import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// node_modules/@canvasjs/charts/canvasjs.min.js
var require_canvasjs_min = __commonJS({
  "node_modules/@canvasjs/charts/canvasjs.min.js"(exports, module) {
    (function() {
      function oa(g, t) {
        g.prototype = cb(t.prototype);
        g.prototype.constructor = g;
        g.base = t.prototype;
      }
      function cb(g) {
        function t() {
        }
        t.prototype = g;
        return new t();
      }
      function Wa(g, t, l2) {
        "millisecond" === l2 ? g.setMilliseconds(g.getMilliseconds() + 1 * t) : "second" === l2 ? g.setSeconds(g.getSeconds() + 1 * t) : "minute" === l2 ? g.setMinutes(g.getMinutes() + 1 * t) : "hour" === l2 ? g.setHours(g.getHours() + 1 * t) : "day" === l2 ? g.setDate(g.getDate() + 1 * t) : "week" === l2 ? g.setDate(g.getDate() + 7 * t) : "month" === l2 ? g.setMonth(g.getMonth() + 1 * t) : "year" === l2 && g.setFullYear(g.getFullYear() + 1 * t);
        return g;
      }
      function ga(g, t) {
        var l2 = false;
        0 > g && (l2 = true, g *= -1);
        g = "" + g;
        for (t = t ? t : 1; g.length < t; ) g = "0" + g;
        return l2 ? "-" + g : g;
      }
      function Fa(g) {
        if (!g) return g;
        g = g.replace(/^\s\s*/, "");
        for (var t = /\s/, l2 = g.length; t.test(g.charAt(--l2)); ) ;
        return g.slice(0, l2 + 1);
      }
      function ya(g) {
        g.roundRect = function(g2, l2, r2, S, na, B, u2, C2) {
          u2 && (this.fillStyle = u2);
          C2 && (this.strokeStyle = C2);
          "undefined" === typeof na && (na = 5);
          na = Math.min(na, Math.min(r2, S) / 2);
          this.lineWidth = B;
          this.beginPath();
          this.moveTo(g2 + na, l2);
          this.lineTo(g2 + r2 - na, l2);
          this.quadraticCurveTo(g2 + r2, l2, g2 + r2, l2 + na);
          this.lineTo(g2 + r2, l2 + S - na);
          this.quadraticCurveTo(g2 + r2, l2 + S, g2 + r2 - na, l2 + S);
          this.lineTo(g2 + na, l2 + S);
          this.quadraticCurveTo(g2, l2 + S, g2, l2 + S - na);
          this.lineTo(g2, l2 + na);
          this.quadraticCurveTo(g2, l2, g2 + na, l2);
          this.closePath();
          u2 && this.fill();
          C2 && 0 < B && this.stroke();
        };
      }
      function Qa(g, t) {
        return g - t;
      }
      function T(g) {
        var t = ((g & 16711680) >> 16).toString(16), l2 = ((g & 65280) >> 8).toString(16);
        g = ((g & 255) >> 0).toString(16);
        t = 2 > t.length ? "0" + t : t;
        l2 = 2 > l2.length ? "0" + l2 : l2;
        g = 2 > g.length ? "0" + g : g;
        return "#" + t + l2 + g;
      }
      function db(g, t) {
        var l2 = this.length >>> 0, r2 = Number(t) || 0, r2 = 0 > r2 ? Math.ceil(r2) : Math.floor(r2);
        for (0 > r2 && (r2 += l2); r2 < l2; r2++) if (r2 in this && this[r2] === g) return r2;
        return -1;
      }
      function l(g) {
        return null === g || "undefined" === typeof g;
      }
      function Ca(g) {
        g.indexOf || (g.indexOf = db);
        return g;
      }
      function eb(g) {
        if (ta.fSDec) g[ia("`eeDwdouMhrudods")](ia("e`u`@ohl`uhnoHuds`uhnoDoe"), function() {
          ta._fTWm && ta._fTWm(g);
        });
      }
      function Xa(g, t, l2) {
        l2 = l2 || "normal";
        var r2 = g + "_" + t + "_" + l2, S = Ya[r2];
        if (isNaN(S)) {
          try {
            if (!qa) {
              var na = document.body;
              qa = document.createElement("span");
              qa.innerHTML = "";
              var B = document.createTextNode("Mpgyi");
              qa.appendChild(B);
              na.appendChild(qa);
            }
            qa.style.display = "";
            P(qa, { position: "absolute", left: "0px", top: "-20000px", padding: "0px", margin: "0px", border: "none", whiteSpace: "pre", lineHeight: "normal", fontFamily: g, fontSize: t + "px", fontWeight: l2 });
            S = Math.round(qa.offsetHeight);
            qa.style.display = "none";
          } catch (u2) {
            S = Math.ceil(1.1 * t);
          }
          S = Math.max(S, t);
          Ya[r2] = S;
        }
        return S;
      }
      function K(g, t) {
        var l2 = [];
        if (l2 = {
          solid: [],
          shortDash: [3, 1],
          shortDot: [1, 1],
          shortDashDot: [3, 1, 1, 1],
          shortDashDotDot: [3, 1, 1, 1, 1, 1],
          dot: [1, 2],
          dash: [4, 2],
          dashDot: [4, 2, 1, 2],
          longDash: [8, 2],
          longDashDot: [8, 2, 1, 2],
          longDashDotDot: [8, 2, 1, 2, 1, 2]
        }[g || "solid"]) for (var r2 = 0; r2 < l2.length; r2++) l2[r2] *= t;
        else l2 = [];
        return l2;
      }
      function M(g, t, wa, r2, S) {
        r2 = r2 || [];
        S = l(S) ? fb ? { passive: false, capture: false } : false : S;
        r2.push([g, t, wa, S]);
        return g.addEventListener ? (g.addEventListener(t, wa, S), wa) : g.attachEvent ? (r2 = function(t2) {
          t2 = t2 || window.event;
          t2.preventDefault = t2.preventDefault || function() {
            t2.returnValue = false;
          };
          t2.stopPropagation = t2.stopPropagation || function() {
            t2.cancelBubble = true;
          };
          wa.call(
            g,
            t2
          );
        }, g.attachEvent("on" + t, r2), r2) : false;
      }
      function gb(g) {
        if (g._menuButton) g.exportEnabled ? (P(g._menuButton, { backgroundColor: g.toolbar.itemBackgroundColor, color: g.toolbar.fontColor }), Ka(g._menuButton), ra(g, g._menuButton, "menu"), 0 >= navigator.userAgent.search("MSIE") && g._menuButton.childNodes[0] && P(g._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" })) : ua(g._menuButton);
        else if (g.exportEnabled && r) {
          var t = false;
          g._menuButton = document.createElement("button");
          ra(g, g._menuButton, "menu");
          g._toolBar.appendChild(g._menuButton);
          M(g._menuButton, "touchstart", function(g2) {
            t = true;
          }, g.allDOMEventHandlers);
          M(g._menuButton, "click", function() {
            "none" !== g._dropdownMenu.style.display || g._dropDownCloseTime && 500 >= (/* @__PURE__ */ new Date()).getTime() - g._dropDownCloseTime.getTime() || (g._dropdownMenu.style.display = "block", g._menuButton.blur(), g._dropdownMenu.focus());
          }, g.allDOMEventHandlers, true);
          M(g._menuButton, "mousemove", function() {
            t || (P(g._menuButton, { backgroundColor: g.toolbar.itemBackgroundColorOnHover, color: g.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search("MSIE") && P(g._menuButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
          }, g.allDOMEventHandlers, true);
          M(g._menuButton, "mouseout", function() {
            t || (P(g._menuButton, { backgroundColor: g.toolbar.itemBackgroundColor, color: g.toolbar.fontColor }), 0 >= navigator.userAgent.search("MSIE") && P(g._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
          }, g.allDOMEventHandlers, true);
        }
        if (g.exportEnabled && g._dropdownMenu) {
          var l2 = g.theme && -1 !== g.theme.indexOf("dark") ? "black" : "#888888";
          P(
            g._dropdownMenu,
            { backgroundColor: g.toolbar.itemBackgroundColor, color: g.toolbar.fontColor, boxShadow: "2px 2px 10px " + l2 }
          );
          for (var l2 = g._dropdownMenu.childNodes, E = [g._cultureInfo.printText, g._cultureInfo.saveJPGText, g._cultureInfo.savePNGText], S = 0; S < E.length; S++) P(l2[S], { backgroundColor: g.toolbar.itemBackgroundColor, color: g.toolbar.fontColor }), l2[S].innerHTML = E[S];
        } else !g._dropdownMenu && (g.exportEnabled && r) && (t = false, g._dropdownMenu = document.createElement("div"), g._dropdownMenu.setAttribute("tabindex", -1), l2 = g.theme && -1 !== g.theme.indexOf("dark") ? "black" : "#888888", P(g._dropdownMenu, { position: "absolute", zIndex: 1, userSelect: "none", MozUserSeelct: "none", WebkitUserSelect: "none", msUserSelect: "none", cursor: "pointer", right: "0px", top: "25px", minWidth: "120px", outline: 0, fontSize: "14px", fontFamily: "Arial, Helvetica, sans-serif", padding: "5px 0px 5px 0px", textAlign: "left", lineHeight: "10px", backgroundColor: g.toolbar.itemBackgroundColor, boxShadow: "2px 2px 10px " + l2 }), g._dropdownMenu.style.display = "none", g._toolBar.appendChild(g._dropdownMenu), M(
          g._dropdownMenu,
          "blur",
          function() {
            ua(g._dropdownMenu);
            g._dropDownCloseTime = /* @__PURE__ */ new Date();
          },
          g.allDOMEventHandlers,
          true
        ), l2 = document.createElement("div"), P(l2, { padding: "12px 8px 12px 8px" }), l2.innerHTML = g._cultureInfo.printText, l2.style.backgroundColor = g.toolbar.itemBackgroundColor, l2.style.color = g.toolbar.fontColor, g._dropdownMenu.appendChild(l2), M(l2, "touchstart", function(g2) {
          t = true;
        }, g.allDOMEventHandlers), M(
          l2,
          "mousemove",
          function() {
            t || (this.style.backgroundColor = g.toolbar.itemBackgroundColorOnHover, this.style.color = g.toolbar.fontColorOnHover);
          },
          g.allDOMEventHandlers,
          true
        ), M(l2, "mouseout", function() {
          t || (this.style.backgroundColor = g.toolbar.itemBackgroundColor, this.style.color = g.toolbar.fontColor);
        }, g.allDOMEventHandlers, true), M(l2, "click", function() {
          g.print();
          ua(g._dropdownMenu);
        }, g.allDOMEventHandlers, true), l2 = document.createElement("div"), P(l2, { padding: "12px 8px 12px 8px" }), l2.innerHTML = g._cultureInfo.saveJPGText, l2.style.backgroundColor = g.toolbar.itemBackgroundColor, l2.style.color = g.toolbar.fontColor, g._dropdownMenu.appendChild(l2), M(l2, "touchstart", function(g2) {
          t = true;
        }, g.allDOMEventHandlers), M(l2, "mousemove", function() {
          t || (this.style.backgroundColor = g.toolbar.itemBackgroundColorOnHover, this.style.color = g.toolbar.fontColorOnHover);
        }, g.allDOMEventHandlers, true), M(l2, "mouseout", function() {
          t || (this.style.backgroundColor = g.toolbar.itemBackgroundColor, this.style.color = g.toolbar.fontColor);
        }, g.allDOMEventHandlers, true), M(l2, "click", function() {
          g.exportChart({ format: "jpeg", fileName: g.exportFileName });
          ua(g._dropdownMenu);
        }, g.allDOMEventHandlers, true), l2 = document.createElement("div"), P(l2, { padding: "12px 8px 12px 8px" }), l2.innerHTML = g._cultureInfo.savePNGText, l2.style.backgroundColor = g.toolbar.itemBackgroundColor, l2.style.color = g.toolbar.fontColor, g._dropdownMenu.appendChild(l2), M(l2, "touchstart", function(g2) {
          t = true;
        }, g.allDOMEventHandlers), M(l2, "mousemove", function() {
          t || (this.style.backgroundColor = g.toolbar.itemBackgroundColorOnHover, this.style.color = g.toolbar.fontColorOnHover);
        }, g.allDOMEventHandlers, true), M(l2, "mouseout", function() {
          t || (this.style.backgroundColor = g.toolbar.itemBackgroundColor, this.style.color = g.toolbar.fontColor);
        }, g.allDOMEventHandlers, true), M(l2, "click", function() {
          g.exportChart({ format: "png", fileName: g.exportFileName });
          ua(g._dropdownMenu);
        }, g.allDOMEventHandlers, true));
      }
      function Za(g, t, l2) {
        g *= ka;
        t *= ka;
        g = l2.getImageData(g, t, 2, 2).data;
        t = true;
        for (l2 = 0; 4 > l2; l2++) if (g[l2] !== g[l2 + 4] | g[l2] !== g[l2 + 8] | g[l2] !== g[l2 + 12]) {
          t = false;
          break;
        }
        return t ? g[0] << 16 | g[1] << 8 | g[2] : 0;
      }
      function W(g, t, l2) {
        return g in t ? t[g] : l2[g];
      }
      function La(g, t, wa, E) {
        r && $a ? (E = !l(E) && E ? g.getContext("2d", { willReadFrequently: true }) : g.getContext("2d"), Ma = E.webkitBackingStorePixelRatio || E.mozBackingStorePixelRatio || E.msBackingStorePixelRatio || E.oBackingStorePixelRatio || E.backingStorePixelRatio || 1, ka = Ra / Ma, g.width = t * ka, g.height = wa * ka, Ra !== Ma && (g.style.width = t + "px", g.style.height = wa + "px", E.scale(ka, ka))) : (g.width = t, g.height = wa);
      }
      function hb(g) {
        if (!ib) {
          var t = false, l2 = false;
          "undefined" === typeof pa.Chart.creditHref ? (g.creditHref = ia("iuuqr;..b`ow`rkr/bnl."), g.creditText = ia("B`ow`rKR/bnl")) : (t = g.updateOption("creditText"), l2 = g.updateOption("creditHref"));
          if (g.creditHref && g.creditText) {
            g._creditLink || (g._creditLink = document.createElement("a"), g._creditLink.setAttribute("class", "canvasjs-chart-credit"), g._creditLink.setAttribute("title", "JavaScript Charts"), P(g._creditLink, { outline: "none", margin: "0px", position: "absolute", right: "2px", top: g.height - 14 + "px", color: "dimgrey", textDecoration: "none", fontSize: "11px", fontFamily: "Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif" }), g._creditLink.setAttribute("tabIndex", -1), g._creditLink.setAttribute("target", "_blank"));
            if (0 === g.renderCount || t || l2) g._creditLink.setAttribute("href", g.creditHref), g._creditLink.innerHTML = g.creditText;
            g._creditLink && g.creditHref && g.creditText ? (g._creditLink.parentElement || g._canvasJSContainer.appendChild(g._creditLink), g._creditLink.style.top = g.height - 14 + "px") : g._creditLink.parentElement && g._canvasJSContainer.removeChild(g._creditLink);
          }
        }
      }
      function sa(g, t, l2) {
        Ga && (this.canvasCount |= 0, window.console.log(++this.canvasCount));
        var E = document.createElement("canvas");
        E.setAttribute("class", "canvasjs-chart-canvas");
        La(E, g, t, l2);
        r || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(E);
        return E;
      }
      function P(g, t) {
        for (var l2 in t) g.style[l2] = t[l2];
      }
      function ab(g) {
        return g.currentStyle ? g.currentStyle : window && window.getComputedStyle ? window.getComputedStyle(g, null) : g.style;
      }
      function ra(g, t, l2) {
        t.getAttribute("state") || (t.style.backgroundColor = g.toolbar.itemBackgroundColor, t.style.color = g.toolbar.fontColor, t.style.border = "none", P(t, { WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" }));
        t.getAttribute("state") !== l2 && (t.setAttribute("state", l2), t.setAttribute("type", "button"), P(t, { padding: "5px 12px", cursor: "pointer", "float": "left", width: "40px", height: "25px", outline: "0px", verticalAlign: "baseline", lineHeight: "0" }), t.innerHTML = "<img src='" + jb[l2].image + "' alt='" + g._cultureInfo[l2 + "Text"] + "' />", P(t.childNodes[0], { height: "95%", pointerEvents: "none" }));
        t.setAttribute("title", g._cultureInfo[l2 + "Text"]);
      }
      function Ka() {
        for (var g = null, t = 0; t < arguments.length; t++) g = arguments[t], g.style && (g.style.display = "inline");
      }
      function ua() {
        for (var g = null, t = 0; t < arguments.length; t++) (g = arguments[t]) && g.style && (g.style.display = "none");
      }
      function Sa(g, t, l2, r2, S) {
        if (null === g || "undefined" === typeof g) return "undefined" === typeof l2 ? t : l2;
        g = parseFloat(g.toString()) * (0 <= g.toString().indexOf("%") ? t / 100 : 1);
        "undefined" !== typeof r2 && (g = Math.min(r2, g), "undefined" !== typeof S && (g = Math.max(S, g)));
        return !isNaN(g) && g <= t && 0 <= g ? g : "undefined" === typeof l2 ? t : l2;
      }
      function U(g, t, r2, E, S) {
        this._defaultsKey = g;
        this._themeOptionsKey = t;
        this._index = E;
        this.parent = S;
        this._eventListeners = [];
        g = {};
        this.theme && l(this.parent) && l(t) && l(E) ? g = l(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[t]) && (null === E ? g = this.parent.themeOptions[t] : 0 < this.parent.themeOptions[t].length && (E = Math.min(this.parent.themeOptions[t].length - 1, E), g = this.parent.themeOptions[t][E]));
        this.themeOptions = g;
        this.options = r2 ? r2 : { _isPlaceholder: true };
        this.setOptions(this.options, g);
      }
      function Da(g, t, l2, r2, S) {
        "undefined" === typeof S && (S = 0);
        this._padding = S;
        this._x1 = g;
        this._y1 = t;
        this._x2 = l2;
        this._y2 = r2;
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      }
      function ja(g, t) {
        ja.base.constructor.call(this, "TextBlock", null, t, null, null);
        this.ctx = g;
        this._isDirty = true;
        this._wrappedText = null;
        this._initialize();
      }
      function Ta(g, t) {
        Ta.base.constructor.call(this, "Toolbar", "toolbar", t, null, g);
        this.chart = g;
        this.canvas = g.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "toolbar";
      }
      function za(g, t) {
        za.base.constructor.call(this, "Title", "title", t, null, g);
        this.chart = g;
        this.canvas = g.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "title";
        if (l(this.options.margin) && g.options.subtitles) {
          for (var r2 = g.options.subtitles, E = 0; E < r2.length; E++) if ((l(r2[E].horizontalAlign) && "center" === this.horizontalAlign || r2[E].horizontalAlign === this.horizontalAlign) && (l(r2[E].verticalAlign) && "top" === this.verticalAlign || r2[E].verticalAlign === this.verticalAlign) && !r2[E].dockInsidePlotArea === !this.dockInsidePlotArea) {
            this.margin = 0;
            break;
          }
        }
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function Ha(g, t, l2) {
        Ha.base.constructor.call(this, "Subtitle", "subtitles", t, l2, g);
        this.chart = g;
        this.canvas = g.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "subtitles";
        this.isOptionsInArray = true;
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function Ua() {
        this.pool = [];
      }
      function Ia(g) {
        var t;
        g && Ja[g] && (t = Ja[g]);
        Ia.base.constructor.call(this, "CultureInfo", null, t, null, null);
      }
      var Ga = false, ta = {}, r = !!document.createElement("canvas").getContext, pa = { Chart: {
        width: 500,
        height: 400,
        zoomEnabled: false,
        zoomType: "x",
        backgroundColor: "white",
        theme: "light1",
        animationEnabled: false,
        animationDuration: 1200,
        dataPointWidth: null,
        dataPointMinWidth: null,
        dataPointMaxWidth: null,
        colorSet: "colorSet1",
        culture: "en",
        creditText: "CanvasJS",
        interactivityEnabled: true,
        exportEnabled: false,
        exportFileName: "Chart",
        rangeChanging: null,
        rangeChanged: null,
        publicProperties: { title: "readWrite", subtitles: "readWrite", toolbar: "readWrite", toolTip: "readWrite", legend: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly", selectedColorSet: "readOnly" }
      }, Title: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 20,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: r ? "transparent" : null,
        margin: 5,
        wrap: true,
        maxWidth: null,
        textAlign: "center",
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Subtitle: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 14,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: null,
        margin: 2,
        wrap: true,
        maxWidth: null,
        textAlign: "center",
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Toolbar: { itemBackgroundColor: "white", itemBackgroundColorOnHover: "#2196f3", buttonBorderColor: "#2196f3", buttonBorderThickness: 1, fontColor: "black", fontColorOnHover: "white", publicProperties: { options: "readWrite", chart: "readOnly" } }, Legend: {
        name: null,
        verticalAlign: "center",
        horizontalAlign: "right",
        fontSize: 14,
        fontFamily: "calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        cursor: null,
        itemmouseover: null,
        itemmouseout: null,
        itemmousemove: null,
        itemclick: null,
        dockInsidePlotArea: false,
        reversed: false,
        backgroundColor: r ? "transparent" : null,
        borderColor: r ? "transparent" : null,
        borderThickness: 0,
        cornerRadius: 0,
        maxWidth: null,
        maxHeight: null,
        markerMargin: null,
        itemMaxWidth: null,
        itemWidth: null,
        itemWrap: true,
        itemTextAlign: "left",
        itemTextFormatter: null,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, ToolTip: {
        enabled: true,
        shared: false,
        animationEnabled: true,
        content: null,
        contentFormatter: null,
        reversed: false,
        backgroundColor: r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
        borderColor: null,
        borderThickness: 2,
        cornerRadius: 5,
        fontSize: 14,
        fontColor: "black",
        fontFamily: "Calibri, Arial, Georgia, serif;",
        fontWeight: "normal",
        fontStyle: "italic",
        updated: null,
        hidden: null,
        publicProperties: { options: "readWrite", chart: "readOnly" }
      }, Axis: {
        minimum: null,
        maximum: null,
        viewportMinimum: null,
        viewportMaximum: null,
        interval: null,
        intervalType: null,
        reversed: false,
        logarithmic: false,
        logarithmBase: 10,
        title: null,
        titleFontColor: "black",
        titleFontSize: 20,
        titleFontFamily: "arial",
        titleFontWeight: "normal",
        titleFontStyle: "normal",
        titleWrap: true,
        titleMaxWidth: null,
        titleBackgroundColor: r ? "transparent" : null,
        titleBorderColor: r ? "transparent" : null,
        titleBorderThickness: 0,
        titleCornerRadius: 0,
        titleTextAlign: "left",
        titlePadding: 0,
        labelAngle: 0,
        labelFontFamily: "arial",
        labelFontColor: "black",
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelAutoFit: true,
        labelWrap: true,
        labelMaxWidth: null,
        labelFormatter: null,
        labelBackgroundColor: r ? "transparent" : null,
        labelBorderColor: r ? "transparent" : null,
        labelBorderThickness: 0,
        labelPadding: 0,
        labelCornerRadius: 0,
        labelPlacement: "outside",
        labelTextAlign: "left",
        prefix: "",
        suffix: "",
        includeZero: false,
        tickLength: 5,
        tickColor: "black",
        tickThickness: 1,
        tickPlacement: "outside",
        lineColor: "black",
        lineThickness: 1,
        lineDashType: "solid",
        gridColor: "#A0A0A0",
        gridThickness: 0,
        gridDashType: "solid",
        interlacedColor: r ? "transparent" : null,
        valueFormatString: null,
        margin: 2,
        publicProperties: {
          options: "readWrite",
          stripLines: "readWrite",
          scaleBreaks: "readWrite",
          crosshair: "readWrite",
          bounds: "readOnly",
          chart: "readOnly"
        }
      }, StripLine: {
        value: null,
        startValue: null,
        endValue: null,
        color: "orange",
        opacity: null,
        thickness: 2,
        lineDashType: "solid",
        label: "",
        labelPlacement: "inside",
        labelAlign: "far",
        labelWrap: true,
        labelMaxWidth: null,
        labelBackgroundColor: null,
        labelBorderColor: r ? "transparent" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelFontFamily: "arial",
        labelFontColor: "orange",
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelFormatter: null,
        labelTextAlign: "left",
        labelPadding: 0,
        showOnTop: false,
        publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, ScaleBreaks: { autoCalculate: false, collapsibleThreshold: "25%", maxNumberOfAutoBreaks: 2, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", customBreaks: "readWrite", axis: "readOnly", autoBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" } }, Break: {
        startValue: null,
        endValue: null,
        spacing: 8,
        type: "straight",
        color: "#FFFFFF",
        fillOpacity: 0.9,
        lineThickness: 2,
        lineColor: "#E16E6E",
        lineDashType: "solid",
        publicProperties: { options: "readWrite", scaleBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, Crosshair: { enabled: false, snapToDataPoint: false, color: "grey", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelWrap: true, labelMaxWidth: null, labelTextAlign: "left", labelBackgroundColor: r ? "grey" : null, labelBorderColor: r ? "grey" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: r ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontSize: 12, labelPadding: { top: 2, right: 3, bottom: 2, left: 4 }, labelFontColor: "#fff", labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, valueFormatString: null, updated: null, hidden: null, publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" } }, DataSeries: {
        name: null,
        dataPoints: null,
        label: "",
        bevelEnabled: false,
        highlightEnabled: true,
        cursor: "default",
        indexLabel: "",
        indexLabelPlacement: "auto",
        indexLabelOrientation: "horizontal",
        indexLabelTextAlign: "left",
        indexLabelFontColor: "black",
        indexLabelFontSize: 12,
        indexLabelFontStyle: "normal",
        indexLabelFontFamily: "Arial",
        indexLabelFontWeight: "normal",
        indexLabelPadding: 0,
        indexLabelBackgroundColor: null,
        indexLabelBorderColor: null,
        indexLabelBorderThickness: 0,
        indexLabelLineColor: "gray",
        indexLabelLineThickness: 1,
        indexLabelLineDashType: "solid",
        indexLabelMaxWidth: null,
        indexLabelWrap: true,
        indexLabelFormatter: null,
        lineThickness: 2,
        lineDashType: "solid",
        connectNullData: false,
        nullDataLineDashType: "dash",
        color: null,
        lineColor: null,
        risingColor: "white",
        fallingColor: "red",
        fillOpacity: null,
        startAngle: 0,
        radius: null,
        innerRadius: null,
        explodeOnClick: true,
        neckHeight: null,
        neckWidth: null,
        reversed: false,
        valueRepresents: null,
        linkedDataSeriesIndex: null,
        whiskerThickness: 2,
        whiskerDashType: "solid",
        whiskerColor: null,
        whiskerLength: null,
        stemThickness: 2,
        stemColor: null,
        stemDashType: "solid",
        upperBoxColor: "white",
        lowerBoxColor: "white",
        type: "column",
        xValueType: "number",
        axisXType: "primary",
        axisYType: "primary",
        axisXIndex: 0,
        axisYIndex: 0,
        xValueFormatString: null,
        yValueFormatString: null,
        zValueFormatString: null,
        percentFormatString: null,
        showInLegend: false,
        legendMarkerType: null,
        legendMarkerColor: null,
        legendText: null,
        legendMarkerBorderColor: r ? "transparent" : null,
        legendMarkerBorderThickness: 0,
        markerType: "circle",
        markerColor: null,
        markerSize: null,
        markerBorderColor: r ? "transparent" : null,
        markerBorderThickness: 0,
        mouseover: null,
        mouseout: null,
        mousemove: null,
        click: null,
        toolTipContent: null,
        visible: true,
        publicProperties: {
          options: "readWrite",
          axisX: "readWrite",
          axisY: "readWrite",
          chart: "readOnly"
        }
      }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: "", horizontalAlign: "center", textAlign: "left", fontSize: 12, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, textBaseline: "top" }, CultureInfo: {
        decimalSeparator: ".",
        digitGroupSeparator: ",",
        zoomText: "Zoom",
        panText: "Pan",
        resetText: "Reset",
        menuText: "More Options",
        saveJPGText: "Save as JPEG",
        savePNGText: "Save as PNG",
        printText: "Print",
        days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
      } }, Ja = { en: {} }, u = r ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", Ea = r ? "Impact, Charcoal, sans-serif" : "Arial", Aa = {
        colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "),
        colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "),
        colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")
      }, F, ba, Q, da, ha;
      ba = "#333333";
      Q = "#000000";
      F = "#666666";
      ha = da = "#000000";
      var fa = 20, C = 14, Va = {
        colorSet: "colorSet1",
        backgroundColor: "#FFFFFF",
        title: {
          fontFamily: Ea,
          fontSize: 32,
          fontColor: ba,
          fontWeight: "normal",
          verticalAlign: "top",
          margin: 5
        },
        subtitles: [{ fontFamily: Ea, fontSize: C, fontColor: ba, fontWeight: "normal", verticalAlign: "top", margin: 5 }],
        data: [{ indexLabelFontFamily: u, indexLabelFontSize: C, indexLabelFontColor: ba, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }],
        axisX: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: ba, titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: F, tickThickness: 1, tickColor: F, gridThickness: 0, gridColor: F, stripLines: [{
          labelFontFamily: u,
          labelFontSize: C,
          labelFontColor: "#FF7300",
          labelFontWeight: "normal",
          labelBackgroundColor: null,
          color: "#FF7300",
          thickness: 1
        }], crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }],
        axisX2: [{
          titleFontFamily: u,
          titleFontSize: fa,
          titleFontColor: ba,
          titleFontWeight: "normal",
          labelFontFamily: u,
          labelFontSize: C,
          labelFontColor: Q,
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: F,
          tickThickness: 1,
          tickColor: F,
          gridThickness: 0,
          gridColor: F,
          stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
          crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" },
          scaleBreaks: {
            type: "zigzag",
            spacing: "2%",
            lineColor: "#BBBBBB",
            lineThickness: 1,
            lineDashType: "solid"
          }
        }],
        axisY: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: ba, titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: F, tickThickness: 1, tickColor: F, gridThickness: 1, gridColor: F, stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
          labelFontFamily: u,
          labelFontSize: C,
          labelFontColor: "#EEEEEE",
          labelFontWeight: "normal",
          labelBackgroundColor: ha,
          color: da,
          thickness: 1,
          lineDashType: "dash"
        }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }],
        axisY2: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: ba, titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: F, tickThickness: 1, tickColor: F, gridThickness: 1, gridColor: F, stripLines: [{
          labelFontFamily: u,
          labelFontSize: C,
          labelFontColor: "#FF7300",
          labelFontWeight: "normal",
          labelBackgroundColor: null,
          color: "#FF7300",
          thickness: 1
        }], crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }],
        legend: { fontFamily: u, fontSize: 14, fontColor: ba, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" },
        toolTip: { fontFamily: u, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 },
        toolbar: { itemBackgroundColor: "white", itemBackgroundColorOnHover: "#2196f3", buttonBorderColor: "#2196f3", buttonBorderThickness: 1, fontColor: "black", fontColorOnHover: "white" }
      };
      Q = ba = "#F5F5F5";
      F = "#FFFFFF";
      da = "#40BAF1";
      ha = "#F5F5F5";
      var fa = 20, C = 14, bb = { colorSet: "colorSet2", title: { fontFamily: u, fontSize: 33, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: u, fontSize: C, fontColor: "#3A3A3A", fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{
        indexLabelFontFamily: u,
        indexLabelFontSize: C,
        indexLabelFontColor: "#666666",
        indexLabelFontWeight: "normal",
        indexLabelLineThickness: 1
      }], axisX: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickThickness: 1, tickColor: "#BBBBBB", gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: "#FFA500",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FFA500",
        thickness: 1
      }], crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisX2: [{
        titleFontFamily: u,
        titleFontSize: fa,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: "#BBBBBB",
        tickColor: "#BBBBBB",
        tickThickness: 1,
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
      }], axisY: [{
        titleFontFamily: u,
        titleFontSize: fa,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: "#BBBBBB",
        tickColor: "#BBBBBB",
        tickThickness: 1,
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: {
          labelFontFamily: u,
          labelFontSize: C,
          labelFontColor: "#EEEEEE",
          labelFontWeight: "normal",
          labelBackgroundColor: "black",
          color: "black",
          thickness: 1,
          lineDashType: "dot"
        },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
      }], axisY2: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: "#FFA500",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FFA500",
        thickness: 1
      }], crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], legend: { fontFamily: u, fontSize: 14, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: {
        fontFamily: u,
        fontSize: 14,
        fontStyle: "normal",
        cornerRadius: 0,
        borderThickness: 1
      }, toolbar: { itemBackgroundColor: "white", itemBackgroundColorOnHover: "#2196f3", buttonBorderColor: "#2196f3", buttonBorderThickness: 1, fontColor: "black", fontColorOnHover: "white" } };
      Q = ba = "#F5F5F5";
      F = "#FFFFFF";
      da = "#40BAF1";
      ha = "#F5F5F5";
      fa = 20;
      C = 14;
      Ea = { colorSet: "colorSet1", backgroundColor: "#2A2A2A", title: { fontFamily: Ea, fontSize: 32, fontColor: ba, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{
        fontFamily: Ea,
        fontSize: C,
        fontColor: ba,
        fontWeight: "normal",
        verticalAlign: "top",
        margin: 5
      }], toolbar: { itemBackgroundColor: "#666666", itemBackgroundColorOnHover: "#FF7372", buttonBorderColor: "#FF7372", buttonBorderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{ indexLabelFontFamily: u, indexLabelFontSize: C, indexLabelFontColor: Q, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
        titleFontFamily: u,
        titleFontSize: fa,
        titleFontColor: Q,
        titleFontWeight: "normal",
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: Q,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: F,
        tickThickness: 1,
        tickColor: F,
        gridThickness: 0,
        gridColor: F,
        stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
      }], axisX2: [{
        titleFontFamily: u,
        titleFontSize: fa,
        titleFontColor: Q,
        titleFontWeight: "normal",
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: Q,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: F,
        tickThickness: 1,
        tickColor: F,
        gridThickness: 0,
        gridColor: F,
        stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: {
          labelFontFamily: u,
          labelFontSize: C,
          labelFontColor: "#000000",
          labelFontWeight: "normal",
          labelBackgroundColor: ha,
          color: da,
          thickness: 1,
          lineDashType: "dash"
        },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
      }], axisY: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: F, tickThickness: 1, tickColor: F, gridThickness: 1, gridColor: F, stripLines: [{
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY2: [{
        titleFontFamily: u,
        titleFontSize: fa,
        titleFontColor: Q,
        titleFontWeight: "normal",
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: Q,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: F,
        tickThickness: 1,
        tickColor: F,
        gridThickness: 1,
        gridColor: F,
        stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
      }], legend: {
        fontFamily: u,
        fontSize: 14,
        fontColor: ba,
        fontWeight: "bold",
        verticalAlign: "bottom",
        horizontalAlign: "center"
      }, toolTip: { fontFamily: u, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: Q, backgroundColor: "rgba(0, 0, 0, .7)" } };
      F = "#FFFFFF";
      Q = ba = "#FAFAFA";
      da = "#40BAF1";
      ha = "#F5F5F5";
      var fa = 20, C = 14, Na = { light1: Va, light2: bb, dark1: Ea, dark2: { colorSet: "colorSet2", backgroundColor: "#32373A", title: { fontFamily: u, fontSize: 32, fontColor: ba, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{
        fontFamily: u,
        fontSize: C,
        fontColor: ba,
        fontWeight: "normal",
        verticalAlign: "top",
        margin: 5
      }], toolbar: { itemBackgroundColor: "#666666", itemBackgroundColorOnHover: "#FF7372", buttonBorderColor: "#FF7372", buttonBorderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{ indexLabelFontFamily: u, indexLabelFontSize: C, indexLabelFontColor: Q, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
        titleFontFamily: u,
        titleFontSize: fa,
        titleFontColor: Q,
        titleFontWeight: "normal",
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: Q,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: F,
        tickThickness: 1,
        tickColor: F,
        gridThickness: 0,
        gridColor: F,
        stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#777777",
          lineThickness: 1,
          lineDashType: "solid",
          color: "#111111"
        }
      }], axisX2: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: F, tickThickness: 1, tickColor: F, gridThickness: 0, gridColor: F, stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ha,
        color: da,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY: [{ titleFontFamily: u, titleFontSize: fa, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: u, labelFontSize: C, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 0, lineColor: F, tickThickness: 1, tickColor: F, gridThickness: 1, gridColor: F, stripLines: [{
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY2: [{
        titleFontFamily: u,
        titleFontSize: fa,
        titleFontColor: Q,
        titleFontWeight: "normal",
        labelFontFamily: u,
        labelFontSize: C,
        labelFontColor: Q,
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: F,
        tickThickness: 1,
        tickColor: F,
        gridThickness: 1,
        gridColor: F,
        stripLines: [{ labelFontFamily: u, labelFontSize: C, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: u, labelFontSize: C, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
      }], legend: {
        fontFamily: u,
        fontSize: 14,
        fontColor: ba,
        fontWeight: "bold",
        verticalAlign: "bottom",
        horizontalAlign: "center"
      }, toolTip: { fontFamily: u, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: Q, backgroundColor: "rgba(0, 0, 0, .7)" } }, theme1: Va, theme2: bb, theme3: Va }, V = { numberDuration: 1, yearDuration: 314496e5, monthDuration: 2592e6, weekDuration: 6048e5, dayDuration: 864e5, hourDuration: 36e5, minuteDuration: 6e4, secondDuration: 1e3, millisecondDuration: 1, dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ") };
      (function() {
        ta.fSDec = function(g) {
          for (var t = "", l2 = 0; l2 < g.length; l2++) t += String.fromCharCode(Math.ceil(g.length / 57 / 5) ^ g.charCodeAt(l2));
          return t;
        };
        delete pa[ta.fSDec("Bi`su")][ta.fSDec("bsdehuIsdg")];
        ta.pro = { sCH: pa[ta.fSDec("Bi`su")][ta.fSDec("bsdehuIsdg")] };
      })();
      var fb = function() {
        var g = false;
        try {
          var t = Object.defineProperty && Object.defineProperty({}, "passive", { get: function() {
            g = true;
            return false;
          } });
          window.addEventListener && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
        } catch (l2) {
          g = false;
        }
        return g;
      }(), Ya = {}, qa = null, kb = function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height));
      }, xa = function(g) {
        g.width = 1;
        g.height = 1;
        g.getContext("2d") && g.getContext("2d").clearRect(0, 0, 1, 1);
      }, lb = function(g, t, l2) {
        t = Math.min(this.width, this.height);
        return Math.max("theme4" === this.theme ? 0 : 300 <= t ? 12 : 11, Math.round(t * (g / 400)));
      }, Ba = function() {
        var g = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, t = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), l2 = "Sun Mon Tue Wed Thu Fri Sat".split(" "), r2 = "January February March April May June July August September October November December".split(" "), S = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), u2 = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, B = /[^-+\dA-Z]/g;
        return function(C2, K2, F2) {
          var T2 = F2 ? F2.days : t, M2 = F2 ? F2.months : r2, V2 = F2 ? F2.shortDays : l2, P2 = F2 ? F2.shortMonths : S;
          F2 = "";
          var U2 = false;
          C2 = C2 && C2.getTime ? C2 : C2 ? new Date(C2) : /* @__PURE__ */ new Date();
          if (isNaN(C2)) throw SyntaxError("invalid date");
          "UTC:" === K2.slice(0, 4) && (K2 = K2.slice(4), U2 = true);
          F2 = U2 ? "getUTC" : "get";
          var Q2 = C2[F2 + "Date"](), O = C2[F2 + "Day"](), X = C2[F2 + "Month"](), a = C2[F2 + "FullYear"](), e = C2[F2 + "Hours"](), c = C2[F2 + "Minutes"](), b = C2[F2 + "Seconds"](), d = C2[F2 + "Milliseconds"](), f = U2 ? 0 : C2.getTimezoneOffset();
          return F2 = K2.replace(g, function(q) {
            switch (q) {
              case "D":
                return Q2;
              case "DD":
                return ga(Q2, 2);
              case "DDD":
                return V2[O];
              case "DDDD":
                return T2[O];
              case "M":
                return X + 1;
              case "MM":
                return ga(X + 1, 2);
              case "MMM":
                return P2[X];
              case "MMMM":
                return M2[X];
              case "Y":
                return parseInt(String(a).slice(-2));
              case "YY":
                return ga(String(a).slice(-2), 2);
              case "YYY":
                return ga(String(a).slice(-3), 3);
              case "YYYY":
                return ga(a, 4);
              case "h":
                return e % 12 || 12;
              case "hh":
                return ga(e % 12 || 12, 2);
              case "H":
                return e;
              case "HH":
                return ga(e, 2);
              case "m":
                return c;
              case "mm":
                return ga(c, 2);
              case "s":
                return b;
              case "ss":
                return ga(b, 2);
              case "f":
                return ga(String(d), 3).slice(0, 1);
              case "ff":
                return ga(String(d), 3).slice(
                  0,
                  2
                );
              case "fff":
                return ga(String(d), 3).slice(0, 3);
              case "t":
                return 12 > e ? "a" : "p";
              case "tt":
                return 12 > e ? "am" : "pm";
              case "T":
                return 12 > e ? "A" : "P";
              case "TT":
                return 12 > e ? "AM" : "PM";
              case "K":
                return U2 ? "UTC" : (String(C2).match(u2) || [""]).pop().replace(B, "");
              case "z":
                return (0 < f ? "-" : "+") + Math.floor(Math.abs(f) / 60);
              case "zz":
                return (0 < f ? "-" : "+") + ga(Math.floor(Math.abs(f) / 60), 2);
              case "zzz":
                return (0 < f ? "-" : "+") + ga(Math.floor(Math.abs(f) / 60), 2) + ga(Math.abs(f) % 60, 2);
              default:
                return q.slice(1, q.length - 1);
            }
          });
        };
      }(), mb = function(g) {
        var t = 0 > g;
        if (1 > Math.abs(g)) {
          var l2 = parseInt(g.toString().split("e-")[1]);
          l2 && (g = (t ? -1 * g : g) * Math.pow(10, l2 - 1), g = "0." + Array(l2).join("0") + g.toString().substring(2), g = t ? "-" + g : g);
        } else l2 = parseInt(g.toString().split("+")[1]), 20 < l2 && (l2 -= 20, g /= Math.pow(10, l2), g = g.toString() + Array(l2 + 1).join("0"));
        return String(g);
      }, ea = function(g, l2, r2) {
        if (null === g) return "";
        if (!isFinite(g)) return g;
        g = Number(g);
        var E = 0 > g ? true : false;
        E && (g *= -1);
        var S = r2 ? r2.decimalSeparator : ".", u2 = r2 ? r2.digitGroupSeparator : ",", B = "";
        l2 = String(l2);
        var B = 1, C2 = r2 = "", F2 = -1, K2 = [], T2 = [], M2 = 0, V2 = 0, P2 = 0, U2 = false, Q2 = 0, C2 = l2.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
        l2 = null;
        for (var O = 0; C2 && O < C2.length; O++) if (l2 = C2[O], "." === l2 && 0 > F2) F2 = O;
        else {
          if ("%" === l2) B *= 100;
          else if ("" === l2) {
            B *= 1e3;
            continue;
          } else if ("," === l2[0] && "." === l2[l2.length - 1]) {
            B /= Math.pow(1e3, l2.length - 1);
            F2 = O + l2.length - 1;
            continue;
          } else "E" !== l2[0] && "e" !== l2[0] || "0" !== l2[l2.length - 1] || (U2 = true);
          0 > F2 ? (K2.push(l2), "#" === l2 || "0" === l2 ? M2++ : "," === l2 && P2++) : (T2.push(l2), "#" !== l2 && "0" !== l2 || V2++);
        }
        U2 && (l2 = Math.floor(g), C2 = -Math.floor(Math.log(g) / Math.LN10 + 1), Q2 = 0 === g ? 0 : 0 === l2 ? -(M2 + C2) : mb(l2).length - M2, B /= Math.pow(10, Q2));
        0 > F2 && (F2 = O);
        B = (g * B).toFixed(V2);
        l2 = B.split(".");
        B = (l2[0] + "").split("");
        g = (l2[1] + "").split("");
        B && "0" === B[0] && B.shift();
        for (U2 = C2 = O = V2 = F2 = 0; 0 < K2.length; ) if (l2 = K2.pop(), "#" === l2 || "0" === l2) if (F2++, F2 === M2) {
          var X = B, B = [];
          if ("0" === l2) for (l2 = M2 - V2 - (X ? X.length : 0); 0 < l2; ) X.unshift("0"), l2--;
          for (; 0 < X.length; ) r2 = X.pop() + r2, U2++, 0 === U2 % C2 && (O === P2 && 0 < X.length) && (r2 = u2 + r2);
        } else 0 < B.length ? (r2 = B.pop() + r2, V2++, U2++) : "0" === l2 && (r2 = "0" + r2, V2++, U2++), 0 === U2 % C2 && (O === P2 && 0 < B.length) && (r2 = u2 + r2);
        else "E" !== l2[0] && "e" !== l2[0] || "0" !== l2[l2.length - 1] || !/[eE][+-]*[0]+/.test(l2) ? "," === l2 ? (O++, C2 = U2, U2 = 0, 0 < B.length && (r2 = u2 + r2)) : r2 = 1 < l2.length && ('"' === l2[0] && '"' === l2[l2.length - 1] || "'" === l2[0] && "'" === l2[l2.length - 1]) ? l2.slice(1, l2.length - 1) + r2 : l2 + r2 : (l2 = 0 > Q2 ? l2.replace("+", "").replace("-", "") : l2.replace("-", ""), r2 += l2.replace(/[0]+/, function(a) {
          return ga(Q2, a.length);
        }));
        u2 = "";
        for (K2 = false; 0 < T2.length; ) l2 = T2.shift(), "#" === l2 || "0" === l2 ? 0 < g.length && 0 !== Number(g.join("")) ? (u2 += g.shift(), K2 = true) : "0" === l2 && (u2 += "0", K2 = true) : 1 < l2.length && ('"' === l2[0] && '"' === l2[l2.length - 1] || "'" === l2[0] && "'" === l2[l2.length - 1]) ? u2 += l2.slice(1, l2.length - 1) : "E" !== l2[0] && "e" !== l2[0] || "0" !== l2[l2.length - 1] || !/[eE][+-]*[0]+/.test(l2) ? u2 += l2 : (l2 = 0 > Q2 ? l2.replace("+", "").replace("-", "") : l2.replace("-", ""), u2 += l2.replace(/[0]+/, function(a) {
          return ga(Q2, a.length);
        }));
        r2 += (K2 ? S : "") + u2;
        return E ? "-" + r2 : r2;
      }, Oa = function(g) {
        var l2 = 0, r2 = 0;
        g = g || window.event;
        g.offsetX || 0 === g.offsetX ? (l2 = g.offsetX, r2 = g.offsetY) : g.layerX || 0 == g.layerX ? (l2 = g.layerX, r2 = g.layerY) : (l2 = g.pageX - g.target.offsetLeft, r2 = g.pageY - g.target.offsetTop);
        return { x: l2, y: r2 };
      }, $a = true, Ra = window.devicePixelRatio || 1, Ma = 1, ka = $a ? Ra / Ma : 1, Y = function(g, l2, r2, E, u2, C2, B, F2, K2, T2, U2, V2, M2) {
        "undefined" === typeof M2 && (M2 = 1);
        B = B || 0;
        F2 = F2 || "black";
        var P2 = 15 < E - l2 && 15 < u2 - r2 ? 8 : 0.35 * Math.min(E - l2, u2 - r2);
        g.beginPath();
        g.moveTo(l2, r2);
        g.save();
        g.fillStyle = C2;
        g.globalAlpha = M2;
        g.fillRect(l2, r2, E - l2, u2 - r2);
        g.globalAlpha = 1;
        0 < B && (M2 = 0 === B % 2 ? 0 : 0.5, g.beginPath(), g.lineWidth = B, g.strokeStyle = F2, g.moveTo(l2, r2), g.rect(l2 - M2, r2 - M2, E - l2 + 2 * M2, u2 - r2 + 2 * M2), g.stroke());
        g.restore();
        true === K2 && (g.save(), g.beginPath(), g.moveTo(l2, r2), g.lineTo(l2 + P2, r2 + P2), g.lineTo(E - P2, r2 + P2), g.lineTo(E, r2), g.closePath(), B = g.createLinearGradient((E + l2) / 2, r2 + P2, (E + l2) / 2, r2), B.addColorStop(0, C2), B.addColorStop(1, "rgba(255, 255, 255, .4)"), g.fillStyle = B, g.fill(), g.restore());
        true === T2 && (g.save(), g.beginPath(), g.moveTo(l2, u2), g.lineTo(l2 + P2, u2 - P2), g.lineTo(E - P2, u2 - P2), g.lineTo(E, u2), g.closePath(), B = g.createLinearGradient((E + l2) / 2, u2 - P2, (E + l2) / 2, u2), B.addColorStop(0, C2), B.addColorStop(1, "rgba(255, 255, 255, .4)"), g.fillStyle = B, g.fill(), g.restore());
        true === U2 && (g.save(), g.beginPath(), g.moveTo(l2, r2), g.lineTo(l2 + P2, r2 + P2), g.lineTo(l2 + P2, u2 - P2), g.lineTo(l2, u2), g.closePath(), B = g.createLinearGradient(l2 + P2, (u2 + r2) / 2, l2, (u2 + r2) / 2), B.addColorStop(0, C2), B.addColorStop(1, "rgba(255, 255, 255, 0.1)"), g.fillStyle = B, g.fill(), g.restore());
        true === V2 && (g.save(), g.beginPath(), g.moveTo(E, r2), g.lineTo(E - P2, r2 + P2), g.lineTo(E - P2, u2 - P2), g.lineTo(E, u2), B = g.createLinearGradient(E - P2, (u2 + r2) / 2, E, (u2 + r2) / 2), B.addColorStop(0, C2), B.addColorStop(1, "rgba(255, 255, 255, 0.1)"), g.fillStyle = B, B.addColorStop(0, C2), B.addColorStop(1, "rgba(255, 255, 255, 0.1)"), g.fillStyle = B, g.fill(), g.closePath(), g.restore());
      }, ia = function(g) {
        for (var l2 = "", r2 = 0; r2 < g.length; r2++) l2 += String.fromCharCode(Math.ceil(g.length / 57 / 5) ^ g.charCodeAt(r2));
        return l2;
      }, ib = window && (window[ia("mnb`uhno")] && window[ia("mnb`uhno")].href && window[ia("mnb`uhno")].href.indexOf && (-1 !== window[ia("mnb`uhno")].href.indexOf(ia("b`ow`rkr/bnl")) || -1 !== window[ia("mnb`uhno")].href.indexOf(ia("gdonqhy/bnl")) || -1 !== window[ia("mnb`uhno")].href.indexOf(ia("gheemd")))) && -1 === window[ia("mnb`uhno")].href.indexOf(ia("gheemd")), jb = {
        reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==" },
        pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC" },
        zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=" },
        menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC" }
      };
      U.prototype.setOptions = function(g, l2) {
        if (pa[this._defaultsKey]) {
          var r2 = pa[this._defaultsKey], E;
          for (E in r2) "publicProperties" !== E && r2.hasOwnProperty(E) && (this[E] = g && E in g ? g[E] : l2 && E in l2 ? l2[E] : r2[E]);
        } else Ga && window.console && console.log("defaults not set");
      };
      U.prototype.get = function(g) {
        var l2 = pa[this._defaultsKey];
        if ("options" === g) return this.options && this.options._isPlaceholder ? null : this.options;
        if (l2.hasOwnProperty(g) || l2.publicProperties && l2.publicProperties.hasOwnProperty(g)) return this[g];
        window.console && window.console.log('Property "' + g + `" doesn't exist. Please check for typo.`);
      };
      U.prototype.set = function(g, l2, r2) {
        r2 = "undefined" === typeof r2 ? true : r2;
        var E = pa[this._defaultsKey];
        if ("options" === g) this.createUserOptions(l2);
        else if (E.hasOwnProperty(g) || E.publicProperties && E.publicProperties.hasOwnProperty(g) && "readWrite" === E.publicProperties[g]) this.options._isPlaceholder && this.createUserOptions(), this.options[g] = l2;
        else {
          window.console && (E.publicProperties && E.publicProperties.hasOwnProperty(g) && "readOnly" === E.publicProperties[g] ? window.console.log('Property "' + g + '" is read-only.') : window.console.log('Property "' + g + `" doesn't exist. Please check for typo.`));
          return;
        }
        r2 && (this.stockChart || this.chart || this).render();
      };
      U.prototype.addTo = function(g, l2, r2, E) {
        E = "undefined" === typeof E ? true : E;
        var u2 = pa[this._defaultsKey];
        u2.hasOwnProperty(g) || u2.publicProperties && u2.publicProperties.hasOwnProperty(g) && "readWrite" === u2.publicProperties[g] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[g] && (this.options[g] = []), g = this.options[g], r2 = "undefined" === typeof r2 || null === r2 ? g.length : r2, g.splice(r2, 0, l2), E && (this.stockChart || this.chart || this).render()) : window.console && (u2.publicProperties && u2.publicProperties.hasOwnProperty(g) && "readOnly" === u2.publicProperties[g] ? window.console.log('Property "' + g + '" is read-only.') : window.console.log('Property "' + g + `" doesn't exist. Please check for typo.`));
      };
      U.prototype.createUserOptions = function(g) {
        if ("undefined" !== typeof g || this.options._isPlaceholder) if (this.parent && this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {
          this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);
          var l2 = this.parent.options[this.optionsName], r2 = l2.length;
          this.options._isPlaceholder || (Ca(l2), r2 = l2.indexOf(this.options));
          this.options = "undefined" === typeof g ? {} : g;
          l2[r2] = this.options;
        } else this.options = "undefined" === typeof g ? {} : g, this.parent && (g = this.parent.options, this.optionsName ? l2 = this.optionsName : (l2 = this._defaultsKey) && 0 !== l2.length ? (r2 = l2.charAt(0).toLowerCase(), 1 < l2.length && (r2 = r2.concat(l2.slice(1))), l2 = r2) : l2 = void 0, g[l2] = this.options);
      };
      U.prototype.remove = function(g) {
        g = "undefined" === typeof g ? true : g;
        if (this.isOptionsInArray) {
          var l2 = this.parent.options[this.optionsName];
          Ca(l2);
          var r2 = l2.indexOf(this.options);
          0 <= r2 && l2.splice(r2, 1);
        } else delete this.parent.options[this.optionsName];
        g && (this.stockChart || this.chart || this).render();
      };
      U.prototype.updateOption = function(g) {
        !pa[this._defaultsKey] && (Ga && window.console) && console.log("defaults not set");
        var r2 = pa[this._defaultsKey], u2 = {}, E = this[g], C2 = this._themeOptionsKey, F2 = this._index;
        this.theme && l(this.parent) && l(C2) && l(F2) ? u2 = l(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && this.parent.themeOptions && (this.options.theme ? "Chart" === this._defaultsKey && Na[this.options.theme] ? u2 = Na[this.options.theme] : stockThemes[this.options.theme] && (u2 = stockThemes[this.options.theme][C2]) : this.parent.themeOptions[C2] && (null === F2 ? u2 = this.parent.themeOptions[C2] : 0 < this.parent.themeOptions[C2].length && (u2 = Math.min(this.parent.themeOptions[C2].length - 1, F2), u2 = this.parent.themeOptions[C2][u2])));
        this.themeOptions = u2;
        g in r2 && (E = g in this.options ? this.options[g] : u2 && g in u2 ? u2[g] : r2[g]);
        if (E === this[g]) return false;
        this[g] = E;
        return true;
      };
      U.prototype.trackChanges = function(g) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        this.sessionVariables[g] = this.options[g];
      };
      U.prototype.isBeingTracked = function(g) {
        this.options._oldOptions || (this.options._oldOptions = {});
        return this.options._oldOptions[g] ? true : false;
      };
      U.prototype.hasOptionChanged = function(g) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        return this.sessionVariables[g] !== this.options[g];
      };
      U.prototype.addEventListener = function(g, l2, r2) {
        g && l2 && (this._eventListeners[g] = this._eventListeners[g] || [], this._eventListeners[g].push({ context: r2 || this, eventHandler: l2 }));
      };
      U.prototype.removeEventListener = function(l2, r2) {
        if (l2 && r2 && this._eventListeners[l2]) {
          for (var u2 = this._eventListeners[l2], E = 0; E < u2.length; E++) if (u2[E].eventHandler === r2) {
            u2[E].splice(E, 1);
            break;
          }
        }
      };
      U.prototype.removeAllEventListeners = function() {
        this._eventListeners = [];
      };
      U.prototype.dispatchEvent = function(l2, r2, u2) {
        if (l2 && this._eventListeners[l2]) {
          r2 = r2 || {};
          for (var E = this._eventListeners[l2], C2 = 0; C2 < E.length; C2++) E[C2].eventHandler.call(E[C2].context, r2);
        }
        "function" === typeof this[l2] && this[l2].call(u2 || this.chart, r2);
      };
      Da.prototype.registerSpace = function(l2, r2) {
        "top" === l2 ? this._topOccupied += r2.height : "bottom" === l2 ? this._bottomOccupied += r2.height : "left" === l2 ? this._leftOccupied += r2.width : "right" === l2 && (this._rightOccupied += r2.width);
      };
      Da.prototype.unRegisterSpace = function(l2, r2) {
        "top" === l2 ? this._topOccupied -= r2.height : "bottom" === l2 ? this._bottomOccupied -= r2.height : "left" === l2 ? this._leftOccupied -= r2.width : "right" === l2 && (this._rightOccupied -= r2.width);
      };
      Da.prototype.getFreeSpace = function() {
        return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied };
      };
      Da.prototype.reset = function() {
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      };
      oa(ja, U);
      ja.prototype._initialize = function() {
        l(this.padding) || "object" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = l(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = l(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = l(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = l(this.padding.left) ? 0 : Number(this.padding.left) | 0);
      };
      ja.prototype.render = function(l2) {
        if (0 !== this.fontSize) {
          l2 && this.ctx.save();
          var r2 = this.ctx.font;
          this.ctx.textBaseline = this.textBaseline;
          var u2 = 0;
          this._isDirty && this.measureText(this.ctx);
          this.ctx.translate(this.x, this.y + u2);
          "middle" === this.textBaseline && (u2 = -this._lineHeight / 2);
          this.ctx.font = this._getFontString();
          this.ctx.rotate(Math.PI / 180 * this.angle);
          var E = 0, C2 = this.topPadding, F2 = null;
          this.ctx.roundRect || ya(this.ctx);
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(
            0,
            u2,
            this.width,
            this.height,
            this.cornerRadius,
            this.borderThickness,
            this.backgroundColor,
            this.borderColor
          );
          this.ctx.fillStyle = this.fontColor;
          for (u2 = 0; u2 < this._wrappedText.lines.length; u2++) F2 = this._wrappedText.lines[u2], "right" === this.textAlign ? E = this.width - F2.width - this.rightPadding : "left" === this.textAlign ? E = this.leftPadding : "center" === this.textAlign && (E = (this.width - (this.leftPadding + this.rightPadding)) / 2 - F2.width / 2 + this.leftPadding), this.ctx.fillText(F2.text, E, C2), C2 += F2.height;
          this.ctx.font = r2;
          l2 && this.ctx.restore();
        }
      };
      ja.prototype.setText = function(l2) {
        this.text = l2;
        this._isDirty = true;
        this._wrappedText = null;
      };
      ja.prototype.measureText = function() {
        this._lineHeight = Xa(this.fontFamily, this.fontSize, this.fontWeight);
        if (null === this.maxWidth) throw "Please set maxWidth and height for TextBlock";
        this._wrapText(this.ctx);
        this._isDirty = false;
        return { width: this.width, height: this.height };
      };
      ja.prototype._getLineWithWidth = function(l2, r2, u2) {
        l2 = String(l2);
        if (!l2) return { text: "", width: 0 };
        var E = u2 = 0, C2 = l2.length - 1, F2 = Infinity;
        for (this.ctx.font = this._getFontString(); E <= C2; ) {
          var F2 = Math.floor((E + C2) / 2), B = l2.substr(0, F2 + 1);
          u2 = this.ctx.measureText(B).width;
          if (u2 < r2) E = F2 + 1;
          else if (u2 > r2) C2 = F2 - 1;
          else break;
        }
        u2 > r2 && 1 < B.length && (B = B.substr(0, B.length - 1), u2 = this.ctx.measureText(B).width);
        r2 = true;
        if (B.length === l2.length || " " === l2[B.length]) r2 = false;
        r2 && (l2 = B.split(" "), 1 < l2.length && l2.pop(), B = l2.join(" "), u2 = this.ctx.measureText(B).width);
        return { text: B, width: u2 };
      };
      ja.prototype._wrapText = function() {
        var l2 = new String(Fa(String(this.text))), r2 = [], u2 = this.ctx.font, E = 0, C2 = 0;
        this.ctx.font = this._getFontString();
        if (0 === this.frontSize) C2 = E = 0;
        else for (; 0 < l2.length; ) {
          var F2 = this.maxHeight - (this.topPadding + this.bottomPadding), B = this._getLineWithWidth(l2, this.maxWidth - (this.leftPadding + this.rightPadding), false);
          B.height = this._lineHeight;
          r2.push(B);
          var K2 = C2, C2 = Math.max(C2, B.width), E = E + B.height, l2 = Fa(l2.slice(B.text.length, l2.length));
          F2 && E > F2 && (B = r2.pop(), E -= B.height, C2 = K2);
        }
        this._wrappedText = { lines: r2, width: C2, height: E };
        this.width = C2 + (this.leftPadding + this.rightPadding);
        this.height = E + (this.topPadding + this.bottomPadding);
        this.ctx.font = u2;
      };
      ja.prototype._getFontString = function() {
        var l2;
        l2 = this.fontStyle ? this.fontStyle + " " : "";
        l2 += this.fontWeight ? this.fontWeight + " " : "";
        l2 += this.fontSize ? this.fontSize + "px " : "";
        var t = this.fontFamily ? this.fontFamily + "" : "";
        !r && t && (t = t.split(",")[0], "'" !== t[0] && '"' !== t[0] && (t = "'" + t + "'"));
        return l2 += t;
      };
      oa(Ta, U);
      oa(za, U);
      za.prototype.setLayout = function() {
        if (this.text) {
          var g = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, r2 = g.layoutManager.getFreeSpace(), u2 = r2.x1, E = r2.y1, C2 = 0, E = 0, u2 = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 40 : 0, F2;
          this.textAlign = l(this.options.textAlign) ? this.horizontalAlign : this.textAlign;
          "center" === this.verticalAlign ? "left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = r2.height - 4), E = 0.5 * r2.width - this.margin - 2) : (null === this.maxWidth && (this.maxWidth = r2.width - 4), E = 0.5 * r2.height - 4) : (null === this.maxWidth && (this.maxWidth = r2.width - 4 - u2 * ("center" === this.horizontalAlign ? 2 : 1)), E = 0.5 * r2.height - this.margin - 2, C2 = 0);
          l(this.padding) || "number" !== typeof this.padding ? l(this.padding) || "object" !== typeof this.padding || (F2 = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, F2 += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0) : F2 = 2 * this.padding;
          this.wrap || (E = Math.min(E, 1.5 * this.fontSize + F2));
          var B = new ja(this.ctx, {
            fontSize: this.fontSize,
            fontFamily: this.fontFamily,
            fontColor: this.fontColor,
            fontStyle: this.fontStyle,
            fontWeight: this.fontWeight,
            textAlign: this.textAlign,
            verticalAlign: this.verticalAlign,
            borderColor: this.borderColor,
            borderThickness: this.borderThickness,
            backgroundColor: this.backgroundColor,
            maxWidth: this.maxWidth,
            maxHeight: E,
            cornerRadius: this.cornerRadius,
            text: this.text,
            padding: this.padding,
            textBaseline: "middle"
          }), K2 = B.measureText();
          "center" === this.verticalAlign ? ("left" === this.horizontalAlign ? (u2 = r2.x1 + 2 + B._lineHeight / 2, E = r2.y2 - 2 - (this.maxWidth / 2 - K2.width / 2), C2 = -90, F2 = "left", this.width = K2.height, this.height = K2.width) : "right" === this.horizontalAlign ? (u2 = r2.x2 - 2 - B._lineHeight / 2, E = r2.y1 + 2 + (this.maxWidth / 2 - K2.width / 2), C2 = 90, F2 = "right", this.width = K2.height, this.height = K2.width) : (E = r2.y1 + 2 + (r2.height / 2 - K2.height / 2) + B._lineHeight / 2, u2 = r2.x1 + 2 + (r2.width / 2 - K2.width / 2), F2 = "center", this.width = K2.width, this.height = K2.height), r2 = "center") : ("bottom" === this.verticalAlign ? (E = r2.y2 - 2 - K2.height + B._lineHeight / 2, F2 = "bottom") : (E = r2.y1 + 2 + B._lineHeight / 2, F2 = "top"), u2 = "left" === this.horizontalAlign ? r2.x1 + 2 : "right" === this.horizontalAlign ? r2.x2 - 2 - K2.width - u2 : r2.x1 + r2.width / 2 - K2.width / 2, r2 = this.horizontalAlign, this.width = K2.width, this.height = K2.height);
          B.x = u2;
          B.y = E;
          B.angle = C2;
          B.horizontalAlign = r2;
          this._textBlock = B;
          g.layoutManager.registerSpace(F2, { width: this.width + ("left" === F2 || "right" === F2 ? this.margin + 2 : 0), height: this.height + ("top" === F2 || "bottom" === F2 ? this.margin + 2 : 0) });
          this.bounds = { x1: u2, y1: E - B._lineHeight / 2, x2: u2 + this.width, y2: E + this.height - B._lineHeight / 2 };
          "center" === this.verticalAlign && ("left" === this.horizontalAlign && (this.bounds = { x1: u2 - B._lineHeight / 2, y1: E - this.height, x2: u2 + this.width - B._lineHeight / 2, y2: E }), "right" === this.horizontalAlign && (this.bounds = { x1: u2 - B._lineHeight / 2, y1: E, x2: u2 + this.width - B._lineHeight / 2, y2: E + this.height }));
          this.ctx.textBaseline = "top";
        }
      };
      za.prototype.render = function() {
        this._textBlock && this._textBlock.render(true);
      };
      oa(Ha, U);
      Ha.prototype.setLayout = za.prototype.setLayout;
      Ha.prototype.render = za.prototype.render;
      Ua.prototype.get = function(l2, r2) {
        var u2 = null;
        0 < this.pool.length ? (u2 = this.pool.pop(), La(u2, l2, r2)) : u2 = sa(l2, r2);
        return u2;
      };
      Ua.prototype.release = function(l2) {
        this.pool.push(l2);
      };
      oa(Ia, U);
      var Pa = { addTheme: function(l2, r2) {
        Na[l2] = r2;
      }, addColorSet: function(l2, r2) {
        Aa[l2] = r2;
      }, addCultureInfo: function(l2, r2) {
        Ja[l2] = r2;
      }, formatNumber: function(l2, r2, u2) {
        u2 = u2 || "en";
        if (Ja[u2]) return ea(l2, r2 || "#,##0.##", new Ia(u2));
        throw "Unknown Culture Name";
      }, formatDate: function(l2, r2, u2) {
        u2 = u2 || "en";
        if (Ja[u2]) return Ba(l2, r2 || "DD MMM YYYY", new Ia(u2));
        throw "Unknown Culture Name";
      } };
      "undefined" !== typeof module && "undefined" !== typeof module.exports ? module.exports = Pa : "function" === typeof define && define.amd ? define([], function() {
        return Pa;
      }) : (window.CanvasJS && window.console && window.console.log("CanvasJS namespace already exists. If you are loading both chart and stockchart scripts, just load stockchart alone as it includes all chart features."), window.CanvasJS = window.CanvasJS ? window.CanvasJS : Pa);
      u = Pa.Chart = function() {
        function g(a, e) {
          return a.x - e.x;
        }
        function t(a, e, c) {
          e = e || {};
          l(c) ? (this.predefinedThemes = Na, this.optionsName = this.parent = this.index = null) : (this.parent = c.parent, this.index = c.index, this.predefinedThemes = c.predefinedThemes, this.optionsName = c.optionsName, this.stockChart = c.stockChart, this.panel = a, this.isOptionsInArray = c.isOptionsInArray);
          this.theme = l(e.theme) || l(this.predefinedThemes[e.theme]) ? "light1" : e.theme;
          t.base.constructor.call(
            this,
            "Chart",
            this.optionsName,
            e,
            this.index,
            this.parent
          );
          var b = this;
          this._containerId = a;
          this._objectsInitialized = false;
          this.overlaidCanvasCtx = this.ctx = null;
          this._indexLabels = [];
          this._panTimerId = 0;
          this._lastTouchEventType = "";
          this._lastTouchData = null;
          this.isAnimating = false;
          this.renderCount = 0;
          this.disableToolTip = this.animatedRender = false;
          this.canvasPool = new Ua();
          this.allDOMEventHandlers = [];
          this.panEnabled = false;
          this._defaultCursor = "default";
          this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };
          this._dataInRenderedOrder = [];
          (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this.container.innerHTML = "", e = a = 0, e = ab(this.container), a = this.options.width ? this.width : 0 < this.container.clientWidth - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) ? this.container.clientWidth - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) : this.width, e = c && c.height ? c.height : this.options.height ? this.height : 0 < this.container.clientHeight - parseFloat(e.paddingTop) - parseFloat(e.paddingBottom) ? this.container.clientHeight - parseFloat(e.paddingTop) - parseFloat(e.paddingBottom) : this.height, this.width = a, this.height = e, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this.selectedColorSet = "undefined" !== typeof Aa[this.colorSet] ? Aa[this.colorSet] : Aa.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", this._canvasJSContainer.style.direction = "ltr", r || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), this.canvas = sa(a, e), this._preRenderCanvas = sa(a, e), this.canvas.style.position = "absolute", this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", ya(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", ya(this._preRenderCtx), r ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = sa(a, e), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = sa(a, e), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", ya(this.overlaidCanvasCtx)), this._eventManager = new ha2(this), this.windowResizeHandler = M(window, "resize", function() {
            b._updateSize() && (b.render(), b.isNavigator && (b.stockChart && b.stockChart.navigator && b.stockChart.navigator.enabled) && b.stockChart.navigator._updateSlider(b.stockChart._axisXMin, b.stockChart._axisXMax));
          }, this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), P(this._toolBar, { position: "absolute", right: "1px", top: "1px" }), this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, M(this.overlaidCanvas, "click", function(a2) {
            b._mouseEventHandler(a2);
          }, this.allDOMEventHandlers), M(this.overlaidCanvas, "mousemove", function(a2) {
            b._mouseEventHandler(a2);
          }, this.allDOMEventHandlers), M(this.overlaidCanvas, "mouseup", function(a2) {
            b._mouseEventHandler(a2);
          }, this.allDOMEventHandlers), M(this.overlaidCanvas, "mousedown", function(a2) {
            b._mouseEventHandler(a2);
            ua(b._dropdownMenu);
          }, this.allDOMEventHandlers), M(
            this.overlaidCanvas,
            "mouseout",
            function(a2) {
              b._mouseEventHandler(a2);
            },
            this.allDOMEventHandlers
          ), M(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(a2) {
            b._touchEventHandler(a2);
          }, this.allDOMEventHandlers), M(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(a2) {
            b._touchEventHandler(a2);
          }, this.allDOMEventHandlers), M(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function(a2) {
            b._touchEventHandler(a2);
          }, this.allDOMEventHandlers), M(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function(a2) {
            b._touchEventHandler(a2);
          }, this.allDOMEventHandlers), this.toolTip = new la(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] })) : window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found');
        }
        function u2(a, e) {
          for (var c = [], b, d = 0; d < a.length; d++) if (0 == d) c.push(a[0]);
          else {
            var f, q, w;
            w = d - 1;
            f = 0 === w ? 0 : w - 1;
            q = w === a.length - 1 ? w : w + 1;
            b = Math.abs((a[q].x - a[f].x) / (0 === a[q].x - a[w].x ? 0.01 : a[q].x - a[w].x)) * (e - 1) / 2 + 1;
            var l2 = (a[q].x - a[f].x) / b;
            b = (a[q].y - a[f].y) / b;
            c[c.length] = a[w].x > a[f].x && 0 < l2 || a[w].x < a[f].x && 0 > l2 ? { x: a[w].x + l2 / 3, y: a[w].y + b / 3 } : { x: a[w].x, y: a[w].y + (1 === c.length ? 0 : b / 9) };
            w = d;
            f = 0 === w ? 0 : w - 1;
            q = w === a.length - 1 ? w : w + 1;
            b = Math.abs((a[q].x - a[f].x) / (0 === a[w].x - a[f].x ? 0.01 : a[w].x - a[f].x)) * (e - 1) / 2 + 1;
            l2 = (a[q].x - a[f].x) / b;
            b = (a[q].y - a[f].y) / b;
            c[c.length] = a[w].x > a[f].x && 0 < l2 || a[w].x < a[f].x && 0 > l2 ? { x: a[w].x - l2 / 3, y: a[w].y - b / 3 } : { x: a[w].x, y: a[w].y - b / 9 };
            c[c.length] = a[d];
          }
          return c;
        }
        function C2(a, e, c, b, d, f, q, w, l2, k) {
          var m = 0;
          k ? (q.color = f, w.color = f) : k = 1;
          m = l2 ? Math.abs(d - c) : Math.abs(b - e);
          m = 0 < q.trimLength ? Math.abs(m * q.trimLength / 100) : Math.abs(m - q.length);
          l2 ? (c += m / 2, d -= m / 2) : (e += m / 2, b -= m / 2);
          var m = 1 === Math.round(q.thickness) % 2 ? 0.5 : 0, n = 1 === Math.round(w.thickness) % 2 ? 0.5 : 0;
          a.save();
          a.globalAlpha = k;
          a.strokeStyle = w.color || f;
          a.lineWidth = w.thickness || 2;
          a.setLineDash && a.setLineDash(K(w.dashType, w.thickness));
          a.beginPath();
          l2 && 0 < w.thickness ? (a.moveTo(b - q.thickness / 2, Math.round((c + d) / 2) - n), a.lineTo(e + q.thickness / 2, Math.round((c + d) / 2) - n)) : 0 < w.thickness && (a.moveTo(Math.round((e + b) / 2) - n, c + q.thickness / 2), a.lineTo(Math.round((e + b) / 2) - n, d - q.thickness / 2));
          a.stroke();
          a.strokeStyle = q.color || f;
          a.lineWidth = q.thickness || 2;
          a.setLineDash && a.setLineDash(K(q.dashType, q.thickness));
          a.beginPath();
          l2 && 0 < q.thickness ? (a.moveTo(b - m, c), a.lineTo(b - m, d), a.moveTo(e + m, c), a.lineTo(e + m, d)) : 0 < q.thickness && (a.moveTo(e, c + m), a.lineTo(b, c + m), a.moveTo(e, d - m), a.lineTo(b, d - m));
          a.stroke();
          a.restore();
        }
        function F2(a, e) {
          F2.base.constructor.call(this, "Legend", "legend", e, null, a);
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = this.chart.ctx;
          this.ghostCtx = this.chart._eventManager.ghostCtx;
          this.items = [];
          this.optionsName = "legend";
          this.height = this.width = 0;
          this.orientation = null;
          this.dataSeries = [];
          this.bounds = { x1: null, y1: null, x2: null, y2: null };
          "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
          this.lineHeight = Xa(this.fontFamily, this.fontSize, this.fontWeight);
          this.horizontalSpacing = this.fontSize;
        }
        function Q2(a, e, c, b) {
          Q2.base.constructor.call(this, "DataSeries", "data", e, c, a);
          this.chart = a;
          this.canvas = a.canvas;
          this._ctx = a.canvas.ctx;
          this.index = c;
          this.noDataPointsInPlotArea = 0;
          this.id = b;
          this.chart._eventManager.objectMap[b] = { id: b, objectType: "dataSeries", dataSeriesIndex: c };
          a = e.dataPoints ? e.dataPoints.length : 0;
          this.dataPointEOs = [];
          for (e = 0; e < a; e++) this.dataPointEOs[e] = {};
          this.dataPointIds = [];
          this.plotUnit = [];
          this.axisY = this.axisX = null;
          this.optionsName = "data";
          this.isOptionsInArray = true;
          null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);
          this.axisPlacement = this.getDefaultAxisPlacement();
          "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));
        }
        function B(a, e, c, b, d, f) {
          B.base.constructor.call(this, "Axis", e, c, b, a);
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = a.ctx;
          this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;
          this.labels = [];
          this.dataSeries = [];
          this._stripLineLabels = this._ticks = this._labels = null;
          this.dataInfo = { min: Infinity, max: -Infinity, viewPortMin: Infinity, viewPortMax: -Infinity, minDiff: Infinity };
          this.isOptionsInArray = true;
          "axisX" === d ? ("left" === f || "bottom" === f ? (this.optionsName = "axisX", l(this.chart.sessionVariables.axisX[b]) && (this.chart.sessionVariables.axisX[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[b]) : (this.optionsName = "axisX2", l(this.chart.sessionVariables.axisX2[b]) && (this.chart.sessionVariables.axisX2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[b]), this.options.interval || (this.intervalType = null)) : "left" === f || "bottom" === f ? (this.optionsName = "axisY", l(this.chart.sessionVariables.axisY[b]) && (this.chart.sessionVariables.axisY[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[b]) : (this.optionsName = "axisY2", l(this.chart.sessionVariables.axisY2[b]) && (this.chart.sessionVariables.axisY2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[b]);
          "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));
          "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));
          this.type = d;
          "axisX" !== d || c && "undefined" !== typeof c.gridThickness || (this.gridThickness = 0);
          this._position = f;
          this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null };
          this.labelAngle = (this.labelAngle % 360 + 360) % 360;
          90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);
          this.options.scaleBreaks && (this.scaleBreaks = new fa2(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));
          this.stripLines = [];
          if (this.options.stripLines && 0 < this.options.stripLines.length) for (a = 0; a < this.options.stripLines.length; a++) this.stripLines.push(new ga2(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));
          this.options.crosshair && (this.crosshair = new da2(this.chart, this.options.crosshair, this), this.crosshair._updatedValue = l(this.sessionVariables.crosshairValue) ? null : this.sessionVariables.crosshairValue);
          this._titleTextBlock = null;
          this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);
          this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;
          this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);
          this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;
          null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
          null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(
            this.viewportMaximum,
            this.maximum
          ));
          this.trackChanges("viewportMinimum");
          this.trackChanges("viewportMaximum");
        }
        function fa2(a, e, c, b) {
          fa2.base.constructor.call(this, "ScaleBreaks", "scaleBreaks", e, null, b);
          this.id = c;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.axis = b;
          this.optionsName = "scaleBreaks";
          this.isOptionsInArray = false;
          this._appliedBreaks = [];
          this.customBreaks = [];
          this.autoBreaks = [];
          "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8);
          this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));
          if (this.options.customBreaks && 0 < this.options.customBreaks.length) {
            for (a = 0; a < this.options.customBreaks.length; a++) this.customBreaks.push(new ba2(this.chart, "customBreaks", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[a].startValue && ("number" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]);
            this._appliedBreaks.sort(function(a2, b2) {
              return a2.startValue - b2.startValue;
            });
            for (a = 0; a < this._appliedBreaks.length - 1; a++) this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + a + " and " + (a + 1) + " are overlapping."), this._appliedBreaks.splice(
              a,
              2
            ), a--);
          }
        }
        function ba2(a, e, c, b, d, f) {
          ba2.base.constructor.call(this, "Break", e, c, b, f);
          this.id = d;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.scaleBreaks = f;
          this.optionsName = e;
          this.isOptionsInArray = true;
          this.type = c.type ? this.type : f.type;
          this.fillOpacity = l(c.fillOpacity) ? f.fillOpacity : this.fillOpacity;
          this.lineThickness = l(c.lineThickness) ? f.lineThickness : this.lineThickness;
          this.color = c.color ? this.color : f.color;
          this.lineColor = c.lineColor ? this.lineColor : f.lineColor;
          this.lineDashType = c.lineDashType ? this.lineDashType : f.lineDashType;
          !l(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());
          !l(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());
          "number" === typeof this.startValue && ("number" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue, this.startValue = this.endValue, this.endValue = a);
          this.spacing = "undefined" === typeof c.spacing ? f.spacing : c.spacing;
          "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = f.spacing);
          this.size = f.parent.logarithmic ? 1 : 0;
        }
        function ga2(a, e, c, b, d) {
          ga2.base.constructor.call(this, "StripLine", "stripLines", e, c, d);
          this.id = b;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.label = this.label;
          this.axis = d;
          this.optionsName = "stripLines";
          this.isOptionsInArray = true;
          this._thicknessType = "pixel";
          null !== this.startValue && null !== this.endValue && (this.value = d.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);
        }
        function da2(a, e, c) {
          da2.base.constructor.call(this, "Crosshair", "crosshair", e, null, c);
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.axis = c;
          this.optionsName = "crosshair";
          this._thicknessType = "pixel";
        }
        function la(a, e) {
          la.base.constructor.call(
            this,
            "ToolTip",
            "toolTip",
            e,
            null,
            a
          );
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = this.chart.ctx;
          this.currentDataPointIndex = this.currentSeriesIndex = -1;
          this._prevY = this._prevX = NaN;
          this.containerTransitionDuration = 0.1;
          this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);
          this.optionsName = "toolTip";
          this._initialize();
        }
        function ha2(a) {
          this.chart = a;
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.ghostCanvas = sa(this.chart.width, this.chart.height, true);
          this.ghostCtx = this.ghostCanvas.getContext("2d");
          this.mouseoveredObjectMaps = [];
        }
        function ia2(a) {
          this.chart = a;
          this.ctx = this.chart.plotArea.ctx;
          this.animations = [];
          this.animationRequestId = null;
        }
        oa(t, U);
        t.prototype.destroy = function() {
          var a = this.allDOMEventHandlers;
          this._animator && this._animator.cancelAllAnimations();
          this._panTimerId && clearTimeout(this._panTimerId);
          for (var e = 0; e < a.length; e++) {
            var c = a[e][0], b = a[e][1], d = a[e][2], f = a[e][3], f = f || false;
            c.removeEventListener ? c.removeEventListener(b, d, f) : c.detachEvent && c.detachEvent("on" + b, d);
          }
          this.allDOMEventHandlers = [];
          for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes(); ) this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
          for (; this.container && this.container.hasChildNodes(); ) this.container.removeChild(this.container.lastChild);
          for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes(); ) this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
          this.container = this._canvasJSContainer = null;
          this.toolTip.container = null;
          this.canvas && xa(this.canvas);
          this.overlaidCanvas && xa(this.overlaidCanvas);
          this._preRenderCanvas && xa(this._preRenderCanvas);
          this._breaksCanvas && xa(this._breaksCanvas);
          this._eventManager && this._eventManager.ghostCanvas && xa(this._eventManager.ghostCanvas);
          this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = null;
        };
        t.prototype._updateOptions = function() {
          var a = this;
          this.updateOption("width");
          this.updateOption("height");
          this.updateOption("dataPointWidth");
          this.updateOption("dataPointMinWidth");
          this.updateOption("dataPointMaxWidth");
          this.updateOption("interactivityEnabled");
          this.updateOption("theme");
          this.stockChart && this.stockChart.options && "undefined" !== typeof this.stockChart.options.theme && l(this.options.theme) ? this.theme = this.stockChart.theme : l(this.stockChart) && l(this.theme) && (this.theme = "light1");
          this.updateOption("colorSet") && (this.selectedColorSet = "undefined" !== typeof Aa[this.colorSet] ? Aa[this.colorSet] : Aa.colorSet1);
          this.updateOption("backgroundColor");
          this.stockChart && (this.stockChart.options && "undefined" !== typeof this.stockChart.options.backgroundColor && l(this.options.backgroundColor)) && (this.backgroundColor = this.stockChart.backgroundColor);
          this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)");
          this.updateOption("culture");
          this.stockChart && l(this.options.culture) && (this.culture = this.stockChart.culture);
          this._cultureInfo = new Ia(this.culture);
          this.updateOption("animationEnabled");
          this.animationEnabled = this.animationEnabled && r;
          this.updateOption("animationDuration");
          this.updateOption("rangeChanging");
          this.updateOption("rangeChanged");
          this.updateOption("exportEnabled");
          this.updateOption("exportFileName");
          this.updateOption("zoomType");
          this.toolbar = new Ta(this, this.options.toolbar);
          if (this.stockChart && this.stockChart.options && this.stockChart.options.toolbar && !this.options.toolbar) for (var e in this.stockChart.options.toolbar) this.toolbar[e] = this.stockChart.options.toolbar[e];
          if (this.options.zoomEnabled || this.panEnabled) {
            if (this._zoomButton) P(this._zoomButton, { borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, backgroundColor: a.toolbar.itemBackgroundColor, color: a.toolbar.fontColor }), 0 >= navigator.userAgent.search("MSIE") && this._zoomButton.childNodes[0] && P(this._zoomButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" });
            else {
              var c = false;
              ua(this._zoomButton = document.createElement("button"));
              ra(this, this._zoomButton, "pan");
              this._toolBar.appendChild(this._zoomButton);
              this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor;
              M(this._zoomButton, "touchstart", function(a2) {
                c = true;
              }, this.allDOMEventHandlers);
              M(this._zoomButton, "click", function() {
                a.zoomEnabled ? (a.zoomEnabled = false, a.panEnabled = true, ra(a, a._zoomButton, "zoom")) : (a.zoomEnabled = true, a.panEnabled = false, ra(a, a._zoomButton, "pan"));
                a.render();
              }, this.allDOMEventHandlers);
              M(this._zoomButton, "mousemove", function() {
                c ? c = false : (P(a._zoomButton, {
                  backgroundColor: a.toolbar.itemBackgroundColorOnHover,
                  color: a.toolbar.fontColorOnHover,
                  transition: "0.4s",
                  WebkitTransition: "0.4s"
                }), 0 >= navigator.userAgent.search("MSIE") && P(a._zoomButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
              }, this.allDOMEventHandlers);
              M(this._zoomButton, "mouseout", function() {
                c || (P(a._zoomButton, { backgroundColor: a.toolbar.itemBackgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && P(a._zoomButton.childNodes[0], {
                  WebkitFilter: "invert(0%)",
                  filter: "invert(0%)"
                }));
              }, this.allDOMEventHandlers);
            }
            this._resetButton ? (P(this._resetButton, { borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, backgroundColor: a.toolbar.itemBackgroundColor, color: a.toolbar.fontColor }), 0 >= navigator.userAgent.search("MSIE") && this._resetButton.childNodes[0] && P(this._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }), this._resetButton.title = this._cultureInfo.resetText) : (c = false, ua(this._resetButton = document.createElement("button")), ra(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor, this._toolBar.appendChild(this._resetButton), M(this._resetButton, "touchstart", function(a2) {
              c = true;
            }, this.allDOMEventHandlers), M(this._resetButton, "click", function() {
              a.toolTip.hide();
              a.toolTip && a.toolTip.enabled && a.toolTip.dispatchEvent("hidden", { chart: a, toolTip: a.toolTip }, a.toolTip);
              a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = true, a.panEnabled = false, ra(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = false, a.panEnabled = false);
              if (a.sessionVariables.axisX) for (var b = 0; b < a.sessionVariables.axisX.length; b++) a.sessionVariables.axisX[b].newViewportMinimum = null, a.sessionVariables.axisX[b].newViewportMaximum = null;
              if (a.sessionVariables.axisX2) for (b = 0; b < a.sessionVariables.axisX2.length; b++) a.sessionVariables.axisX2[b].newViewportMinimum = null, a.sessionVariables.axisX2[b].newViewportMaximum = null;
              if (a.sessionVariables.axisY) for (b = 0; b < a.sessionVariables.axisY.length; b++) a.sessionVariables.axisY[b].newViewportMinimum = null, a.sessionVariables.axisY[b].newViewportMaximum = null;
              if (a.sessionVariables.axisY2) for (b = 0; b < a.sessionVariables.axisY2.length; b++) a.sessionVariables.axisY2[b].newViewportMinimum = null, a.sessionVariables.axisY2[b].newViewportMaximum = null;
              a.resetOverlayedCanvas();
              0 >= navigator.userAgent.search("MSIE") && P(a._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" });
              ua(a._zoomButton, a._resetButton);
              a.stockChart && (a.stockChart._rangeEventParameter = { stockChart: a.stockChart, source: "chart", index: a.stockChart.charts.indexOf(a), minimum: null, maximum: null });
              a._dispatchRangeEvent("rangeChanging", "reset");
              a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanging", a.stockChart.dispatchEvent("rangeChanging", a.stockChart._rangeEventParameter, a.stockChart));
              a.render();
              a.syncCharts && a.stockChart && (a.stockChart.rangeUpdatedBy = !a.stockChart.navigator.slider || l(a.stockChart.navigator.slider.options.minimum) && l(a.stockChart.navigator.slider.options.maximum) ? !a.stockChart.rangeSelector.enabled || !a.stockChart.rangeSelector.inputFields.enabled || l(a.stockChart.rangeSelector.inputFields.options.startValue) && l(a.stockChart.rangeSelector.inputFields.options.endValue) ? null : "inputFields" : "navigator", l(a.stockChart._selectedRangeButtonIndex) || (a.stockChart.rangeUpdatedBy = "rangeButton"), a.syncCharts(null, null), a.stockChart.rangeSelector && a.stockChart.rangeSelector.enabled && a.stockChart.rangeSelector.render(), "rangeButton" === a.stockChart.rangeUpdatedBy && a.stockChart.rangeSelector.selectedRangeButtonIndex < a.stockChart.rangeSelector.buttons.length && (b = a.stockChart.rangeSelector.buttons[a.stockChart._selectedRangeButtonIndex], b.enabled && (b.state = "on", b.textBlock.fontWeight = "bold", b.textBlock.fontColor = a.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover, b.textBlock.backgroundColor = a.stockChart.rangeSelector.buttonStyle.backgroundColorOnSelect, a.stockChart.rangeSelector.sessionVariables._clickedRangeButtonIndex = null, b.render())));
              a._dispatchRangeEvent("rangeChanged", "reset");
              a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanged", a.stockChart.dispatchEvent("rangeChanged", a.stockChart._rangeEventParameter, a.stockChart));
            }, this.allDOMEventHandlers), M(this._resetButton, "mousemove", function() {
              c || (P(a._resetButton, { backgroundColor: a.toolbar.itemBackgroundColorOnHover, color: a.toolbar.fontColorOnHover, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && P(
                a._resetButton.childNodes[0],
                { WebkitFilter: "invert(100%)", filter: "invert(100%)" }
              ));
            }, this.allDOMEventHandlers), M(this._resetButton, "mouseout", function() {
              c || (P(a._resetButton, { backgroundColor: a.toolbar.itemBackgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && P(a._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
            }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor);
            this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = true, this.zoomEnabled = false) : (this.zoomEnabled = true, this.panEnabled = false), Ka(a._zoomButton, a._resetButton)) : (this.zoomEnabled = true, this.panEnabled = false));
          } else this.panEnabled = this.zoomEnabled = false;
          gb(this);
          "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? ra(a, a._zoomButton, "zoom") : ra(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && ra(a, a._resetButton, "reset"));
          this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);
          for (e in this.toolTip.options) this.toolTip.options.hasOwnProperty(e) && this.toolTip.updateOption(e);
        };
        t.prototype._updateSize = function() {
          var a;
          a = [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas];
          var e = 0, c = 0, b = ab(this.container);
          this.options.width ? e = this.width : this.width = e = 0 < this.container.clientWidth - parseFloat(b.paddingLeft) - parseFloat(b.paddingRight) ? this.container.clientWidth - parseFloat(b.paddingLeft) - parseFloat(b.paddingRight) : this.width;
          l(this.stockChart) || l(this.index) ? this.options.height ? c = this.height : this.height = c = 0 < this.container.clientHeight - parseFloat(b.paddingTop) - parseFloat(b.paddingBottom) ? this.container.clientHeight - parseFloat(b.paddingTop) - parseFloat(b.paddingBottom) : this.height : c = this.height = this.stockChart._chartsHeight[this.index];
          if (this.canvas.width !== e * ka || this.canvas.height !== c * ka) {
            for (b = 0; b < a.length; b++) La(a[b], e, c);
            this.bounds = {
              x1: 0,
              y1: 0,
              x2: this.width,
              y2: this.height,
              width: this.width,
              height: this.height
            };
            a = true;
          } else a = false;
          return a;
        };
        t.prototype._initialize = function() {
          this.isNavigator = l(this.parent) || l(this.parent._defaultsKey) || "Navigator" !== this.parent._defaultsKey ? false : true;
          this._animator ? this._animator.cancelAllAnimations() : this._animator = new ia2(this);
          this.removeAllEventListeners();
          this.disableToolTip = false;
          this._axes = [];
          this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;
          this._updateOptions();
          this.animatedRender = r && this.animationEnabled && 0 === this.renderCount;
          this._updateSize();
          this.clearCanvas();
          this.ctx.beginPath();
          this.axisX = [];
          this.axisX2 = [];
          this.axisY = [];
          this.axisY2 = [];
          this._indexLabels = [];
          this._dataInRenderedOrder = [];
          this._events = [];
          this._eventManager && this._eventManager.reset();
          this.plotInfo = { axisPlacement: null, plotTypes: [] };
          this.layoutManager = new Da(0, 0, this.width, this.height, this.isNavigator ? 0 : 2);
          this.plotArea.layoutManager && this.plotArea.layoutManager.reset();
          this.data = [];
          this.title = null;
          this.subtitles = [];
          var a = 0, e = null;
          if (this.options.data) {
            for (var c = 0; c < this.options.data.length; c++) if (a++, !this.options.data[c].type || 0 <= t._supportedChartTypes.indexOf(this.options.data[c].type)) {
              var b = new Q2(this, this.options.data[c], a - 1, ++this._eventManager.lastObjectId);
              if (!l(b) && b.dataPoints) {
                for (var d = 0; d < b.dataPoints.length; d++) if (b.dataPoints[d].x && b.dataPoints[d].x.getTime) {
                  b.xValueType = "dateTime";
                  break;
                }
              }
              "error" === b.type && (b.linkedDataSeriesIndex = l(this.options.data[c].linkedDataSeriesIndex) ? c - 1 : this.options.data[c].linkedDataSeriesIndex, 0 > b.linkedDataSeriesIndex || b.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof b.linkedDataSeriesIndex || "error" === this.options.data[b.linkedDataSeriesIndex].type) && (b.linkedDataSeriesIndex = null);
              null === b.name && (b.name = "DataSeries " + a);
              null === b.color ? 1 < this.options.data.length ? (b._colorSet = [this.selectedColorSet[b.index % this.selectedColorSet.length]], b.color = this.selectedColorSet[b.index % this.selectedColorSet.length]) : b._colorSet = "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "candlestick" === b.type || "ohlc" === b.type || "waterfall" === b.type || "boxAndWhisker" === b.type ? [this.selectedColorSet[0]] : this.selectedColorSet : b._colorSet = [b.color];
              null === b.markerSize && (("line" === b.type || "stepLine" === b.type || "spline" === b.type || 0 <= b.type.toLowerCase().indexOf("area")) && b.dataPoints && b.dataPoints.length < this.width / 16 || "scatter" === b.type) && (b.markerSize = 8);
              "bubble" !== b.type && "scatter" !== b.type || !b.dataPoints || (b.dataPoints.some ? b.dataPoints.some(function(a2) {
                return a2.x;
              }) && b.dataPoints.sort(g) : b.dataPoints.sort(g));
              this.data.push(b);
              var d = b.axisPlacement, e = e || d, f;
              "normal" === d ? "xySwapped" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === d ? "normal" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === d ? "normal" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === d && "none" === this.plotInfo.axisPlacement && (f = 'You cannot combine "' + b.type + '" with pie chart');
              if (f && window.console) {
                window.console.log(f);
                return;
              }
            }
            for (c = 0; c < this.data.length; c++) {
              if ("none" == e && "error" === this.data[c].type && window.console) {
                window.console.log('You cannot combine "' + b.type + '" with error chart');
                return;
              }
              "error" === this.data[c].type && (this.data[c].axisPlacement = this.plotInfo.axisPlacement = e || "normal", this.data[c]._linkedSeries = null === this.data[c].linkedDataSeriesIndex ? null : this.data[this.data[c].linkedDataSeriesIndex]);
            }
          }
          this._objectsInitialized = true;
          this._plotAreaElements = [];
        };
        t._supportedChartTypes = Ca("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));
        t.prototype.setLayout = function() {
          for (var a = this._plotAreaElements, e = 0; e < this.data.length; e++) if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
            if (!this.data[e].axisYType || "primary" === this.data[e].axisYType) if (this.options.axisY && 0 < this.options.axisY.length) {
              if (!this.axisY.length) for (var c = 0; c < this.options.axisY.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[c] = new B(this, "axisY", this.options.axisY[c], c, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[c] = new B(this, "axisY", this.options.axisY[c], c, "axisY", "bottom"));
              this.data[e].axisY = this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0];
              this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]);
            } else this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new B(this, "axisY", this.options.axisY, 0, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new B(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[e].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[e]);
            if ("secondary" === this.data[e].axisYType) if (this.options.axisY2 && 0 < this.options.axisY2.length) {
              if (!this.axisY2.length) for (c = 0; c < this.options.axisY2.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[c] = new B(this, "axisY2", this.options.axisY2[c], c, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[c] = new B(this, "axisY2", this.options.axisY2[c], c, "axisY", "top"));
              this.data[e].axisY = this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0];
              this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]);
            } else this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new B(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new B(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[e].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[e]);
            if (!this.data[e].axisXType || "primary" === this.data[e].axisXType) if (this.options.axisX && 0 < this.options.axisX.length) {
              if (!this.axisX.length) for (c = 0; c < this.options.axisX.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[c] = new B(this, "axisX", this.options.axisX[c], c, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[c] = new B(this, "axisX", this.options.axisX[c], c, "axisX", "left"));
              this.data[e].axisX = this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0];
              this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]);
            } else this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new B(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new B(
              this,
              "axisX",
              this.options.axisX,
              0,
              "axisX",
              "left"
            ))), this.data[e].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[e]);
            if ("secondary" === this.data[e].axisXType) if (this.options.axisX2 && 0 < this.options.axisX2.length) {
              if (!this.axisX2.length) for (c = 0; c < this.options.axisX2.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[c] = new B(this, "axisX2", this.options.axisX2[c], c, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[c] = new B(
                this,
                "axisX2",
                this.options.axisX2[c],
                c,
                "axisX",
                "right"
              ));
              this.data[e].axisX = this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0];
              this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]);
            } else this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new B(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new B(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[e].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[e]);
          }
          if (this.axisY) {
            for (c = 1; c < this.axisY.length; c++) "undefined" === typeof this.axisY[c].options.gridThickness && (this.axisY[c].gridThickness = 0);
            for (c = 0; c < this.axisY.length - 1; c++) "undefined" === typeof this.axisY[c].options.margin && (this.axisY[c].margin = 10);
          }
          if (this.axisY2) {
            for (c = 1; c < this.axisY2.length; c++) "undefined" === typeof this.axisY2[c].options.gridThickness && (this.axisY2[c].gridThickness = 0);
            for (c = 0; c < this.axisY2.length - 1; c++) "undefined" === typeof this.axisY2[c].options.margin && (this.axisY2[c].margin = 10);
          }
          this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));
          if (this.axisX) for (c = 0; c < this.axisX.length; c++) "undefined" === typeof this.axisX[c].options.gridThickness && (this.axisX[c].gridThickness = 0);
          if (this.axisX2) for (c = 0; c < this.axisX2.length; c++) "undefined" === typeof this.axisX2[c].options.gridThickness && (this.axisX2[c].gridThickness = 0);
          this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness && "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));
          c = false;
          if (0 < this._axes.length && this.options.zoomEnabled && (this.zoomEnabled || this.panEnabled)) {
            for (e = 0; e < this._axes.length; e++) if (!l(this._axes[e].viewportMinimum) || !l(this._axes[e].viewportMaximum)) {
              c = true;
              break;
            }
          }
          c ? (Ka(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor) : (ua(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = true, this.panEnabled = false));
          eb(this);
          this._processData();
          this.options.title && (this.title = new za(this, this.options.title), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout());
          if (this.options.subtitles) for (e = 0; e < this.options.subtitles.length; e++) c = new Ha(
            this,
            this.options.subtitles[e],
            e
          ), this.subtitles.push(c), c.dockInsidePlotArea ? a.push(c) : c.setLayout();
          this.legend = new F2(this, this.options.legend);
          for (e = 0; e < this.data.length; e++) (this.data[e].showInLegend || "pie" === this.data[e].type || "doughnut" === this.data[e].type || "funnel" === this.data[e].type || "pyramid" === this.data[e].type) && this.legend.dataSeries.push(this.data[e]);
          this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout();
          for (e = 0; e < this._axes.length; e++) if (this._axes[e].scaleBreaks && this._axes[e].scaleBreaks._appliedBreaks.length) {
            r ? (this._breaksCanvas = sa(this.width, this.height, true), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);
            break;
          }
          this._preRenderCanvas = sa(this.width, this.height);
          this._preRenderCtx = this._preRenderCanvas.getContext("2d");
          "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || B.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
        };
        t.prototype.renderElements = function() {
          if (this.height && this.width) {
            var a = this._plotAreaElements;
            this.title && !this.title.dockInsidePlotArea && this.title.render();
            for (var e = 0; e < this.subtitles.length; e++) this.subtitles[e].dockInsidePlotArea || this.subtitles[e].render();
            this.legend.dockInsidePlotArea || this.legend.render();
            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) B.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement);
            else if ("none" === this.plotInfo.axisPlacement) this.preparePlotArea();
            else return;
            for (e = 0; e < a.length; e++) a[e].setLayout(), a[e].render();
            var c = [];
            if (this.animatedRender) {
              var b = sa(this.width, this.height);
              b.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height);
            }
            hb(this);
            var a = this.ctx.miterLimit, d;
            this.ctx.miterLimit = 3;
            r && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), this._preRenderCtx.clearRect(0, 0, this.width, this.height));
            for (e = 0; e < this.plotInfo.plotTypes.length; e++) for (var f = this.plotInfo.plotTypes[e], q = 0; q < f.plotUnits.length; q++) {
              var w = f.plotUnits[q], J = null;
              w.targetCanvas && xa(w.targetCanvas);
              w.targetCanvas = null;
              this.animatedRender && (w.targetCanvas = sa(this.width, this.height), w.targetCanvasCtx = w.targetCanvas.getContext("2d"), d = w.targetCanvasCtx.miterLimit, w.targetCanvasCtx.miterLimit = 3);
              "line" === w.type ? J = this.renderLine(w) : "stepLine" === w.type ? J = this.renderStepLine(w) : "spline" === w.type ? J = this.renderSpline(w) : "column" === w.type ? J = this.renderColumn(w) : "bar" === w.type ? J = this.renderBar(w) : "area" === w.type ? J = this.renderArea(w) : "stepArea" === w.type ? J = this.renderStepArea(w) : "splineArea" === w.type ? J = this.renderSplineArea(w) : "stackedColumn" === w.type ? J = this.renderStackedColumn(w) : "stackedColumn100" === w.type ? J = this.renderStackedColumn100(w) : "stackedBar" === w.type ? J = this.renderStackedBar(w) : "stackedBar100" === w.type ? J = this.renderStackedBar100(w) : "stackedArea" === w.type ? J = this.renderStackedArea(w) : "stackedArea100" === w.type ? J = this.renderStackedArea100(w) : "bubble" === w.type ? J = J = this.renderBubble(w) : "scatter" === w.type ? J = this.renderScatter(w) : "pie" === w.type ? this.renderPie(w) : "doughnut" === w.type ? this.renderPie(w) : "funnel" === w.type ? J = this.renderFunnel(w) : "pyramid" === w.type ? J = this.renderFunnel(w) : "candlestick" === w.type ? J = this.renderCandlestick(w) : "ohlc" === w.type ? J = this.renderCandlestick(w) : "rangeColumn" === w.type ? J = this.renderRangeColumn(w) : "error" === w.type ? J = this.renderError(w) : "rangeBar" === w.type ? J = this.renderRangeBar(w) : "rangeArea" === w.type ? J = this.renderRangeArea(w) : "rangeSplineArea" === w.type ? J = this.renderRangeSplineArea(w) : "waterfall" === w.type ? J = this.renderWaterfall(w) : "boxAndWhisker" === w.type && (J = this.renderBoxAndWhisker(w));
              for (var k = 0; k < w.dataSeriesIndexes.length; k++) this._dataInRenderedOrder.push(this.data[w.dataSeriesIndexes[k]]);
              this.animatedRender && (w.targetCanvasCtx.miterLimit = d, J && c.push(J));
            }
            this.ctx.miterLimit = a;
            this.animatedRender && this._breaksCanvasCtx && c.push({
              source: this._breaksCanvasCtx,
              dest: this.plotArea.ctx,
              animationCallback: O.fadeInAnimation,
              easingFunction: O.easing.easeInQuad,
              animationBase: 0,
              startTimePercent: 0.7
            });
            this.animatedRender && 0 < this._indexLabels.length && (d = sa(this.width, this.height).getContext("2d"), ya(d), c.push(this.renderIndexLabels(d)));
            var m = this;
            if (0 < c.length) m.disableToolTip = true, m._animator.animate(200, m.animationDuration, function(a2) {
              m.ctx.clearRect(0, 0, m.width, m.height);
              m.ctx.drawImage(b, 0, 0, Math.floor(m.width * ka), Math.floor(m.height * ka), 0, 0, m.width, m.height);
              for (var d2 = 0; d2 < c.length; d2++) J = c[d2], 1 > a2 && "undefined" !== typeof J.startTimePercent ? a2 >= J.startTimePercent && J.animationCallback(J.easingFunction(a2 - J.startTimePercent, 0, 1, 1 - J.startTimePercent), J) : J.animationCallback(J.easingFunction(a2, 0, 1, 1), J);
              m.dispatchEvent("dataAnimationIterationEnd", { chart: m });
            }, function() {
              c = [];
              for (var a2 = 0; a2 < m.plotInfo.plotTypes.length; a2++) for (var d2 = m.plotInfo.plotTypes[a2], e2 = 0; e2 < d2.plotUnits.length; e2++) {
                var f2 = d2.plotUnits[e2];
                f2.targetCanvas && xa(f2.targetCanvas);
                f2.targetCanvas = null;
              }
              b = null;
              m.disableToolTip = false;
              m.dispatchEvent("dataAnimationEnd", { chart: m });
            });
            else {
              if (m._breaksCanvas) if (r) m.plotArea.ctx.drawImage(m._breaksCanvas, 0, 0, this.width, this.height);
              else for (k = 0; k < m._axes.length; k++) m._axes[k].createMask();
              0 < m._indexLabels.length && m.renderIndexLabels();
              m.dispatchEvent("dataAnimationIterationEnd", { chart: m });
              m.dispatchEvent("dataAnimationEnd", { chart: m });
            }
            this.attachPlotAreaEventHandlers();
            this.zoomEnabled || (this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display) || ua(
              this._zoomButton,
              this._resetButton
            );
            l(this.toolTip._xValue) || l(this.toolTip._dataSeriesIndex) || this.toolTip.showAtX(this.toolTip._xValue, this.toolTip._dataSeriesIndex);
            this.toolTip._updateToolTip();
            this.toolTip.enabled && this.toolTip._updatedEventParameters && !isNaN(this.toolTip._prevX) && !isNaN(this.toolTip._prevY) && this.toolTip.container && this.toolTip.container.style && this.toolTip.dispatchEvent("none" === this.toolTip.container.style.display ? "hidden" : "updated", this.toolTip._updatedEventParameters, this.toolTip);
            this.renderCount++;
            Ga && (m = this, setTimeout(function() {
              var a2 = document.getElementById("ghostCanvasCopy");
              a2 && (La(a2, m.width, m.height), a2.getContext("2d").drawImage(m._eventManager.ghostCanvas, 0, 0));
            }, 2e3));
            this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);
            for (k = 0; k < this._axes.length; k++) this._axes[k].maskCanvas && (delete this._axes[k].maskCanvas, delete this._axes[k].maskCtx);
          }
        };
        t.prototype.render = function(a) {
          a && (this.options = a);
          this._initialize();
          this.setLayout();
          this.renderElements();
          this._preRenderCanvas && xa(this._preRenderCanvas);
        };
        t.prototype.attachPlotAreaEventHandlers = function() {
          this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown, mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ? "move" : "default", capture: true, bounds: this.plotArea });
        };
        t.prototype.categoriseDataSeries = function() {
          for (var a = "", e = 0; e < this.data.length; e++) if (a = this.data[e], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= t._supportedChartTypes.indexOf(a.type)) {
            for (var c = null, b = false, d = null, f = false, q = 0; q < this.plotInfo.plotTypes.length; q++) if (this.plotInfo.plotTypes[q].type === a.type) {
              b = true;
              c = this.plotInfo.plotTypes[q];
              break;
            }
            b || (c = { type: a.type, totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(c));
            for (q = 0; q < c.plotUnits.length; q++) if (c.plotUnits[q].axisYType === a.axisYType && c.plotUnits[q].axisXType === a.axisXType && c.plotUnits[q].axisYIndex === a.axisYIndex && c.plotUnits[q].axisXIndex === a.axisXIndex) {
              f = true;
              d = c.plotUnits[q];
              break;
            }
            f || (d = {
              type: a.type,
              previousDataSeriesCount: 0,
              index: c.plotUnits.length,
              plotType: c,
              axisXType: a.axisXType,
              axisYType: a.axisYType,
              axisYIndex: a.axisYIndex,
              axisXIndex: a.axisXIndex,
              axisY: "primary" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0],
              axisX: "primary" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0],
              dataSeriesIndexes: [],
              yTotals: [],
              yAbsTotals: []
            }, c.plotUnits.push(d));
            c.totalDataSeries++;
            d.dataSeriesIndexes.push(e);
            a.plotUnit = d;
          }
          for (e = 0; e < this.plotInfo.plotTypes.length; e++) for (c = this.plotInfo.plotTypes[e], q = a = 0; q < c.plotUnits.length; q++) c.plotUnits[q].previousDataSeriesCount = a, a += c.plotUnits[q].dataSeriesIndexes.length;
        };
        t.prototype.assignIdToDataPoints = function() {
          for (var a = 0; a < this.data.length; a++) {
            var e = this.data[a];
            if (e.dataPoints) for (var c = e.dataPoints.length, b = 0; b < c; b++) e.dataPointIds[b] = ++this._eventManager.lastObjectId;
          }
        };
        t.prototype._processData = function() {
          this.assignIdToDataPoints();
          this.categoriseDataSeries();
          for (var a = 0; a < this.plotInfo.plotTypes.length; a++) for (var e = this.plotInfo.plotTypes[a], c = 0; c < e.plotUnits.length; c++) {
            var b = e.plotUnits[c];
            "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type ? this._processMultiseriesPlotUnit(b) : "stackedColumn" === b.type || "stackedBar" === b.type || "stackedArea" === b.type ? this._processStackedPlotUnit(b) : "stackedColumn100" === b.type || "stackedBar100" === b.type || "stackedArea100" === b.type ? this._processStacked100PlotUnit(b) : "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? this._processMultiYPlotUnit(b) : "waterfall" === b.type && this._processSpecificPlotUnit(b);
          }
          this.calculateAutoBreaks();
        };
        t.prototype._processMultiseriesPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, d, f = false, q = 0; q < a.dataSeriesIndexes.length; q++) {
            var w = this.data[a.dataSeriesIndexes[q]], l2 = 0, k = false, m = false, n;
            if ("normal" === w.axisPlacement || "xySwapped" === w.axisPlacement) var p = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity, h = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
            if (w.dataPoints[l2].x && w.dataPoints[l2].x.getTime || "dateTime" === w.xValueType) f = true;
            for (l2 = 0; l2 < w.dataPoints.length; l2++) {
              "undefined" === typeof w.dataPoints[l2].x && (w.dataPoints[l2].x = l2 + (a.axisX.logarithmic ? 1 : 0));
              w.dataPoints[l2].x.getTime ? (f = true, b = w.dataPoints[l2].x.getTime()) : b = w.dataPoints[l2].x;
              d = w.dataPoints[l2].y;
              b < c.min && (c.min = b);
              b > c.max && (c.max = b);
              d < e.min && "number" === typeof d && (e.min = d);
              d > e.max && "number" === typeof d && (e.max = d);
              if (0 < l2) {
                if (a.axisX.logarithmic) {
                  var y = b / w.dataPoints[l2 - 1].x;
                  1 > y && (y = 1 / y);
                  c.minDiff > y && 1 !== y && (c.minDiff = y);
                } else y = b - w.dataPoints[l2 - 1].x, 0 > y && (y *= -1), c.minDiff > y && 0 !== y && (c.minDiff = y);
                null !== d && null !== w.dataPoints[l2 - 1].y && (a.axisY.logarithmic ? (y = d / w.dataPoints[l2 - 1].y, 1 > y && (y = 1 / y), e.minDiff > y && 1 !== y && (e.minDiff = y)) : (y = d - w.dataPoints[l2 - 1].y, 0 > y && (y *= -1), e.minDiff > y && 0 !== y && (e.minDiff = y)));
              }
              if (b < p && !k) null !== d && (n = b);
              else {
                if (!k && (k = true, 0 < l2)) {
                  l2 -= 2;
                  continue;
                }
                if (b > h && !m) m = true;
                else if (b > h && m) continue;
                w.dataPoints[l2].label && (a.axisX.labels[b] = w.dataPoints[l2].label);
                b < c.viewPortMin && (c.viewPortMin = b);
                b > c.viewPortMax && (c.viewPortMax = b);
                null === d ? c.viewPortMin === b && n < b && (c.viewPortMin = n) : (d < e.viewPortMin && "number" === typeof d && (e.viewPortMin = d), d > e.viewPortMax && "number" === typeof d && (e.viewPortMax = d));
              }
            }
            w.axisX.valueType = w.xValueType = f ? "dateTime" : "number";
          }
        };
        t.prototype._processStackedPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, d, f = false, q = [], w = [], J = Infinity, k = -Infinity, m = {}, n = 0; n < a.dataSeriesIndexes.length; n++) {
              var p = this.data[a.dataSeriesIndexes[n]], h = 0, y = false, g2 = false, r2;
              if ("normal" === p.axisPlacement || "xySwapped" === p.axisPlacement) var s = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -Infinity, x = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
              if (p.dataPoints[h].x && p.dataPoints[h].x.getTime || "dateTime" === p.xValueType) f = true;
              for (h = 0; h < p.dataPoints.length; h++) {
                "undefined" === typeof p.dataPoints[h].x && (p.dataPoints[h].x = h + (a.axisX.logarithmic ? 1 : 0));
                p.dataPoints[h].x.getTime ? (f = true, b = p.dataPoints[h].x.getTime()) : b = p.dataPoints[h].x;
                d = l(p.dataPoints[h].y) ? 0 : p.dataPoints[h].y;
                b < c.min && (c.min = b);
                b > c.max && (c.max = b);
                if (0 < h) {
                  if (a.axisX.logarithmic) {
                    var v = b / p.dataPoints[h - 1].x;
                    1 > v && (v = 1 / v);
                    c.minDiff > v && 1 !== v && (c.minDiff = v);
                  } else v = b - p.dataPoints[h - 1].x, 0 > v && (v *= -1), c.minDiff > v && 0 !== v && (c.minDiff = v);
                  null !== d && null !== p.dataPoints[h - 1].y && (a.axisY.logarithmic ? 0 < d && (v = d / p.dataPoints[h - 1].y, 1 > v && (v = 1 / v), e.minDiff > v && 1 !== v && (e.minDiff = v)) : (v = d - p.dataPoints[h - 1].y, 0 > v && (v *= -1), e.minDiff > v && 0 !== v && (e.minDiff = v)));
                }
                if (b < s && !y) null !== p.dataPoints[h].y && (r2 = b);
                else {
                  if (!y && (y = true, 0 < h)) {
                    h -= 2;
                    continue;
                  }
                  if (b > x && !g2) g2 = true;
                  else if (b > x && g2) continue;
                  p.dataPoints[h].label && (a.axisX.labels[b] = p.dataPoints[h].label);
                  b < c.viewPortMin && (c.viewPortMin = b);
                  b > c.viewPortMax && (c.viewPortMax = b);
                  null === p.dataPoints[h].y ? c.viewPortMin === b && r2 < b && (c.viewPortMin = r2) : (m[b] = (m[b] || 0) + p.dataPoints[h].y, p.dataPointEOs[h].cumulativeY = m[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + d, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(d), 0 <= d ? q[b] ? q[b] += d : (q[b] = d, J = Math.min(d, J)) : w[b] ? w[b] += d : (w[b] = d, k = Math.max(d, k)));
                }
              }
              a.axisY.scaleBreaks && (a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (e.dataPointYPositiveSums ? (e.dataPointYPositiveSums.push.apply(e.dataPointYPositiveSums, q), e.dataPointYNegativeSums.push.apply(e.dataPointYPositiveSums, w)) : (e.dataPointYPositiveSums = q, e.dataPointYNegativeSums = w));
              p.axisX.valueType = p.xValueType = f ? "dateTime" : "number";
            }
            for (h in q) q.hasOwnProperty(h) && !isNaN(h) && (a = q[h], a < e.min && (e.min = Math.min(a, J)), a > e.max && (e.max = a), h < c.viewPortMin || h > c.viewPortMax || (a < e.viewPortMin && (e.viewPortMin = Math.min(a, J)), a > e.viewPortMax && (e.viewPortMax = a)));
            for (h in w) w.hasOwnProperty(h) && !isNaN(h) && (a = w[h], a < e.min && (e.min = a), a > e.max && (e.max = Math.max(a, k)), h < c.viewPortMin || h > c.viewPortMax || (a < e.viewPortMin && (e.viewPortMin = a), a > e.viewPortMax && (e.viewPortMax = Math.max(a, k))));
          }
        };
        t.prototype._processStacked100PlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, d, f = false, q = false, w = false, J = {}, k = [], m = 0; m < a.dataSeriesIndexes.length; m++) {
              var n = this.data[a.dataSeriesIndexes[m]], p = 0, h = false, y = false, g2;
              if ("normal" === n.axisPlacement || "xySwapped" === n.axisPlacement) var r2 = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -Infinity, s = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
              if (n.dataPoints[p].x && n.dataPoints[p].x.getTime || "dateTime" === n.xValueType) f = true;
              for (p = 0; p < n.dataPoints.length; p++) {
                "undefined" === typeof n.dataPoints[p].x && (n.dataPoints[p].x = p + (a.axisX.logarithmic ? 1 : 0));
                n.dataPoints[p].x.getTime ? (f = true, b = n.dataPoints[p].x.getTime()) : b = n.dataPoints[p].x;
                d = l(n.dataPoints[p].y) ? null : n.dataPoints[p].y;
                b < c.min && (c.min = b);
                b > c.max && (c.max = b);
                if (0 < p) {
                  if (a.axisX.logarithmic) {
                    var x = b / n.dataPoints[p - 1].x;
                    1 > x && (x = 1 / x);
                    c.minDiff > x && 1 !== x && (c.minDiff = x);
                  } else x = b - n.dataPoints[p - 1].x, 0 > x && (x *= -1), c.minDiff > x && 0 !== x && (c.minDiff = x);
                  l(d) || null === n.dataPoints[p - 1].y || (a.axisY.logarithmic ? 0 < d && (x = d / n.dataPoints[p - 1].y, 1 > x && (x = 1 / x), e.minDiff > x && 1 !== x && (e.minDiff = x)) : (x = d - n.dataPoints[p - 1].y, 0 > x && (x *= -1), e.minDiff > x && 0 !== x && (e.minDiff = x)));
                }
                if (b < r2 && !h) null !== d && (g2 = b);
                else {
                  if (!h && (h = true, 0 < p)) {
                    p -= 2;
                    continue;
                  }
                  if (b > s && !y) y = true;
                  else if (b > s && y) continue;
                  n.dataPoints[p].label && (a.axisX.labels[b] = n.dataPoints[p].label);
                  b < c.viewPortMin && (c.viewPortMin = b);
                  b > c.viewPortMax && (c.viewPortMax = b);
                  null === d ? c.viewPortMin === b && g2 < b && (c.viewPortMin = g2) : (J[b] = (J[b] || 0) + n.dataPoints[p].y, n.dataPointEOs[p].cumulativeY = J[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + d, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(d), 0 <= d ? q = true : 0 > d && (w = true), k[b] = k[b] ? k[b] + Math.abs(d) : Math.abs(d));
                }
              }
              n.axisX.valueType = n.xValueType = f ? "dateTime" : "number";
            }
            a.axisY.logarithmic ? (e.max = l(e.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(e.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), e.min = l(e.viewPortMin) ? 1 : Math.min(e.viewPortMin, 1)) : q && !w ? (e.max = l(e.viewPortMax) ? 99 : Math.max(e.viewPortMax, 99), e.min = l(e.viewPortMin) ? 1 : Math.min(e.viewPortMin, 1)) : q && w ? (e.max = l(e.viewPortMax) ? 99 : Math.max(e.viewPortMax, 99), e.min = l(e.viewPortMin) ? -99 : Math.min(e.viewPortMin, -99)) : !q && w && (e.max = l(e.viewPortMax) ? -1 : Math.max(
              e.viewPortMax,
              -1
            ), e.min = l(e.viewPortMin) ? -99 : Math.min(e.viewPortMin, -99));
            e.viewPortMin = e.min;
            e.viewPortMax = e.max;
            a.dataPointYSums = k;
          }
        };
        t.prototype._processMultiYPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, d, f, q, w = false, l2 = 0; l2 < a.dataSeriesIndexes.length; l2++) {
            var k = this.data[a.dataSeriesIndexes[l2]], m = 0, n = false, p = false, h, y, g2;
            if ("normal" === k.axisPlacement || "xySwapped" === k.axisPlacement) var r2 = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity, s = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
            if (k.dataPoints[m].x && k.dataPoints[m].x.getTime || "dateTime" === k.xValueType) w = true;
            for (m = 0; m < k.dataPoints.length; m++) {
              "undefined" === typeof k.dataPoints[m].x && (k.dataPoints[m].x = m + (a.axisX.logarithmic ? 1 : 0));
              k.dataPoints[m].x.getTime ? (w = true, b = k.dataPoints[m].x.getTime()) : b = k.dataPoints[m].x;
              if ((d = k.dataPoints[m].y) && d.length) {
                f = Math.min.apply(null, d);
                q = Math.max.apply(null, d);
                y = true;
                for (var x = 0; x < d.length; x++) null === d.k && (y = false);
                y && (n || (g2 = h), h = b);
              }
              b < c.min && (c.min = b);
              b > c.max && (c.max = b);
              f < e.min && (e.min = f);
              q > e.max && (e.max = q);
              0 < m && (a.axisX.logarithmic ? (y = b / k.dataPoints[m - 1].x, 1 > y && (y = 1 / y), c.minDiff > y && 1 !== y && (c.minDiff = y)) : (y = b - k.dataPoints[m - 1].x, 0 > y && (y *= -1), c.minDiff > y && 0 !== y && (c.minDiff = y)), d && (null !== d[0] && k.dataPoints[m - 1].y && null !== k.dataPoints[m - 1].y[0]) && (a.axisY.logarithmic ? (y = d[0] / k.dataPoints[m - 1].y[0], 1 > y && (y = 1 / y), e.minDiff > y && 1 !== y && (e.minDiff = y)) : (y = d[0] - k.dataPoints[m - 1].y[0], 0 > y && (y *= -1), e.minDiff > y && 0 !== y && (e.minDiff = y))));
              if (!(b < r2) || n) {
                if (!n && (n = true, 0 < m)) {
                  m -= 2;
                  h = g2;
                  continue;
                }
                if (b > s && !p) p = true;
                else if (b > s && p) continue;
                k.dataPoints[m].label && (a.axisX.labels[b] = k.dataPoints[m].label);
                b < c.viewPortMin && (c.viewPortMin = b);
                b > c.viewPortMax && (c.viewPortMax = b);
                if (c.viewPortMin === b && d) {
                  for (x = 0; x < d.length; x++) if (null === d[x] && h < b) {
                    c.viewPortMin = h;
                    break;
                  }
                }
                null === d ? c.viewPortMin === b && h < b && (c.viewPortMin = h) : (f < e.viewPortMin && (e.viewPortMin = f), q > e.viewPortMax && (e.viewPortMax = q));
              }
            }
            k.axisX.valueType = k.xValueType = w ? "dateTime" : "number";
          }
        };
        t.prototype._processSpecificPlotUnit = function(a) {
          if ("waterfall" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, d, f = false, q = 0; q < a.dataSeriesIndexes.length; q++) {
            var w = this.data[a.dataSeriesIndexes[q]], l2 = 0, k = false, m = false, n = b = 0;
            if ("normal" === w.axisPlacement || "xySwapped" === w.axisPlacement) var p = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity, h = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
            if (w.dataPoints[l2].x && w.dataPoints[l2].x.getTime || "dateTime" === w.xValueType) f = true;
            for (l2 = 0; l2 < w.dataPoints.length; l2++) "undefined" !== typeof w.dataPoints[l2].isCumulativeSum && true === w.dataPoints[l2].isCumulativeSum ? (w.dataPointEOs[l2].cumulativeSumYStartValue = 0, w.dataPointEOs[l2].cumulativeSum = 0 === l2 ? 0 : w.dataPointEOs[l2 - 1].cumulativeSum, w.dataPoints[l2].y = 0 === l2 ? 0 : w.dataPointEOs[l2 - 1].cumulativeSum) : "undefined" !== typeof w.dataPoints[l2].isIntermediateSum && true === w.dataPoints[l2].isIntermediateSum ? (w.dataPointEOs[l2].cumulativeSumYStartValue = n, w.dataPointEOs[l2].cumulativeSum = 0 === l2 ? 0 : w.dataPointEOs[l2 - 1].cumulativeSum, w.dataPoints[l2].y = 0 === l2 ? 0 : b, n = 0 === l2 ? 0 : w.dataPointEOs[l2 - 1].cumulativeSum, b = 0) : (d = "number" !== typeof w.dataPoints[l2].y ? 0 : w.dataPoints[l2].y, w.dataPointEOs[l2].cumulativeSumYStartValue = 0 === l2 ? 0 : w.dataPointEOs[l2 - 1].cumulativeSum, w.dataPointEOs[l2].cumulativeSum = 0 === l2 ? d : w.dataPointEOs[l2 - 1].cumulativeSum + d, b += d);
            for (l2 = 0; l2 < w.dataPoints.length; l2++) if ("undefined" === typeof w.dataPoints[l2].x && (w.dataPoints[l2].x = l2 + (a.axisX.logarithmic ? 1 : 0)), w.dataPoints[l2].x.getTime ? (f = true, b = w.dataPoints[l2].x.getTime()) : b = w.dataPoints[l2].x, d = w.dataPoints[l2].y, b < c.min && (c.min = b), b > c.max && (c.max = b), w.dataPointEOs[l2].cumulativeSum < e.min && (e.min = w.dataPointEOs[l2].cumulativeSum), w.dataPointEOs[l2].cumulativeSum > e.max && (e.max = w.dataPointEOs[l2].cumulativeSum), 0 < l2 && (a.axisX.logarithmic ? (n = b / w.dataPoints[l2 - 1].x, 1 > n && (n = 1 / n), c.minDiff > n && 1 !== n && (c.minDiff = n)) : (n = b - w.dataPoints[l2 - 1].x, 0 > n && (n *= -1), c.minDiff > n && 0 !== n && (c.minDiff = n)), null !== d && null !== w.dataPoints[l2 - 1].y && (a.axisY.logarithmic ? (d = w.dataPointEOs[l2].cumulativeSum / w.dataPointEOs[l2 - 1].cumulativeSum, 1 > d && (d = 1 / d), e.minDiff > d && 1 !== d && (e.minDiff = d)) : (d = w.dataPointEOs[l2].cumulativeSum - w.dataPointEOs[l2 - 1].cumulativeSum, 0 > d && (d *= -1), e.minDiff > d && 0 !== d && (e.minDiff = d)))), !(b < p) || k) {
              if (!k && (k = true, 0 < l2)) {
                l2 -= 2;
                continue;
              }
              if (b > h && !m) m = true;
              else if (b > h && m) continue;
              w.dataPoints[l2].label && (a.axisX.labels[b] = w.dataPoints[l2].label);
              b < c.viewPortMin && (c.viewPortMin = b);
              b > c.viewPortMax && (c.viewPortMax = b);
              0 < l2 && (w.dataPointEOs[l2 - 1].cumulativeSum < e.viewPortMin && (e.viewPortMin = w.dataPointEOs[l2 - 1].cumulativeSum), w.dataPointEOs[l2 - 1].cumulativeSum > e.viewPortMax && (e.viewPortMax = w.dataPointEOs[l2 - 1].cumulativeSum));
              w.dataPointEOs[l2].cumulativeSum < e.viewPortMin && (e.viewPortMin = w.dataPointEOs[l2].cumulativeSum);
              w.dataPointEOs[l2].cumulativeSum > e.viewPortMax && (e.viewPortMax = w.dataPointEOs[l2].cumulativeSum);
            }
            w.axisX.valueType = w.xValueType = f ? "dateTime" : "number";
          }
        };
        t.prototype.calculateAutoBreaks = function() {
          function a(a2, b2, c2, d2) {
            if (d2) return c2 = Math.pow(Math.min(c2 * a2 / b2, b2 / a2), 0.2), 1 >= c2 && (c2 = Math.pow(1 > a2 ? 1 / a2 : Math.min(b2 / a2, a2), 0.25)), { startValue: a2 * c2, endValue: b2 / c2 };
            c2 = 0.2 * Math.min(c2 - b2 + a2, b2 - a2);
            0 >= c2 && (c2 = 0.25 * (0 < a2 ? Math.min(b2 - a2, Math.abs(a2)) : b2 - a2));
            return { startValue: a2 + c2, endValue: b2 - c2 };
          }
          function e(a2) {
            if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length)) {
              var b2 = a2.axisX.scaleBreaks && a2.axisX.scaleBreaks.autoCalculate && 1 <= a2.axisX.scaleBreaks.maxNumberOfAutoBreaks, c2 = a2.axisY.scaleBreaks && a2.axisY.scaleBreaks.autoCalculate && 1 <= a2.axisY.scaleBreaks.maxNumberOfAutoBreaks;
              if (b2 || c2) for (var e2 = a2.axisY.dataInfo, h2 = a2.axisX.dataInfo, f2, q2 = h2.min, k2 = h2.max, m2 = e2.min, n2 = e2.max, h2 = h2._dataRanges, e2 = e2._dataRanges, p2, w2 = 0, g3 = 0; g3 < a2.dataSeriesIndexes.length; g3++) {
                var J = d.data[a2.dataSeriesIndexes[g3]];
                if (!(4 > J.dataPoints.length)) {
                  for (w2 = 0; w2 < J.dataPoints.length; w2++) if (b2 && (p2 = (k2 + 1 - q2) * Math.max(parseFloat(a2.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, f2 = J.dataPoints[w2].x.getTime ? J.dataPoints[w2].x.getTime() : J.dataPoints[w2].x, p2 = Math.floor((f2 - q2) / p2), f2 < h2[p2].min && (h2[p2].min = f2), f2 > h2[p2].max && (h2[p2].max = f2)), c2) {
                    var r2 = (n2 + 1 - m2) * Math.max(parseFloat(a2.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                    if ((f2 = "waterfall" === a2.type ? J.dataPointEOs[w2].cumulativeSum : J.dataPoints[w2].y) && f2.length) for (var ca = 0; ca < f2.length; ca++) p2 = Math.floor((f2[ca] - m2) / r2), f2[ca] < e2[p2].min && (e2[p2].min = f2[ca]), f2[ca] > e2[p2].max && (e2[p2].max = f2[ca]);
                    else l(f2) || (p2 = Math.floor((f2 - m2) / r2), f2 < e2[p2].min && (e2[p2].min = f2), f2 > e2[p2].max && (e2[p2].max = f2));
                  }
                }
              }
            }
          }
          function c(a2) {
            if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length) && a2.axisX.scaleBreaks && a2.axisX.scaleBreaks.autoCalculate && 1 <= a2.axisX.scaleBreaks.maxNumberOfAutoBreaks) for (var b2 = a2.axisX.dataInfo, c2 = b2.min, e2 = b2.max, h2 = b2._dataRanges, f2, q2 = 0, k2 = 0; k2 < a2.dataSeriesIndexes.length; k2++) {
              var m2 = d.data[a2.dataSeriesIndexes[k2]];
              if (!(4 > m2.dataPoints.length)) for (q2 = 0; q2 < m2.dataPoints.length; q2++) f2 = (e2 + 1 - c2) * Math.max(parseFloat(a2.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, b2 = m2.dataPoints[q2].x.getTime ? m2.dataPoints[q2].x.getTime() : m2.dataPoints[q2].x, f2 = Math.floor((b2 - c2) / f2), b2 < h2[f2].min && (h2[f2].min = b2), b2 > h2[f2].max && (h2[f2].max = b2);
            }
          }
          for (var b, d = this, f = false, q = 0; q < this._axes.length; q++) if (this._axes[q].scaleBreaks && this._axes[q].scaleBreaks.autoCalculate && 1 <= this._axes[q].scaleBreaks.maxNumberOfAutoBreaks) {
            f = true;
            this._axes[q].dataInfo._dataRanges = [];
            for (var w = 0; w < 100 / Math.max(parseFloat(this._axes[q].scaleBreaks.collapsibleThreshold) || 10, 10); w++) this._axes[q].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity });
          }
          if (f) {
            for (q = 0; q < this.plotInfo.plotTypes.length; q++) for (f = this.plotInfo.plotTypes[q], w = 0; w < f.plotUnits.length; w++) b = f.plotUnits[w], "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type || "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "waterfall" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? e(b) : 0 <= b.type.indexOf("stacked") && c(b);
            for (q = 0; q < this._axes.length; q++) if (this._axes[q].dataInfo._dataRanges) {
              var g2 = this._axes[q].dataInfo.min;
              b = (this._axes[q].dataInfo.max + 1 - g2) * Math.max(parseFloat(this._axes[q].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
              var k = this._axes[q].dataInfo._dataRanges, m, n, f = [];
              if (this._axes[q].dataInfo.dataPointYPositiveSums) {
                var p = this._axes[q].dataInfo.dataPointYPositiveSums;
                m = k;
                for (w in p) if (p.hasOwnProperty(w) && !isNaN(w) && (n = p[w], !l(n))) {
                  var h = Math.floor((n - g2) / b);
                  n < m[h].min && (m[h].min = n);
                  n > m[h].max && (m[h].max = n);
                }
                delete this._axes[q].dataInfo.dataPointYPositiveSums;
              }
              if (this._axes[q].dataInfo.dataPointYNegativeSums) {
                p = this._axes[q].dataInfo.dataPointYNegativeSums;
                m = k;
                for (w in p) p.hasOwnProperty(w) && !isNaN(w) && (n = -1 * p[w], l(n) || (h = Math.floor((n - g2) / b), n < m[h].min && (m[h].min = n), n > m[h].max && (m[h].max = n)));
                delete this._axes[q].dataInfo.dataPointYNegativeSums;
              }
              for (w = 0; w < k.length - 1; w++) if (m = k[w].max, isFinite(m)) for (; w < k.length - 1; ) if (g2 = k[w + 1].min, isFinite(g2)) {
                n = g2 - m;
                n > b && f.push({ diff: n, start: m, end: g2 });
                break;
              } else w++;
              if (this._axes[q].scaleBreaks.customBreaks) {
                for (w = 0; w < this._axes[q].scaleBreaks.customBreaks.length; w++) for (b = 0; b < f.length; b++) if (this._axes[q].scaleBreaks.customBreaks[w].startValue <= f[b].start && f[b].start <= this._axes[q].scaleBreaks.customBreaks[w].endValue || this._axes[q].scaleBreaks.customBreaks[w].startValue <= f[b].start && f[b].start <= this._axes[q].scaleBreaks.customBreaks[w].endValue || f[b].start <= this._axes[q].scaleBreaks.customBreaks[w].startValue && this._axes[q].scaleBreaks.customBreaks[w].startValue <= f[b].end || f[b].start <= this._axes[q].scaleBreaks.customBreaks[w].endValue && this._axes[q].scaleBreaks.customBreaks[w].endValue <= f[b].end) f.splice(b, 1), b--;
              }
              f.sort(function(a2, b2) {
                return b2.diff - a2.diff;
              });
              for (w = 0; w < Math.min(f.length, this._axes[q].scaleBreaks.maxNumberOfAutoBreaks); w++) b = a(f[w].start, f[w].end, this._axes[q].logarithmic ? this._axes[q].dataInfo.max / this._axes[q].dataInfo.min : this._axes[q].dataInfo.max - this._axes[q].dataInfo.min, this._axes[q].logarithmic), this._axes[q].scaleBreaks.autoBreaks.push(new ba2(this, "autoBreaks", b, w, ++this._eventManager.lastObjectId, this._axes[q].scaleBreaks)), this._axes[q].scaleBreaks._appliedBreaks.push(this._axes[q].scaleBreaks.autoBreaks[this._axes[q].scaleBreaks.autoBreaks.length - 1]);
              this._axes[q].scaleBreaks._appliedBreaks.sort(function(a2, b2) {
                return a2.startValue - b2.startValue;
              });
            }
          }
        };
        t.prototype.renderCrosshairs = function(a, e) {
          for (var c = 0; c < this.axisX.length; c++) if (this.axisX[c] != a && this.axisX[c].crosshair && this.axisX[c].crosshair.enabled && !this.axisX[c].crosshair._hidden) if (e && this.sessionVariables.mouseX > this.plotArea.x1 && this.sessionVariables.mouseX < this.plotArea.x2 && this.sessionVariables.mouseY > this.plotArea.y1 && this.sessionVariables.mouseY < this.plotArea.y2) {
            this.plotInfo && "xySwapped" === this.plotInfo.axisPlacement ? this.axisX[c].crosshair.render(null, this.sessionVariables.mouseY, this.axisX[c].convertPixelToValue(this.sessionVariables.mouseY)) : this.axisX[c].crosshair.render(this.sessionVariables.mouseX, null, this.axisX[c].convertPixelToValue(this.sessionVariables.mouseX));
            var b = { chart: this, crosshair: this.axisX[c].crosshair.options, axis: this.axisX[c], value: this.axisX[c].crosshair.value };
            this.axisX[c].crosshair.dispatchEvent("updated", b, this.axisX[c]);
          } else e || this.axisX[c].showCrosshair(this.axisX[c].crosshair._updatedValue);
          for (c = 0; c < this.axisX2.length; c++) this.axisX2[c] != a && (this.axisX2[c].crosshair && this.axisX2[c].crosshair.enabled && !this.axisX2[c].crosshair._hidden) && (e && this.sessionVariables.mouseX > this.plotArea.x1 && this.sessionVariables.mouseX < this.plotArea.x2 && this.sessionVariables.mouseY > this.plotArea.y1 && this.sessionVariables.mouseY < this.plotArea.y2 ? (this.plotInfo && "xySwapped" === this.plotInfo.axisPlacement ? this.axisX2[c].crosshair.render(null, this.sessionVariables.mouseY, this.axisX2[c].convertPixelToValue(this.sessionVariables.mouseY)) : this.axisX2[c].crosshair.render(this.sessionVariables.mouseX, null, this.axisX2[c].convertPixelToValue(this.sessionVariables.mouseX)), b = { chart: this, crosshair: this.axisX2[c].crosshair.options, axis: this.axisX2[c], value: this.axisX2[c].crosshair.value }, this.axisX2[c].crosshair.dispatchEvent("updated", b, this.axisX2[c])) : e || this.axisX2[c].showCrosshair(this.axisX2[c].crosshair._updatedValue));
          for (c = 0; c < this.axisY.length; c++) this.axisY[c] != a && (this.axisY[c].crosshair && this.axisY[c].crosshair.enabled && !this.axisY[c].crosshair._hidden) && (e && this.sessionVariables.mouseX > this.plotArea.x1 && this.sessionVariables.mouseX < this.plotArea.x2 && this.sessionVariables.mouseY > this.plotArea.y1 && this.sessionVariables.mouseY < this.plotArea.y2 ? (this.plotInfo && "xySwapped" === this.plotInfo.axisPlacement ? this.axisY[c].crosshair.render(this.sessionVariables.mouseX, null, this.axisY[c].convertPixelToValue(this.sessionVariables.mouseX)) : this.axisY[c].crosshair.render(null, this.sessionVariables.mouseY, this.axisY[c].convertPixelToValue(this.sessionVariables.mouseY)), b = { chart: this, crosshair: this.axisY[c].crosshair.options, axis: this.axisY[c], value: this.axisY[c].crosshair.value }, this.axisY[c].crosshair.dispatchEvent("updated", b, this.axisY[c])) : e || this.axisY[c].showCrosshair(this.axisY[c].crosshair._updatedValue));
          for (c = 0; c < this.axisY2.length; c++) this.axisY2[c] != a && (this.axisY2[c].crosshair && this.axisY2[c].crosshair.enabled && !this.axisY2[c].crosshair._hidden) && (e && this.sessionVariables.mouseX > this.plotArea.x1 && this.sessionVariables.mouseX < this.plotArea.x2 && this.sessionVariables.mouseY > this.plotArea.y1 && this.sessionVariables.mouseY < this.plotArea.y2 ? (this.plotInfo && "xySwapped" === this.plotInfo.axisPlacement ? this.axisY2[c].crosshair.render(this.sessionVariables.mouseX, null, this.axisY2[c].convertPixelToValue(this.sessionVariables.mouseX)) : this.axisY2[c].crosshair.render(null, this.sessionVariables.mouseY, this.axisY2[c].convertPixelToValue(this.sessionVariables.mouseY)), b = { chart: this, crosshair: this.axisY2[c].crosshair.options, axis: this.axisY2[c], value: this.axisY2[c].crosshair.value }, this.axisY2[c].crosshair.dispatchEvent("updated", b, this.axisY2[c])) : e || this.axisY2[c].showCrosshair(this.axisY2[c].crosshair._updatedValue));
        };
        t.prototype.getDataPointAtXY = function(a, e, c) {
          c = c || false;
          for (var b = [], d = this._dataInRenderedOrder.length - 1; 0 <= d; d--) {
            var f = null;
            (f = this._dataInRenderedOrder[d].getDataPointAtXY(a, e, c)) && b.push(f);
          }
          a = null;
          e = false;
          for (c = 0; c < b.length; c++) if ("line" === b[c].dataSeries.type || "stepLine" === b[c].dataSeries.type || "area" === b[c].dataSeries.type || "stepArea" === b[c].dataSeries.type) {
            if (d = W("markerSize", b[c].dataPoint, b[c].dataSeries) || 8, b[c].distance <= d / 2) {
              e = true;
              break;
            }
          }
          for (c = 0; c < b.length; c++) e && "line" !== b[c].dataSeries.type && "stepLine" !== b[c].dataSeries.type && "area" !== b[c].dataSeries.type && "stepArea" !== b[c].dataSeries.type || (a ? b[c].distance <= a.distance && (a = b[c]) : a = b[c]);
          return a;
        };
        t.prototype.getObjectAtXY = function(a, e, c) {
          var b = null;
          if (c = this.getDataPointAtXY(a, e, c || false)) b = c.dataSeries.dataPointIds[c.dataPointIndex];
          else if (r) b = Za(a, e, this._eventManager.ghostCtx);
          else for (c = 0; c < this.legend.items.length; c++) {
            var d = this.legend.items[c];
            a >= d.x1 && (a <= d.x2 && e >= d.y1 && e <= d.y2) && (b = d.id);
          }
          return b;
        };
        t.prototype.getAutoFontSize = lb;
        t.prototype.resetOverlayedCanvas = function() {
          this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
        };
        t.prototype.clearCanvas = kb;
        t.prototype.attachEvent = function(a) {
          this._events.push(a);
        };
        t.prototype._touchEventHandler = function(a) {
          if (a.changedTouches && this.interactivityEnabled) {
            var e = [], c = a.changedTouches, b = c ? c[0] : a, d = null;
            switch (a.type) {
              case "touchstart":
              case "MSPointerDown":
                e = ["mousemove", "mousedown"];
                this._lastTouchData = Oa(b);
                this._lastTouchData.time = /* @__PURE__ */ new Date();
                break;
              case "touchmove":
              case "MSPointerMove":
                e = ["mousemove"];
                break;
              case "touchend":
              case "MSPointerUp":
                var f = this._lastTouchData && this._lastTouchData.time ? /* @__PURE__ */ new Date() - this._lastTouchData.time : 0, e = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > f ? ["mouseup", "click"] : ["mouseup"];
                break;
              default:
                return;
            }
            if (!(c && 1 < c.length)) {
              d = Oa(b);
              d.time = /* @__PURE__ */ new Date();
              try {
                var q = d.y - this._lastTouchData.y, f = d.time - this._lastTouchData.time;
                if (1 < Math.abs(q) && this._lastTouchData.scroll || 5 < Math.abs(q) && 250 > f) this._lastTouchData.scroll = true, this.stockChart && (this.stockChart._chartScroll = true);
              } catch (w) {
              }
              this._lastTouchEventType = a.type;
              if (this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = false;
              else for (c = 0; c < e.length; c++) if (d = e[c], q = document.createEvent("MouseEvent"), q.initMouseEvent(d, true, true, window, 1, b.screenX, b.screenY, b.clientX, b.clientY, false, false, false, false, 0, null), b.target.dispatchEvent(q), !l(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < f || "click" === d) a.preventManipulation && a.preventManipulation(), a.preventDefault && a.cancelable && a.preventDefault(), this.stockChart && (this.stockChart._chartScroll = null);
            }
          }
        };
        t.prototype._dispatchRangeEvent = function(a, e) {
          var c = { chart: this };
          c.type = a;
          c.trigger = e;
          var b = [];
          this.axisX && 0 < this.axisX.length && b.push("axisX");
          this.axisX2 && 0 < this.axisX2.length && b.push("axisX2");
          this.axisY && 0 < this.axisY.length && b.push("axisY");
          this.axisY2 && 0 < this.axisY2.length && b.push("axisY2");
          for (var d = 0; d < b.length; d++) if (l(c[b[d]]) && (c[b[d]] = []), "axisY" === b[d]) for (var f = 0; f < this.axisY.length; f++) c[b[d]].push({ viewportMinimum: this[b[d]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[d]][f].sessionVariables.newViewportMaximum });
          else if ("axisY2" === b[d]) for (f = 0; f < this.axisY2.length; f++) c[b[d]].push({ viewportMinimum: this[b[d]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[d]][f].sessionVariables.newViewportMaximum });
          else if ("axisX" === b[d]) for (f = 0; f < this.axisX.length; f++) c[b[d]].push({ viewportMinimum: this[b[d]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[d]][f].sessionVariables.newViewportMaximum });
          else if ("axisX2" === b[d]) for (f = 0; f < this.axisX2.length; f++) c[b[d]].push({
            viewportMinimum: this[b[d]][f].sessionVariables.newViewportMinimum,
            viewportMaximum: this[b[d]][f].sessionVariables.newViewportMaximum
          });
          this.dispatchEvent(a, c, this);
        };
        t.prototype._mouseEventHandler = function(a) {
          function e() {
            t.capturedEventParam && (d = t.capturedEventParam, q = d.bounds, "mouseup" === b && (t.capturedEventParam = null, d.chart.overlaidCanvas.releaseCapture ? d.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", d.chart._mouseEventHandler, false)), d.hasOwnProperty(b) && ("mouseup" !== b || d.chart.overlaidCanvas.releaseCapture ? a.target !== d.chart.overlaidCanvas && r || d[b].call(d.context, c.x, c.y) : a.target !== d.chart.overlaidCanvas && (d.chart.isDrag = false)));
          }
          "undefined" === typeof a.target && a.srcElement && (a.target = a.srcElement);
          var c = Oa(a), b = a.type, d, f;
          a.which ? f = 3 == a.which : a.button && (f = 2 == a.button);
          if (this._ignoreNextEvent) e(), this._ignoreNextEvent = false;
          else if (e(), this.interactivityEnabled) {
            a.preventManipulation && a.preventManipulation();
            a.preventDefault && a.preventDefault();
            var q;
            Ga && window.console && (window.console.log(b + " --> x: " + c.x + "; y:" + c.y), f && window.console.log(a.which), "mouseup" === b && window.console.log("mouseup"));
            if (!f) {
              if (!t.capturedEventParam && this._events) {
                for (f = 0; f < this._events.length; f++) if (this._events[f].hasOwnProperty(b)) if (d = this._events[f], q = d.bounds, c.x >= q.x1 && c.x <= q.x2 && c.y >= q.y1 && c.y <= q.y2) {
                  d[b].call(d.context, c.x, c.y);
                  "mousedown" === b && true === d.capture ? (t.capturedEventParam = d, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener(
                    "mouseup",
                    this._mouseEventHandler,
                    false
                  )) : "mouseup" === b && (d.chart.overlaidCanvas.releaseCapture ? d.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, false));
                  break;
                } else d = null;
                a.target.style.cursor = d && d.cursor ? d.cursor : this._defaultCursor;
              }
              f = this.plotArea;
              if (c.x < f.x1 || c.x > f.x2 || c.y < f.y1 || c.y > f.y2) {
                this.toolTip && this.toolTip.enabled ? (this.toolTip.hide(), this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip)) : this.resetOverlayedCanvas();
                for (f = 0; f < this.axisX.length; f++) this.axisX[f].crosshair && this.axisX[f].crosshair.enabled && (this.axisX[f].crosshair.hide(), this.axisX[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX[f].options }, this.axisX[f].crosshair));
                for (f = 0; f < this.axisX2.length; f++) this.axisX2[f].crosshair && this.axisX2[f].crosshair.enabled && (this.axisX2[f].crosshair.hide(), this.axisX2[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[f].options }, this.axisX2[f].crosshair));
                for (f = 0; f < this.axisY.length; f++) this.axisY[f].crosshair && this.axisY[f].crosshair.enabled && (this.axisY[f].crosshair.hide(), this.axisY[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY[f].options }, this.axisY[f].crosshair));
                for (f = 0; f < this.axisY2.length; f++) this.axisY2[f].crosshair && this.axisY2[f].crosshair.enabled && (this.axisY2[f].crosshair.hide(), this.axisY2[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY2[f].options }, this.axisY2[f].crosshair));
              }
              this.sessionVariables.mouseX = c.x;
              this.sessionVariables.mouseY = c.y;
              this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);
            }
          }
        };
        t.prototype._plotAreaMouseDown = function(a, e) {
          this.isDrag = true;
          this.dragStartPoint = { x: a, y: e };
        };
        t.prototype._plotAreaMouseUp = function(a, e) {
          if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
            var c = e - this.dragStartPoint.y, b = a - this.dragStartPoint.x, d = 0 <= this.zoomType.indexOf("x"), f = 0 <= this.zoomType.indexOf("y"), q = false;
            this.resetOverlayedCanvas();
            if ("xySwapped" === this.plotInfo.axisPlacement) var w = f, f = d, d = w;
            if (this.panEnabled || this.zoomEnabled) {
              if (this.panEnabled) for (d = f = 0; d < this._axes.length; d++) c = this._axes[d], c.logarithmic ? c.viewportMinimum < c.minimum ? (f = c.minimum / c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum * f, c.sessionVariables.newViewportMaximum = c.viewportMaximum * f, q = true) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum / c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum / f, c.sessionVariables.newViewportMaximum = c.viewportMaximum / f, q = true) : c.viewportMinimum < c.minimum ? (f = c.minimum - c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum + f, c.sessionVariables.newViewportMaximum = c.viewportMaximum + f, q = true) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum - c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum - f, c.sessionVariables.newViewportMaximum = c.viewportMaximum - f, q = true);
              else if ((!d || 2 < Math.abs(b)) && (!f || 2 < Math.abs(c)) && this.zoomEnabled) {
                if (!this.dragStartPoint) return;
                c = d ? this.dragStartPoint.x : this.plotArea.x1;
                b = f ? this.dragStartPoint.y : this.plotArea.y1;
                d = d ? a : this.plotArea.x2;
                f = f ? e : this.plotArea.y2;
                2 < Math.abs(c - d) && 2 < Math.abs(b - f) && this._zoomPanToSelectedRegion(c, b, d, f) && (q = true);
              }
              q && (this._ignoreNextEvent = true, this._dispatchRangeEvent("rangeChanging", "zoom"), this.stockChart && (this.stockChart._rangeEventParameter || (this.stockChart._rangeEventParameter = { stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: this.stockChart.sessionVariables._axisXMin, maximum: this.stockChart.sessionVariables._axisXMax }), this.stockChart._rangeEventParameter.type = "rangeChanging", this.stockChart.dispatchEvent("rangeChanging", this.stockChart._rangeEventParameter, this.stockChart)), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), this.stockChart && (this.stockChart.rangeUpdatedBy = "chart", this.stockChart._rangeEventParameter.type = "rangeChanged", this.stockChart.dispatchEvent("rangeChanged", this.stockChart._rangeEventParameter, this.stockChart)), q && (this.zoomEnabled && "none" === this._zoomButton.style.display) && (Ka(
                this._zoomButton,
                this._resetButton
              ), ra(this, this._zoomButton, "pan"), ra(this, this._resetButton, "reset")));
            }
          }
          this.isDrag = false;
          if ("none" !== this.plotInfo.axisPlacement) {
            this.resetOverlayedCanvas();
            if (this.axisX && 0 < this.axisX.length) for (q = 0; q < this.axisX.length; q++) this.axisX[q].crosshair && this.axisX[q].crosshair.enabled && this.axisX[q].renderCrosshair(a, e);
            if (this.axisX2 && 0 < this.axisX2.length) for (q = 0; q < this.axisX2.length; q++) this.axisX2[q].crosshair && this.axisX2[q].crosshair.enabled && this.axisX2[q].renderCrosshair(a, e);
            if (this.axisY && 0 < this.axisY.length) for (q = 0; q < this.axisY.length; q++) this.axisY[q].crosshair && this.axisY[q].crosshair.enabled && this.axisY[q].renderCrosshair(a, e);
            if (this.axisY2 && 0 < this.axisY2.length) for (q = 0; q < this.axisY2.length; q++) this.axisY2[q].crosshair && this.axisY2[q].crosshair.enabled && this.axisY2[q].renderCrosshair(a, e);
            if (this.axisX && 0 < this.axisX.length) for (q = 0; q < this.axisX.length; q++) this.axisX[q].crosshair && this.axisX[q].crosshair.enabled && this.axisX[q].crosshair.renderLabel();
            if (this.axisX2 && 0 < this.axisX2.length) for (q = 0; q < this.axisX2.length; q++) this.axisX2[q].crosshair && this.axisX2[q].crosshair.enabled && this.axisX2[q].crosshair.renderLabel();
            if (this.axisY && 0 < this.axisY.length) for (q = 0; q < this.axisY.length; q++) this.axisY[q].crosshair && this.axisY[q].crosshair.enabled && this.axisY[q].crosshair.renderLabel();
            if (this.axisY2 && 0 < this.axisY2.length) for (q = 0; q < this.axisY2.length; q++) this.axisY2[q].crosshair && this.axisY2[q].crosshair.enabled && this.axisY2[q].crosshair.renderLabel();
          }
        };
        t.prototype._plotAreaMouseMove = function(a, e) {
          if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
            var c = 0, b = 0, d = c = null, d = 0 <= this.zoomType.indexOf("x"), f = 0 <= this.zoomType.indexOf("y"), q = this;
            "xySwapped" === this.plotInfo.axisPlacement && (c = f, f = d, d = c);
            c = this.dragStartPoint.x - a;
            b = this.dragStartPoint.y - e;
            if (2 < Math.abs(c) && 8 > Math.abs(c) && (this.panEnabled || this.zoomEnabled)) {
              this.toolTip.hide();
              this.toolTip && this.toolTip.enabled && this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip);
              for (var w = 0; w < this.axisX.length; w++) this.axisX[w].crosshair && this.axisX[w].crosshair.enabled && (this.axisX[w].crosshair.hide(), this.axisX[w].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX[w].options }, this.axisX[w].crosshair));
              for (w = 0; w < this.axisX2.length; w++) this.axisX2[w].crosshair && this.axisX2[w].crosshair.enabled && (this.axisX2[w].crosshair.hide(), this.axisX2[w].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[w].options }, this.axisX2[w].crosshair));
              for (w = 0; w < this.axisY.length; w++) this.axisY[w].crosshair && this.axisY[w].crosshair.enabled && (this.axisY[w].crosshair.hide(), this.axisY[w].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY[w].options }, this.axisY[w].crosshair));
              for (w = 0; w < this.axisY2.length; w++) this.axisY2[w].crosshair && this.axisY2[w].crosshair.enabled && (this.axisY2[w].crosshair.hide(), this.axisY2[w].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY2[w].options }, this.axisY2[w].crosshair));
            } else this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, e);
            if ((!d || 2 < Math.abs(c) || !f || 2 < Math.abs(b)) && (this.panEnabled || this.zoomEnabled)) {
              if (this.panEnabled) d = { x1: d ? this.plotArea.x1 + c : this.plotArea.x1, y1: f ? this.plotArea.y1 + b : this.plotArea.y1, x2: d ? this.plotArea.x2 + c : this.plotArea.x2, y2: f ? this.plotArea.y2 + b : this.plotArea.y2 }, clearTimeout(q._panTimerId), q._panTimerId = setTimeout(/* @__PURE__ */ function(b2, c2, d2, h) {
                return function() {
                  q._zoomPanToSelectedRegion(b2, c2, d2, h, true) && (q._dispatchRangeEvent("rangeChanging", "pan"), q.stockChart && (q.stockChart._rangeEventParameter.type = "rangeChanging", q.stockChart.dispatchEvent(
                    "rangeChanging",
                    q.stockChart._rangeEventParameter,
                    q.stockChart
                  )), q.render(), q._dispatchRangeEvent("rangeChanged", "pan"), q.stockChart && (q.stockChart._rangeEventParameter.type = "rangeChanged", q.stockChart.dispatchEvent("rangeChanged", q.stockChart._rangeEventParameter, q.stockChart)), q.dragStartPoint.x = a, q.dragStartPoint.y = e);
                };
              }(d.x1, d.y1, d.x2, d.y2), 0);
              else if (this.zoomEnabled) {
                this.resetOverlayedCanvas();
                c = this.overlaidCanvasCtx.globalAlpha;
                this.overlaidCanvasCtx.fillStyle = "#A89896";
                var b = d ? this.dragStartPoint.x : this.plotArea.x1, w = f ? this.dragStartPoint.y : this.plotArea.y1, l2 = d ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, k = f ? e - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
                this.validateRegion(b, w, d ? a : this.plotArea.x2 - this.plotArea.x1, f ? e : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5");
                this.overlaidCanvasCtx.globalAlpha = 0.7;
                this.overlaidCanvasCtx.fillRect(b, w, l2, k);
                this.overlaidCanvasCtx.globalAlpha = c;
              }
            }
          } else if (this.toolTip.mouseMoveHandler(
            a,
            e
          ), "none" !== this.plotInfo.axisPlacement) {
            this.sessionVariables.crosshairShownByPixel = true;
            if (this.axisX && 0 < this.axisX.length) for (d = 0; d < this.axisX.length; d++) this.axisX[d].crosshair && this.axisX[d].crosshair.enabled && this.axisX[d].renderCrosshair(a, e);
            if (this.axisX2 && 0 < this.axisX2.length) for (d = 0; d < this.axisX2.length; d++) this.axisX2[d].crosshair && this.axisX2[d].crosshair.enabled && this.axisX2[d].renderCrosshair(a, e);
            if (this.axisY && 0 < this.axisY.length) for (d = 0; d < this.axisY.length; d++) this.axisY[d].crosshair && this.axisY[d].crosshair.enabled && this.axisY[d].renderCrosshair(a, e);
            if (this.axisY2 && 0 < this.axisY2.length) for (d = 0; d < this.axisY2.length; d++) this.axisY2[d].crosshair && this.axisY2[d].crosshair.enabled && this.axisY2[d].renderCrosshair(a, e);
            if (this.axisX && 0 < this.axisX.length) for (d = 0; d < this.axisX.length; d++) this.axisX[d].crosshair && this.axisX[d].crosshair.enabled && this.axisX[d].crosshair.renderLabel();
            if (this.axisX2 && 0 < this.axisX2.length) for (d = 0; d < this.axisX2.length; d++) this.axisX2[d].crosshair && this.axisX2[d].crosshair.enabled && this.axisX2[d].crosshair.renderLabel();
            if (this.axisY && 0 < this.axisY.length) for (d = 0; d < this.axisY.length; d++) this.axisY[d].crosshair && this.axisY[d].crosshair.enabled && this.axisY[d].crosshair.renderLabel();
            if (this.axisY2 && 0 < this.axisY2.length) for (d = 0; d < this.axisY2.length; d++) this.axisY2[d].crosshair && this.axisY2[d].crosshair.enabled && this.axisY2[d].crosshair.renderLabel();
          }
        };
        t.prototype._zoomPanToSelectedRegion = function(a, e, c, b, d) {
          a = this.validateRegion(a, e, c, b, d);
          e = a.axesWithValidRange;
          c = a.axesRanges;
          if (a.isValid) for (b = 0; b < e.length; b++) {
            d = e[b];
            var f = c[b];
            d.setViewPortRange(f.val1, f.val2);
            this.syncCharts && ("axisX" === d.type && "y" != this.zoomType) && this.syncCharts(f.val1, f.val2);
            this.stockChart && (this.stockChart._rangeEventParameter = { stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: f.val1, maximum: f.val2 });
          }
          return a.isValid;
        };
        t.prototype.validateRegion = function(a, e, c, b, d) {
          d = d || false;
          for (var f = 0 <= this.zoomType.indexOf("x"), q = 0 <= this.zoomType.indexOf("y"), w = false, l2 = [], k = [], m = [], n = 0; n < this._axes.length; n++) ("axisX" === this._axes[n].type && f || "axisY" === this._axes[n].type && q) && k.push(this._axes[n]);
          for (q = 0; q < k.length; q++) {
            var n = k[q], f = false, p = n.convertPixelToValue({ x: a, y: e }), h = n.convertPixelToValue({ x: c, y: b });
            if (p > h) var g2 = h, h = p, p = g2;
            if (n.scaleBreaks) for (g2 = 0; !f && g2 < n.scaleBreaks._appliedBreaks.length; g2++) f = n.scaleBreaks._appliedBreaks[g2].startValue <= p && n.scaleBreaks._appliedBreaks[g2].endValue >= h;
            if (isFinite(n.dataInfo.minDiff)) {
              if (g2 = n.getApparentDifference(p, h, null, true), !(f || !(this.panEnabled && n.scaleBreaks && n.scaleBreaks._appliedBreaks.length) && (n.logarithmic && g2 < Math.pow(n.dataInfo.minDiff, 3) || !n.logarithmic && g2 < 3 * Math.abs(n.dataInfo.minDiff)) || p < n.minimum || h > n.maximum)) l2.push(n), m.push({ val1: p, val2: h }), w = true;
              else if (!d) {
                w = false;
                break;
              }
            }
          }
          return { isValid: w, axesWithValidRange: l2, axesRanges: m };
        };
        t.prototype.preparePlotArea = function() {
          var a = this.plotArea;
          !r && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);
          if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
            var e = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;
            if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
              var c = this.axisY[0];
              a.x1 = e.x1 < e.x2 ? e.x1 : c.lineCoordinates.x1;
              a.y1 = e.y1 < c.lineCoordinates.y1 ? e.y1 : c.lineCoordinates.y1;
              a.x2 = e.x2 > c.lineCoordinates.x2 ? e.x2 : c.lineCoordinates.x2;
              a.y2 = e.y1 > c.lineCoordinates.y2 ? e.y1 : c.lineCoordinates.y2;
              a.width = a.x2 - a.x1;
              a.height = a.y2 - a.y1;
            }
            this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (c = this.axisY2[0], a.x1 = e.x1 < e.x2 ? e.x1 : c.lineCoordinates.x1, a.y1 = e.y1 < c.lineCoordinates.y1 ? e.y1 : c.lineCoordinates.y1, a.x2 = e.x2 > c.lineCoordinates.x2 ? e.x2 : c.lineCoordinates.x2, a.y2 = e.y2 > c.lineCoordinates.y2 ? e.y2 : c.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);
          } else e = this.layoutManager.getFreeSpace(), a.x1 = e.x1, a.x2 = e.x2, a.y1 = e.y1, a.y2 = e.y2, a.width = e.width, a.height = e.height;
          r || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));
          a.layoutManager = new Da(
            a.x1,
            a.y1,
            a.x2,
            a.y2,
            2
          );
        };
        t.prototype.renderIndexLabels = function(a) {
          var e = a || this.plotArea.ctx, c = this.plotArea, b = 0, d = 0, f = 0, q = d = f = 0, w = 0, g2 = b = 0, k = 0;
          for (a = 0; a < this._indexLabels.length; a++) {
            var m = this._indexLabels[a], n = m.chartType.toLowerCase(), p, h, w = W("indexLabelFontColor", m.dataPoint, m.dataSeries), y = W("indexLabelFontSize", m.dataPoint, m.dataSeries), g2 = W("indexLabelFontFamily", m.dataPoint, m.dataSeries), k = W("indexLabelFontStyle", m.dataPoint, m.dataSeries);
            p = W("indexLabelFontWeight", m.dataPoint, m.dataSeries);
            var A = W("indexLabelBackgroundColor", m.dataPoint, m.dataSeries);
            h = W("indexLabelBorderColor", m.dataPoint, m.dataSeries);
            var f = W("indexLabelBorderThickness", m.dataPoint, m.dataSeries), d = W("indexLabelMaxWidth", m.dataPoint, m.dataSeries), q = W("indexLabelWrap", m.dataPoint, m.dataSeries), z = W("indexLabelLineDashType", m.dataPoint, m.dataSeries), s = W("indexLabelLineColor", m.dataPoint, m.dataSeries), x = l(m.dataPoint.indexLabelLineThickness) ? l(m.dataSeries.options.indexLabelLineThickness) ? 0 : m.dataSeries.options.indexLabelLineThickness : m.dataPoint.indexLabelLineThickness, b = 0 < x ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, v = W("indexLabelPadding", m.dataPoint, m.dataSeries), t2 = { percent: null, total: null }, D = null;
            if (0 <= m.dataSeries.type.indexOf("stacked") || "pie" === m.dataSeries.type || "doughnut" === m.dataSeries.type) t2 = this.getPercentAndTotal(m.dataSeries, m.dataPoint);
            if (m.dataSeries.indexLabelFormatter || m.dataPoint.indexLabelFormatter) D = {
              chart: this,
              dataSeries: m.dataSeries,
              dataPoint: m.dataPoint,
              index: m.indexKeyword,
              total: t2.total,
              percent: t2.percent
            };
            var R = m.dataPoint.indexLabelFormatter ? m.dataPoint.indexLabelFormatter(D) : m.dataPoint.indexLabel ? this.replaceKeywordsWithValue(m.dataPoint.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : m.dataSeries.indexLabelFormatter ? m.dataSeries.indexLabelFormatter(D) : m.dataSeries.indexLabel ? this.replaceKeywordsWithValue(m.dataSeries.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : null;
            if (null !== R && "" !== R) {
              var t2 = W(
                "indexLabelPlacement",
                m.dataPoint,
                m.dataSeries
              ), D = W("indexLabelOrientation", m.dataPoint, m.dataSeries), u3 = W("indexLabelTextAlign", m.dataPoint, m.dataSeries), B2 = m.direction, L = m.dataSeries.axisX, N = m.dataSeries.axisY, Z = false, A = new ja(e, { x: 0, y: 0, maxWidth: d ? d : 0.5 * this.width, maxHeight: q ? 5 * y : 1.5 * y, angle: "horizontal" === D ? 0 : -90, text: R, padding: v, backgroundColor: A, borderColor: h, borderThickness: f, textAlign: u3, fontSize: y, fontFamily: g2, fontWeight: p, fontColor: w, fontStyle: k, textBaseline: "middle" });
              A.measureText();
              m.dataSeries.indexLabelMaxWidth = A.maxWidth;
              if ("stackedarea100" === n) {
                if (m.point.x < c.x1 || m.point.x > c.x2 || m.point.y < c.y1 - 1 || m.point.y > c.y2 + 1) continue;
              } else if ("rangearea" === n || "rangesplinearea" === n) {
                if (m.dataPoint.x < L.viewportMinimum || m.dataPoint.x > L.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < N.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > N.viewportMaximum) continue;
              } else if (0 <= n.indexOf("line") || 0 <= n.indexOf("area") || 0 <= n.indexOf("bubble") || 0 <= n.indexOf("scatter")) {
                if (m.dataPoint.x < L.viewportMinimum || m.dataPoint.x > L.viewportMaximum || m.dataPoint.y < N.viewportMinimum || m.dataPoint.y > N.viewportMaximum) continue;
              } else if (0 <= n.indexOf("column")) {
                if (m.dataPoint.x < L.viewportMinimum || m.dataPoint.x > L.viewportMaximum || (0 < m.dataPoint.y.length ? Math.max.apply(null, m.dataPoint.y) : m.cumulativeY ? m.cumulativeY : m.dataPoint.y) < N.viewportMinimum || (0 < m.dataPoint.y.length ? Math.min.apply(null, m.dataPoint.y) : m.cumulativeY ? m.cumulativeY : m.dataPoint.y) > N.viewportMaximum) continue;
              } else if ("waterfall" === n || "error" === n && !m.axisSwapped) {
                if (m.dataPoint.x < L.viewportMinimum || m.dataPoint.x > L.viewportMaximum || m.bounds.y1 > c.y2 || m.bounds.y2 < c.y1) continue;
              } else if (0 <= n.indexOf("bar") || "error" === n) {
                if (m.dataPoint.x < L.viewportMinimum || m.dataPoint.x > L.viewportMaximum || m.bounds.x1 > c.x2 || m.bounds.x2 < c.x1) continue;
              } else if ("candlestick" === n || "ohlc" === n) {
                if (m.dataPoint.x < L.viewportMinimum || m.dataPoint.x > L.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < N.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > N.viewportMaximum) continue;
              } else if (m.dataPoint.x < L.viewportMinimum || m.dataPoint.x > L.viewportMaximum) continue;
              q = w = 2;
              "horizontal" === D ? (g2 = A.width, k = A.height) : (k = A.width, g2 = A.height);
              if ("normal" === this.plotInfo.axisPlacement) {
                if (0 <= n.indexOf("line") || 0 <= n.indexOf("area")) t2 = "auto", w = 4;
                else if (0 <= n.indexOf("stacked")) "auto" === t2 && (t2 = "inside");
                else if ("bubble" === n || "scatter" === n) t2 = "inside";
                p = m.point.x - g2 / 2 + ("horizontal" === D ? 0 : A._lineHeight / 2);
                if ("inside" !== t2) d = c.y1, f = c.y2, 0 < B2 ? (h = m.point.y + A._lineHeight / 2 - k - w - b, h < d && (h = "auto" === t2 ? Math.max(m.point.y, d) + A._lineHeight / 2 + w + b : d + A._lineHeight / 2 + w + b, Z = h + ("horizontal" === D ? k - A._lineHeight / 2 : 0) > m.point.y, !Z || (0 <= n.indexOf("line") || 0 <= n.indexOf("area")) || (h -= b))) : (h = m.point.y + A._lineHeight / 2 + w + b, h > f - k + A._lineHeight / 2 - w && (h = "auto" === t2 ? Math.min(m.point.y, f) + A._lineHeight / 2 - k - w - b : f + A._lineHeight / 2 - k - w - b, Z = h - ("horizontal" === D ? A._lineHeight / 2 : k) < m.point.y, !Z || (0 <= n.indexOf("line") || 0 <= n.indexOf("area")) || (h += b)));
                else {
                  Math.max(m.bounds.y1, c.y1);
                  f = Math.min(m.bounds.y2, c.y2) - k + A._lineHeight / 2;
                  b = 0 <= n.indexOf("range") || "error" === n ? 0 < B2 ? Math.max(
                    m.bounds.y1,
                    c.y1
                  ) + A._lineHeight / 2 + w : Math.min(m.bounds.y2, c.y2) + A._lineHeight / 2 - k - w : (Math.max(m.bounds.y1, c.y1) + Math.min(m.bounds.y2, c.y2)) / 2 - k / 2 + A._lineHeight / 2;
                  if (0 < B2) {
                    if (h = b, "bubble" === n || "scatter" === n) h = m.point.y - k / 2 + A._lineHeight / 2, k > m.bounds.y2 - m.bounds.y1 && (h -= k / 2 + w), 0 > h - A._lineHeight / 2 && (h += Math.abs(h - A._lineHeight / 2) <= (m.bounds.y2 - m.bounds.y1) / 2 + w ? Math.abs(h - A._lineHeight / 2) : (m.bounds.y2 - m.bounds.y1) / 2 + w);
                  } else h = Math.min(m.point.y, b), h > f - k - w && ("bubble" === n || "scatter" === n) && (h = Math.min(m.point.y + w, c.y2 - k - w));
                  h = Math.min(h, f);
                }
              } else 0 <= n.indexOf("line") || 0 <= n.indexOf("area") || 0 <= n.indexOf("scatter") ? (t2 = "auto", q = 4) : 0 <= n.indexOf("stacked") ? "auto" === t2 && (t2 = "inside") : "bubble" === n && (t2 = "inside"), h = m.point.y + A._lineHeight / 2 - k / 2, "inside" !== t2 ? (f = c.x1, d = c.x2, 0 > B2 ? (p = m.point.x - g2 + ("horizontal" === D ? 0 : A._lineHeight / 2) - q - b, ("horizontal" === D ? p : p - A._lineHeight / 2) < f && (p = "auto" === t2 ? Math.max(m.point.x, f) + ("horizontal" === D ? 0 : A._lineHeight / 2) + w + b : f + ("horizontal" === D ? 0 : A._lineHeight / 2) + q, (Z = p + g2 - ("horizontal" === D ? 0 : A._lineHeight / 2) > m.point.x) && (p -= b))) : (p = m.point.x + ("horizontal" === D ? 0 : A._lineHeight / 2) + q + b, ("horizontal" === D ? p : p - A._lineHeight / 2) > d - g2 - q - b && (p = "auto" === t2 ? Math.min(m.point.x, d) - ("horizontal" === D ? g2 : g2 - A._lineHeight / 2) - q - b : d - g2 - q + ("horizontal" === D ? 0 : A._lineHeight / 2), (Z = p - ("horizontal" === D ? 0 : A._lineHeight / 2) < m.point.x) && (p += b)))) : (f = Math.max(m.bounds.x1, c.x1), Math.min(m.bounds.x2, c.x2), b = 0 <= n.indexOf("range") || "error" === n ? 0 > B2 ? Math.max(m.bounds.x1, c.x1) : Math.min(m.bounds.x2, c.x2) - g2 - q + ("horizontal" === D ? 0 : A._lineHeight / 2) : (Math.max(m.bounds.x1, c.x1) + Math.min(m.bounds.x2, c.x2)) / 2 - g2 / 2 + ("horizontal" === D ? 0 : A._lineHeight / 2), p = 0 > B2 ? b : Math.min(m.point.x, b), p = Math.max(p, f + ("horizontal" === D ? 0 : A._lineHeight / 2 + w)));
              "vertical" === D && (h += k - A._lineHeight / 2, 0 <= "ohlc candlestick boxandwhisker column rangecolumn stackedcolumn stackedcolumn100 error".split(" ").indexOf(n) && (Z = 0 < B2 ? h + ("horizontal" === D ? k - A._lineHeight / 2 : 0) > m.point.y : h - ("horizontal" === D ? A._lineHeight / 2 : k) < m.point.y), "bubble" === n || "scatter" === n) && (p += A._lineHeight / 2 - y / 2);
              A.x = p;
              A.y = h;
              A.render(true);
              x && ("inside" !== t2 && (0 > n.indexOf("bar") && ("error" !== n || !m.axisSwapped) && m.point.x > c.x1 && m.point.x < c.x2 || !Z) && (-1 === "ohlc candlestick boxandwhisker column rangecolumn stackedcolumn stackedcolumn100 error".split(" ").indexOf(n) && ("error" !== n || m.axisSwapped) && m.point.y > c.y1 && m.point.y < c.y2 || !Z)) && (e.lineWidth = x, e.strokeStyle = s ? s : "gray", e.setLineDash && e.setLineDash(K(z, x)), e.beginPath(), e.moveTo(m.point.x, m.point.y), 0 <= n.indexOf("bar") || "error" === n && m.axisSwapped ? e.lineTo(p + (0 < m.direction ? 0 : g2) + ("vertical" === D ? -A._lineHeight / 2 : 0), h + ("vertical" === D ? -k / 2 : k / 2 - A._lineHeight / 2)) : 0 <= n.indexOf("column") || "error" === n && !m.axisSwapped ? e.lineTo(p + g2 / 2 - ("horizontal" === D ? 0 : A._lineHeight / 2), h + ("vertical" === D ? h - k < m.point.y ? 0 : -k : (h - A._lineHeight / 2 < m.point.y ? k : 0) - A._lineHeight / 2)) : 0 <= n.indexOf("waterfall") ? e.lineTo(p + g2 / 2 - ("horizontal" === D ? 0 : A._lineHeight / 2), "vertical" === D ? 0 < B2 && h < m.point.y ? h : 0 > B2 && h - k > m.point.y ? h - k : m.point.y : 0 < B2 && h + k - A._lineHeight / 2 < m.point.y ? h + k - A._lineHeight / 2 : 0 > B2 && h - A._lineHeight / 2 > m.point.y ? h - A._lineHeight / 2 : m.point.y) : e.lineTo(p + g2 / 2 - ("horizontal" === D ? 0 : A._lineHeight / 2), h + ("vertical" === D ? h - k < m.point.y ? 0 : -k : (h + k - A._lineHeight / 2 < m.point.y ? k : 0) - A._lineHeight / 2)), e.stroke());
            }
          }
          e = { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 };
          for (a = 0; a < this._indexLabels.length; a++) m = this._indexLabels[a], A = W("indexLabelBackgroundColor", m.dataPoint, m.dataSeries), m.dataSeries.indexLabelBackgroundColor = l(A) ? r ? "transparent" : null : A;
          return e;
        };
        t.prototype.renderLine = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx;
            c.save();
            var d = this.plotArea;
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            for (var f = [], q, w = 0; w < a.dataSeriesIndexes.length; w++) {
              var l2 = a.dataSeriesIndexes[w], k = this.data[l2];
              c.lineWidth = k.lineThickness;
              var m = k.dataPoints, n = "solid";
              if (c.setLineDash) {
                var p = K(
                  k.nullDataLineDashType,
                  k.lineThickness
                ), n = k.lineDashType, h = K(n, k.lineThickness);
                c.setLineDash(h);
              }
              var g2 = k.id;
              this._eventManager.objectMap[g2] = { objectType: "dataSeries", dataSeriesIndex: l2 };
              g2 = T(g2);
              b.strokeStyle = g2;
              b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
              var g2 = k._colorSet, A = g2 = k.lineColor = k.options.lineColor ? k.options.lineColor : g2[0];
              c.strokeStyle = g2;
              var z = true, s = 0, x, v;
              c.beginPath();
              if (0 < m.length) {
                for (var t2 = false, s = 0; s < m.length; s++) if (x = m[s].x.getTime ? m[s].x.getTime() : m[s].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !t2))) if ("number" !== typeof m[s].y) 0 < s && !(k.connectNullData || t2 || z) && (c.stroke(), r && b.stroke()), t2 = true;
                else {
                  x = a.axisX.convertValueToPixel(x);
                  v = a.axisY.convertValueToPixel(m[s].y);
                  var D = k.dataPointIds[s];
                  this._eventManager.objectMap[D] = { id: D, objectType: "dataPoint", dataSeriesIndex: l2, dataPointIndex: s, x1: x, y1: v };
                  z || t2 ? (!z && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || n === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), c.beginPath(), c.moveTo(
                    q.x,
                    q.y
                  ), n = k.nullDataLineDashType, c.setLineDash(p)), c.lineTo(x, v), r && b.lineTo(x, v)) : (c.beginPath(), c.moveTo(x, v), r && (b.beginPath(), b.moveTo(x, v))), t2 = z = false) : (c.lineTo(x, v), r && b.lineTo(x, v), 0 == s % 500 && (c.stroke(), c.beginPath(), c.moveTo(x, v), r && (b.stroke(), b.beginPath(), b.moveTo(x, v))));
                  q = { x, y: v };
                  s < m.length - 1 && (A !== (m[s].lineColor || g2) || n !== (m[s].lineDashType || k.lineDashType)) && (c.stroke(), c.beginPath(), c.moveTo(x, v), A = m[s].lineColor || g2, c.strokeStyle = A, c.setLineDash && (m[s].lineDashType ? (n = m[s].lineDashType, c.setLineDash(K(n, k.lineThickness))) : (n = k.lineDashType, c.setLineDash(h))));
                  if (0 !== m[s].markerSize && (0 < m[s].markerSize || 0 < k.markerSize)) {
                    var R = k.getMarkerProperties(s, x, v, c);
                    f.push(R);
                    D = T(D);
                    r && f.push({ x, y: v, ctx: b, type: R.type, size: R.size, color: D, borderColor: D, borderThickness: R.borderThickness });
                  }
                  (m[s].indexLabel || k.indexLabel || m[s].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "line", dataPoint: m[s], dataSeries: k, point: { x, y: v }, direction: 0 > m[s].y === a.axisY.reversed ? 1 : -1, color: g2 });
                }
                c.stroke();
                r && b.stroke();
              }
            }
            X.drawMarkers(f);
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), b.beginPath());
            c.restore();
            c.beginPath();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderStepLine = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx;
            c.save();
            var d = this.plotArea;
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            for (var f = [], q, w = 0; w < a.dataSeriesIndexes.length; w++) {
              var l2 = a.dataSeriesIndexes[w], k = this.data[l2];
              c.lineWidth = k.lineThickness;
              var m = k.dataPoints, n = "solid";
              if (c.setLineDash) {
                var p = K(k.nullDataLineDashType, k.lineThickness), n = k.lineDashType, h = K(n, k.lineThickness);
                c.setLineDash(h);
              }
              var g2 = k.id;
              this._eventManager.objectMap[g2] = { objectType: "dataSeries", dataSeriesIndex: l2 };
              g2 = T(g2);
              b.strokeStyle = g2;
              b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
              var g2 = k._colorSet, A = g2 = k.lineColor = k.options.lineColor ? k.options.lineColor : g2[0];
              c.strokeStyle = g2;
              var z = true, s = 0, x, v;
              c.beginPath();
              if (0 < m.length) {
                for (var t2 = false, s = 0; s < m.length; s++) if (x = m[s].getTime ? m[s].x.getTime() : m[s].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !t2))) if ("number" !== typeof m[s].y) 0 < s && !(k.connectNullData || t2 || z) && (c.stroke(), r && b.stroke()), t2 = true;
                else {
                  var D = v;
                  x = a.axisX.convertValueToPixel(x);
                  v = a.axisY.convertValueToPixel(m[s].y);
                  var R = k.dataPointIds[s];
                  this._eventManager.objectMap[R] = { id: R, objectType: "dataPoint", dataSeriesIndex: l2, dataPointIndex: s, x1: x, y1: v };
                  z || t2 ? (!z && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || n === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), c.beginPath(), c.moveTo(q.x, q.y), n = k.nullDataLineDashType, c.setLineDash(p)), c.lineTo(x, D), c.lineTo(x, v), r && (b.lineTo(x, D), b.lineTo(x, v))) : (c.beginPath(), c.moveTo(x, v), r && (b.beginPath(), b.moveTo(x, v))), t2 = z = false) : (c.lineTo(x, D), r && b.lineTo(x, D), c.lineTo(x, v), r && b.lineTo(x, v), 0 == s % 500 && (c.stroke(), c.beginPath(), c.moveTo(x, v), r && (b.stroke(), b.beginPath(), b.moveTo(x, v))));
                  q = { x, y: v };
                  s < m.length - 1 && (A !== (m[s].lineColor || g2) || n !== (m[s].lineDashType || k.lineDashType)) && (c.stroke(), c.beginPath(), c.moveTo(x, v), A = m[s].lineColor || g2, c.strokeStyle = A, c.setLineDash && (m[s].lineDashType ? (n = m[s].lineDashType, c.setLineDash(K(n, k.lineThickness))) : (n = k.lineDashType, c.setLineDash(h))));
                  0 !== m[s].markerSize && (0 < m[s].markerSize || 0 < k.markerSize) && (D = k.getMarkerProperties(s, x, v, c), f.push(D), R = T(R), r && f.push({ x, y: v, ctx: b, type: D.type, size: D.size, color: R, borderColor: R, borderThickness: D.borderThickness }));
                  (m[s].indexLabel || k.indexLabel || m[s].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: m[s], dataSeries: k, point: { x, y: v }, direction: 0 > m[s].y === a.axisY.reversed ? 1 : -1, color: g2 });
                }
                c.stroke();
                r && b.stroke();
              }
            }
            X.drawMarkers(f);
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c.clearRect(d.x1, d.y1, d.width, d.height), b.beginPath());
            c.restore();
            c.beginPath();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderSpline = function(a) {
          function e(a2) {
            a2 = u2(a2, 2);
            if (0 < a2.length) {
              b.beginPath();
              r && d.beginPath();
              b.moveTo(a2[0].x, a2[0].y);
              a2[0].newStrokeStyle && (b.strokeStyle = a2[0].newStrokeStyle);
              a2[0].newLineDashArray && b.setLineDash(a2[0].newLineDashArray);
              r && d.moveTo(a2[0].x, a2[0].y);
              for (var c2 = 0; c2 < a2.length - 3; c2 += 3) if (b.bezierCurveTo(a2[c2 + 1].x, a2[c2 + 1].y, a2[c2 + 2].x, a2[c2 + 2].y, a2[c2 + 3].x, a2[c2 + 3].y), r && d.bezierCurveTo(a2[c2 + 1].x, a2[c2 + 1].y, a2[c2 + 2].x, a2[c2 + 2].y, a2[c2 + 3].x, a2[c2 + 3].y), 0 < c2 && 0 === c2 % 3e3 || a2[c2 + 3].newStrokeStyle || a2[c2 + 3].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(a2[c2 + 3].x, a2[c2 + 3].y), a2[c2 + 3].newStrokeStyle && (b.strokeStyle = a2[c2 + 3].newStrokeStyle), a2[c2 + 3].newLineDashArray && b.setLineDash(a2[c2 + 3].newLineDashArray), r && (d.stroke(), d.beginPath(), d.moveTo(a2[c2 + 3].x, a2[c2 + 3].y));
              b.stroke();
              r && d.stroke();
            }
          }
          var c = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx;
            b.save();
            var f = this.plotArea;
            b.beginPath();
            b.rect(f.x1, f.y1, f.width, f.height);
            b.clip();
            for (var q = [], w = 0; w < a.dataSeriesIndexes.length; w++) {
              var l2 = a.dataSeriesIndexes[w], k = this.data[l2];
              b.lineWidth = k.lineThickness;
              var m = k.dataPoints, n = "solid";
              if (b.setLineDash) {
                var p = K(k.nullDataLineDashType, k.lineThickness), n = k.lineDashType, h = K(n, k.lineThickness);
                b.setLineDash(h);
              }
              var g2 = k.id;
              this._eventManager.objectMap[g2] = { objectType: "dataSeries", dataSeriesIndex: l2 };
              g2 = T(g2);
              d.strokeStyle = g2;
              d.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
              var g2 = k._colorSet, A = g2 = k.lineColor = k.options.lineColor ? k.options.lineColor : g2[0];
              b.strokeStyle = g2;
              var z = 0, s, x, v = [];
              b.beginPath();
              if (0 < m.length) {
                for (x = false, z = 0; z < m.length; z++) if (s = m[z].getTime ? m[z].x.getTime() : m[z].x, !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !x))) if ("number" !== typeof m[z].y) 0 < z && !x && (k.connectNullData ? b.setLineDash && (0 < v.length && (k.options.nullDataLineDashType || !m[z - 1].lineDashType)) && (v[v.length - 1].newLineDashArray = p, n = k.nullDataLineDashType) : (e(v), v = [])), x = true;
                else {
                  s = a.axisX.convertValueToPixel(s);
                  x = a.axisY.convertValueToPixel(m[z].y);
                  var t2 = k.dataPointIds[z];
                  this._eventManager.objectMap[t2] = { id: t2, objectType: "dataPoint", dataSeriesIndex: l2, dataPointIndex: z, x1: s, y1: x };
                  v[v.length] = { x: s, y: x };
                  z < m.length - 1 && (A !== (m[z].lineColor || g2) || n !== (m[z].lineDashType || k.lineDashType)) && (A = m[z].lineColor || g2, v[v.length - 1].newStrokeStyle = A, b.setLineDash && (m[z].lineDashType ? (n = m[z].lineDashType, v[v.length - 1].newLineDashArray = K(n, k.lineThickness)) : (n = k.lineDashType, v[v.length - 1].newLineDashArray = h)));
                  if (0 !== m[z].markerSize && (0 < m[z].markerSize || 0 < k.markerSize)) {
                    var D = k.getMarkerProperties(z, s, x, b);
                    q.push(D);
                    t2 = T(t2);
                    r && q.push({ x: s, y: x, ctx: d, type: D.type, size: D.size, color: t2, borderColor: t2, borderThickness: D.borderThickness });
                  }
                  (m[z].indexLabel || k.indexLabel || m[z].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
                    chartType: "spline",
                    dataPoint: m[z],
                    dataSeries: k,
                    point: { x: s, y: x },
                    direction: 0 > m[z].y === a.axisY.reversed ? 1 : -1,
                    color: g2
                  });
                  x = false;
                }
              }
              e(v);
            }
            X.drawMarkers(q);
            r && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(
              f.x1,
              f.y1,
              f.width,
              f.height
            ), d.beginPath());
            b.restore();
            b.beginPath();
            return { source: c, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderColumn = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = 0, q, w, l2, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0, n = a.axisX.dataInfo.minDiff;
            isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));
            n = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > m && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, m));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && m < f) && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            n < f && (n = f);
            n > m && (n = m);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (m = 0; m < a.dataSeriesIndexes.length; m++) {
              var p = a.dataSeriesIndexes[m], h = this.data[p], g2 = h.dataPoints;
              if (0 < g2.length) {
                for (var A = 5 < n && h.bevelEnabled ? true : false, f = 0; f < g2.length; f++) if (g2[f].getTime ? l2 = g2[f].x.getTime() : l2 = g2[f].x, !(l2 < a.axisX.dataInfo.viewPortMin || l2 > a.axisX.dataInfo.viewPortMax) && "number" === typeof g2[f].y) {
                  q = a.axisX.convertValueToPixel(l2);
                  w = a.axisY.convertValueToPixel(g2[f].y);
                  q = a.axisX.reversed ? q + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + m) * n << 0 : q - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + m) * n << 0;
                  var z = a.axisX.reversed ? q - n << 0 : q + n << 0, s;
                  0 <= g2[f].y ? s = k : (s = w, w = k);
                  w > s && (b = w, w = s, s = b);
                  b = g2[f].color ? g2[f].color : h._colorSet[f % h._colorSet.length];
                  Y(c, a.axisX.reversed ? z : q, w, a.axisX.reversed ? q : z, s, b, 0, null, A && (a.axisY.reversed ? 0 > g2[f].y : 0 <= g2[f].y), (a.axisY.reversed ? 0 <= g2[f].y : 0 > g2[f].y) && A, false, false, h.fillOpacity);
                  b = h.dataPointIds[f];
                  this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: f, x1: q, y1: w, x2: z, y2: s };
                  b = T(b);
                  r && Y(
                    this._eventManager.ghostCtx,
                    a.axisX.reversed ? z : q,
                    w,
                    a.axisX.reversed ? q : z,
                    s,
                    b,
                    0,
                    null,
                    false,
                    false,
                    false,
                    false
                  );
                  (g2[f].indexLabel || h.indexLabel || g2[f].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: g2[f], dataSeries: h, point: { x: q + (z - q) / 2, y: 0 > g2[f].y === a.axisY.reversed ? w : s }, direction: 0 > g2[f].y === a.axisY.reversed ? 1 : -1, bounds: { x1: q, y1: Math.min(w, s), x2: z, y2: Math.max(w, s) }, color: b });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.yScaleAnimation, easingFunction: O.easing.easeOutQuart, animationBase: k < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : k > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : k };
          }
        };
        t.prototype.renderStackedColumn = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = [], q = [], l2 = [], g2 = [], k = 0, m, n, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, h = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0, y = a.axisX.dataInfo.minDiff;
            isFinite(y) || (y = 0.3 * Math.abs(a.axisX.range));
            y = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.width * (a.axisX.logarithmic ? Math.log(y) / Math.log(a.axisX.range) : Math.abs(y) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > h && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, h));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && h < k) && (h = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            y < k && (y = k);
            y > h && (y = h);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (h = 0; h < a.dataSeriesIndexes.length; h++) {
              var A = a.dataSeriesIndexes[h], z = this.data[A], s = z.dataPoints;
              if (0 < s.length) {
                var x = 5 < y && z.bevelEnabled ? true : false;
                c.strokeStyle = "#4572A7 ";
                for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[k].y) {
                  m = a.axisX.convertValueToPixel(b);
                  m = m - a.plotType.plotUnits.length * y / 2 + a.index * y << 0;
                  var v = m + y << 0, t2;
                  if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) l2[b] = s[k].y + (l2[b] ? l2[b] : 0), 0 < l2[b] && (n = a.axisY.convertValueToPixel(l2[b]), t2 = "undefined" !== typeof f[b] ? f[b] : p, f[b] = n);
                  else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) g2[b] = s[k].y + (g2[b] ? g2[b] : 0), t2 = a.axisY.convertValueToPixel(g2[b]), n = "undefined" !== typeof q[b] ? q[b] : p, q[b] = t2;
                  else if (n = a.axisY.convertValueToPixel(s[k].y), 0 <= s[k].y) {
                    var D = "undefined" !== typeof f[b] ? f[b] : 0;
                    n -= D;
                    t2 = p - D;
                    f[b] = D + (t2 - n);
                  } else D = q[b] ? q[b] : 0, t2 = n + D, n = p + D, q[b] = D + (t2 - n);
                  b = s[k].color ? s[k].color : z._colorSet[k % z._colorSet.length];
                  Y(c, m, a.axisY.reversed ? t2 : n, v, a.axisY.reversed ? n : t2, b, 0, null, x && (a.axisY.reversed ? 0 > s[k].y : 0 <= s[k].y), (a.axisY.reversed ? 0 <= s[k].y : 0 > s[k].y) && x, false, false, z.fillOpacity);
                  b = z.dataPointIds[k];
                  this._eventManager.objectMap[b] = {
                    id: b,
                    objectType: "dataPoint",
                    dataSeriesIndex: A,
                    dataPointIndex: k,
                    x1: m,
                    y1: n,
                    x2: v,
                    y2: t2
                  };
                  b = T(b);
                  r && Y(this._eventManager.ghostCtx, m, n, v, t2, b, 0, null, false, false, false, false);
                  (s[k].indexLabel || z.indexLabel || s[k].indexLabelFormatter || z.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: s[k], dataSeries: z, point: { x: m + (v - m) / 2, y: 0 <= s[k].y ? n : t2 }, direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: m, y1: Math.min(n, t2), x2: v, y2: Math.max(n, t2) }, color: b, cumulativeY: z.dataPointEOs[k].cumulativeY });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return {
              source: e,
              dest: this.plotArea.ctx,
              animationCallback: O.yScaleAnimation,
              easingFunction: O.easing.easeOutQuart,
              animationBase: p < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : p > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : p
            };
          }
        };
        t.prototype.renderStackedColumn100 = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = [], q = [], l2 = [], g2 = [], k = 0, m, n, p, h = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            p = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;
            var y = a.axisX.dataInfo.minDiff;
            isFinite(y) || (y = 0.3 * Math.abs(a.axisX.range));
            y = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.width * (a.axisX.logarithmic ? Math.log(y) / Math.log(a.axisX.range) : Math.abs(y) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > p && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, p));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && p < k) && (p = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            y < k && (y = k);
            y > p && (y = p);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (var A = 0; A < a.dataSeriesIndexes.length; A++) {
              var z = a.dataSeriesIndexes[A], s = this.data[z], x = s.dataPoints;
              if (0 < x.length) {
                for (var v = 5 < y && s.bevelEnabled ? true : false, k = 0; k < x.length; k++) if (p = x[k].x.getTime ? x[k].x.getTime() : x[k].x, !(p < a.axisX.dataInfo.viewPortMin || p > a.axisX.dataInfo.viewPortMax) && "number" === typeof x[k].y) {
                  m = a.axisX.convertValueToPixel(p);
                  n = 0 !== a.dataPointYSums[p] ? 100 * (x[k].y / a.dataPointYSums[p]) : 0;
                  m = m - a.plotType.plotUnits.length * y / 2 + a.index * y << 0;
                  var t2 = m + y << 0, D;
                  if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < x[k].y) {
                    l2[p] = n + ("undefined" !== typeof l2[p] ? l2[p] : 0);
                    if (0 >= l2[p]) continue;
                    n = a.axisY.convertValueToPixel(l2[p]);
                    D = f[p] ? f[p] : h;
                    f[p] = n;
                  } else a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= x[k].y ? (g2[p] = n + ("undefined" !== typeof g2[p] ? g2[p] : 0), D = a.axisY.convertValueToPixel(g2[p]), n = q[p] ? q[p] : h, q[p] = D) : (n = a.axisY.convertValueToPixel(n), 0 <= x[k].y ? (b = "undefined" !== typeof f[p] ? f[p] : 0, n -= b, D = h - b, a.dataSeriesIndexes.length - 1 === A && 1 >= Math.abs(d.y1 - n) && (n = d.y1), f[p] = b + (D - n)) : (b = "undefined" !== typeof q[p] ? q[p] : 0, D = n + b, n = h + b, a.dataSeriesIndexes.length - 1 === A && 1 >= Math.abs(d.y2 - D) && (D = d.y2), q[p] = b + (D - n)));
                  b = x[k].color ? x[k].color : s._colorSet[k % s._colorSet.length];
                  Y(c, m, a.axisY.reversed ? D : n, t2, a.axisY.reversed ? n : D, b, 0, null, v && (a.axisY.reversed ? 0 > x[k].y : 0 <= x[k].y), (a.axisY.reversed ? 0 <= x[k].y : 0 > x[k].y) && v, false, false, s.fillOpacity);
                  b = s.dataPointIds[k];
                  this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: z, dataPointIndex: k, x1: m, y1: n, x2: t2, y2: D };
                  b = T(b);
                  r && Y(this._eventManager.ghostCtx, m, n, t2, D, b, 0, null, false, false, false, false);
                  (x[k].indexLabel || s.indexLabel || x[k].indexLabelFormatter || s.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn100", dataPoint: x[k], dataSeries: s, point: { x: m + (t2 - m) / 2, y: 0 <= x[k].y ? n : D }, direction: 0 > x[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: m, y1: Math.min(n, D), x2: t2, y2: Math.max(n, D) }, color: b, yCumulative: 100 * (s.dataPointEOs[k].cumulativeY / a.dataPointYSums[p]) });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(
              a.axisY.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.yScaleAnimation, easingFunction: O.easing.easeOutQuart, animationBase: h < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : h > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : h };
          }
        };
        t.prototype.renderBar = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = 0, q, l2, g2, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0, n = a.axisX.dataInfo.minDiff;
            isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));
            n = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.height * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > m && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, m));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && m < f) && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            n < f && (n = f);
            n > m && (n = m);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (m = 0; m < a.dataSeriesIndexes.length; m++) {
              var p = a.dataSeriesIndexes[m], h = this.data[p], y = h.dataPoints;
              if (0 < y.length) {
                var A = 5 < n && h.bevelEnabled ? true : false;
                c.strokeStyle = "#4572A7 ";
                for (f = 0; f < y.length; f++) if (y[f].getTime ? g2 = y[f].x.getTime() : g2 = y[f].x, !(g2 < a.axisX.dataInfo.viewPortMin || g2 > a.axisX.dataInfo.viewPortMax) && "number" === typeof y[f].y) {
                  l2 = a.axisX.convertValueToPixel(g2);
                  q = a.axisY.convertValueToPixel(y[f].y);
                  l2 = a.axisX.reversed ? l2 + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + m) * n << 0 : l2 - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + m) * n << 0;
                  var z = a.axisX.reversed ? l2 - n << 0 : l2 + n << 0, s;
                  0 <= y[f].y ? s = k : (s = q, q = k);
                  b = y[f].color ? y[f].color : h._colorSet[f % h._colorSet.length];
                  Y(c, a.axisY.reversed ? q : s, a.axisX.reversed ? z : l2, a.axisY.reversed ? s : q, a.axisX.reversed ? l2 : z, b, 0, null, A, false, false, false, h.fillOpacity);
                  b = h.dataPointIds[f];
                  this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: f, x1: s, y1: l2, x2: q, y2: z };
                  b = T(b);
                  r && Y(this._eventManager.ghostCtx, s, a.axisX.reversed ? z : l2, q, a.axisX.reversed ? l2 : z, b, 0, null, false, false, false, false);
                  (y[f].indexLabel || h.indexLabel || y[f].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: "bar", dataPoint: y[f], dataSeries: h, point: { x: 0 <= y[f].y ? q : s, y: l2 + (z - l2) / 2 }, direction: 0 > y[f].y === a.axisY.reversed ? 1 : -1, bounds: {
                    x1: Math.min(s, q),
                    y1: l2,
                    x2: Math.max(s, q),
                    y2: z
                  }, color: b });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return {
              source: e,
              dest: this.plotArea.ctx,
              animationCallback: O.xScaleAnimation,
              easingFunction: O.easing.easeOutQuart,
              animationBase: k < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : k > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : k
            };
          }
        };
        t.prototype.renderStackedBar = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = [], q = [], l2 = [], g2 = [], k = 0, m, n, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, h = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0, y = a.axisX.dataInfo.minDiff;
            isFinite(y) || (y = 0.3 * Math.abs(a.axisX.range));
            y = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.height * (a.axisX.logarithmic ? Math.log(y) / Math.log(a.axisX.range) : Math.abs(y) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > h && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, h));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && h < k) && (h = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            y < k && (y = k);
            y > h && (y = h);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (h = 0; h < a.dataSeriesIndexes.length; h++) {
              var A = a.dataSeriesIndexes[h], z = this.data[A], s = z.dataPoints;
              if (0 < s.length) {
                var x = 5 < y && z.bevelEnabled ? true : false;
                c.strokeStyle = "#4572A7 ";
                for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[k].y) {
                  n = a.axisX.convertValueToPixel(b);
                  n = n - a.plotType.plotUnits.length * y / 2 + a.index * y << 0;
                  var v = n + y << 0, t2;
                  if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) l2[b] = s[k].y + (l2[b] ? l2[b] : 0), 0 < l2[b] && (t2 = f[b] ? f[b] : p, f[b] = m = a.axisY.convertValueToPixel(l2[b]));
                  else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) g2[b] = s[k].y + (g2[b] ? g2[b] : 0), m = q[b] ? q[b] : p, q[b] = t2 = a.axisY.convertValueToPixel(g2[b]);
                  else if (m = a.axisY.convertValueToPixel(s[k].y), 0 <= s[k].y) {
                    var D = f[b] ? f[b] : 0;
                    t2 = p + D;
                    m += D;
                    f[b] = D + (m - t2);
                  } else D = q[b] ? q[b] : 0, t2 = m - D, m = p - D, q[b] = D + (m - t2);
                  b = s[k].color ? s[k].color : z._colorSet[k % z._colorSet.length];
                  Y(c, a.axisY.reversed ? m : t2, n, a.axisY.reversed ? t2 : m, v, b, 0, null, x, false, false, false, z.fillOpacity);
                  b = z.dataPointIds[k];
                  this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: A, dataPointIndex: k, x1: t2, y1: n, x2: m, y2: v };
                  b = T(b);
                  r && Y(this._eventManager.ghostCtx, t2, n, m, v, b, 0, null, false, false, false, false);
                  (s[k].indexLabel || z.indexLabel || s[k].indexLabelFormatter || z.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar", dataPoint: s[k], dataSeries: z, point: { x: 0 <= s[k].y ? m : t2, y: n + (v - n) / 2 }, direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(t2, m), y1: n, x2: Math.max(t2, m), y2: v }, color: b });
                }
              }
            }
            r && (e.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return {
              source: e,
              dest: this.plotArea.ctx,
              animationCallback: O.xScaleAnimation,
              easingFunction: O.easing.easeOutQuart,
              animationBase: p < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : p > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : p
            };
          }
        };
        t.prototype.renderStackedBar100 = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = [], q = [], l2 = [], g2 = [], k = 0, m, n, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, h = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0, y = a.axisX.dataInfo.minDiff;
            isFinite(y) || (y = 0.3 * Math.abs(a.axisX.range));
            y = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.height * (a.axisX.logarithmic ? Math.log(y) / Math.log(a.axisX.range) : Math.abs(y) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > h && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, h));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && h < k) && (h = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            y < k && (y = k);
            y > h && (y = h);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (h = 0; h < a.dataSeriesIndexes.length; h++) {
              var A = a.dataSeriesIndexes[h], z = this.data[A], s = z.dataPoints;
              if (0 < s.length) {
                var x = 5 < y && z.bevelEnabled ? true : false;
                c.strokeStyle = "#4572A7 ";
                for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[k].y) {
                  n = a.axisX.convertValueToPixel(b);
                  var v;
                  v = 0 !== a.dataPointYSums[b] ? 100 * (s[k].y / a.dataPointYSums[b]) : 0;
                  n = n - a.plotType.plotUnits.length * y / 2 + a.index * y << 0;
                  var t2 = n + y << 0;
                  if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) {
                    l2[b] = v + (l2[b] ? l2[b] : 0);
                    if (0 >= l2[b]) continue;
                    v = f[b] ? f[b] : p;
                    f[b] = m = a.axisY.convertValueToPixel(l2[b]);
                  } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) g2[b] = v + (g2[b] ? g2[b] : 0), m = q[b] ? q[b] : p, q[b] = v = a.axisY.convertValueToPixel(g2[b]);
                  else if (m = a.axisY.convertValueToPixel(v), 0 <= s[k].y) {
                    var D = f[b] ? f[b] : 0;
                    v = p + D;
                    m += D;
                    a.dataSeriesIndexes.length - 1 === h && 1 >= Math.abs(d.x2 - m) && (m = d.x2);
                    f[b] = D + (m - v);
                  } else D = q[b] ? q[b] : 0, v = m - D, m = p - D, a.dataSeriesIndexes.length - 1 === h && 1 >= Math.abs(d.x1 - v) && (v = d.x1), q[b] = D + (m - v);
                  b = s[k].color ? s[k].color : z._colorSet[k % z._colorSet.length];
                  Y(c, a.axisY.reversed ? m : v, n, a.axisY.reversed ? v : m, t2, b, 0, null, x, false, false, false, z.fillOpacity);
                  b = z.dataPointIds[k];
                  this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: A, dataPointIndex: k, x1: v, y1: n, x2: m, y2: t2 };
                  b = T(b);
                  r && Y(this._eventManager.ghostCtx, v, n, m, t2, b, 0, null, false, false, false, false);
                  (s[k].indexLabel || z.indexLabel || s[k].indexLabelFormatter || z.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar100", dataPoint: s[k], dataSeries: z, point: { x: 0 <= s[k].y ? m : v, y: n + (t2 - n) / 2 }, direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(
                    v,
                    m
                  ), y1: n, x2: Math.max(v, m), y2: t2 }, color: b });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.xScaleAnimation, easingFunction: O.easing.easeOutQuart, animationBase: p < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : p > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : p };
          }
        };
        t.prototype.renderArea = function(a) {
          var e, c;
          function b() {
            D && (0 < h.lineThickness && f.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? t2 = v : 0 > a.axisY.viewportMaximum ? t2 = l2.y1 : 0 < a.axisY.viewportMinimum && (t2 = v), f.lineTo(z, t2), f.lineTo(D.x, t2), f.closePath(), f.globalAlpha = h.fillOpacity, f.fill(), f.globalAlpha = 1, r && (q.lineTo(z, t2), q.lineTo(D.x, t2), q.closePath(), q.fill()), f.beginPath(), f.moveTo(z, s), q.beginPath(), q.moveTo(z, s), D = { x: z, y: s });
          }
          var d = a.targetCanvasCtx || this.plotArea.ctx, f = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var q = this._eventManager.ghostCtx, l2 = a.axisY.lineCoordinates, g2 = [], k = this.plotArea, m;
            f.save();
            r && q.save();
            f.beginPath();
            f.rect(k.x1, k.y1, k.width, k.height);
            f.clip();
            r && (q.beginPath(), q.rect(k.x1, k.y1, k.width, k.height), q.clip());
            for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
              var p = a.dataSeriesIndexes[n], h = this.data[p], y = h.dataPoints, g2 = h.id;
              this._eventManager.objectMap[g2] = { objectType: "dataSeries", dataSeriesIndex: p };
              g2 = T(g2);
              q.fillStyle = g2;
              g2 = [];
              e = true;
              var A = 0, z, s, x, v = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), t2, D = null;
              if (0 < y.length) {
                var R = h._colorSet[A % h._colorSet.length], u3 = h.lineColor = h.options.lineColor || R, B2 = u3;
                f.fillStyle = R;
                f.strokeStyle = u3;
                f.lineWidth = h.lineThickness;
                c = "solid";
                if (f.setLineDash) {
                  var L = K(
                    h.nullDataLineDashType,
                    h.lineThickness
                  );
                  c = h.lineDashType;
                  var N = K(c, h.lineThickness);
                  f.setLineDash(N);
                }
                for (var Z = true; A < y.length; A++) if (x = y[A].x.getTime ? y[A].x.getTime() : y[A].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!h.connectNullData || !Z))) if ("number" !== typeof y[A].y) h.connectNullData || (Z || e) || b(), Z = true;
                else {
                  z = a.axisX.convertValueToPixel(x);
                  s = a.axisY.convertValueToPixel(y[A].y);
                  e || Z ? (!e && h.connectNullData ? (f.setLineDash && (h.options.nullDataLineDashType || c === h.lineDashType && h.lineDashType !== h.nullDataLineDashType) && (e = z, c = s, z = m.x, s = m.y, b(), f.moveTo(m.x, m.y), z = e, s = c, D = m, c = h.nullDataLineDashType, f.setLineDash(L)), f.lineTo(z, s), r && q.lineTo(z, s)) : (f.beginPath(), f.moveTo(z, s), r && (q.beginPath(), q.moveTo(z, s)), D = { x: z, y: s }), Z = e = false) : (f.lineTo(z, s), r && q.lineTo(z, s), 0 == A % 250 && b());
                  m = { x: z, y: s };
                  A < y.length - 1 && (B2 !== (y[A].lineColor || u3) || c !== (y[A].lineDashType || h.lineDashType)) && (b(), B2 = y[A].lineColor || u3, f.strokeStyle = B2, f.setLineDash && (y[A].lineDashType ? (c = y[A].lineDashType, f.setLineDash(K(c, h.lineThickness))) : (c = h.lineDashType, f.setLineDash(N))));
                  var $ = h.dataPointIds[A];
                  this._eventManager.objectMap[$] = { id: $, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: A, x1: z, y1: s };
                  0 !== y[A].markerSize && (0 < y[A].markerSize || 0 < h.markerSize) && (x = h.getMarkerProperties(A, z, s, f), g2.push(x), $ = T($), r && g2.push({ x: z, y: s, ctx: q, type: x.type, size: x.size, color: $, borderColor: $, borderThickness: x.borderThickness }));
                  (y[A].indexLabel || h.indexLabel || y[A].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({
                    chartType: "area",
                    dataPoint: y[A],
                    dataSeries: h,
                    point: { x: z, y: s },
                    direction: 0 > y[A].y === a.axisY.reversed ? 1 : -1,
                    color: R
                  });
                }
                b();
                X.drawMarkers(g2);
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && f.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && f.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.clearRect(
              k.x1,
              k.y1,
              k.width,
              k.height
            ), this._eventManager.ghostCtx.restore());
            f.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderSplineArea = function(a) {
          function e() {
            var c2 = u2(x, 2);
            if (0 < c2.length) {
              if (0 < m.lineThickness) {
                b.beginPath();
                b.moveTo(c2[0].x, c2[0].y);
                c2[0].newStrokeStyle && (b.strokeStyle = c2[0].newStrokeStyle);
                c2[0].newLineDashArray && b.setLineDash(c2[0].newLineDashArray);
                for (var e2 = 0; e2 < c2.length - 3; e2 += 3) if (b.bezierCurveTo(
                  c2[e2 + 1].x,
                  c2[e2 + 1].y,
                  c2[e2 + 2].x,
                  c2[e2 + 2].y,
                  c2[e2 + 3].x,
                  c2[e2 + 3].y
                ), r && d.bezierCurveTo(c2[e2 + 1].x, c2[e2 + 1].y, c2[e2 + 2].x, c2[e2 + 2].y, c2[e2 + 3].x, c2[e2 + 3].y), c2[e2 + 3].newStrokeStyle || c2[e2 + 3].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(c2[e2 + 3].x, c2[e2 + 3].y), c2[e2 + 3].newStrokeStyle && (b.strokeStyle = c2[e2 + 3].newStrokeStyle), c2[e2 + 3].newLineDashArray && b.setLineDash(c2[e2 + 3].newLineDashArray);
                b.stroke();
              }
              b.beginPath();
              b.moveTo(c2[0].x, c2[0].y);
              r && (d.beginPath(), d.moveTo(c2[0].x, c2[0].y));
              for (e2 = 0; e2 < c2.length - 3; e2 += 3) b.bezierCurveTo(c2[e2 + 1].x, c2[e2 + 1].y, c2[e2 + 2].x, c2[e2 + 2].y, c2[e2 + 3].x, c2[e2 + 3].y), r && d.bezierCurveTo(c2[e2 + 1].x, c2[e2 + 1].y, c2[e2 + 2].x, c2[e2 + 2].y, c2[e2 + 3].x, c2[e2 + 3].y);
              a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? z = A : 0 > a.axisY.viewportMaximum ? z = f.y1 : 0 < a.axisY.viewportMinimum && (z = A);
              s = { x: c2[0].x, y: c2[0].y };
              b.lineTo(c2[c2.length - 1].x, z);
              b.lineTo(s.x, z);
              b.closePath();
              b.globalAlpha = m.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              r && (d.lineTo(c2[c2.length - 1].x, z), d.lineTo(s.x, z), d.closePath(), d.fill());
            }
          }
          var c = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx, f = a.axisY.lineCoordinates, q = [], l2 = this.plotArea;
            b.save();
            r && d.save();
            b.beginPath();
            b.rect(l2.x1, l2.y1, l2.width, l2.height);
            b.clip();
            r && (d.beginPath(), d.rect(l2.x1, l2.y1, l2.width, l2.height), d.clip());
            for (var g2 = 0; g2 < a.dataSeriesIndexes.length; g2++) {
              var k = a.dataSeriesIndexes[g2], m = this.data[k], n = m.dataPoints, q = m.id;
              this._eventManager.objectMap[q] = { objectType: "dataSeries", dataSeriesIndex: k };
              q = T(q);
              d.fillStyle = q;
              var q = [], p = 0, h, y, A = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), z, s = null, x = [];
              if (0 < n.length) {
                var v = m._colorSet[p % m._colorSet.length], t2 = m.lineColor = m.options.lineColor || v, D = t2;
                b.fillStyle = v;
                b.strokeStyle = t2;
                b.lineWidth = m.lineThickness;
                var R = "solid";
                if (b.setLineDash) {
                  var B2 = K(m.nullDataLineDashType, m.lineThickness), R = m.lineDashType, C3 = K(R, m.lineThickness);
                  b.setLineDash(C3);
                }
                for (y = false; p < n.length; p++) if (h = n[p].x.getTime ? n[p].x.getTime() : n[p].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !y))) if ("number" !== typeof n[p].y) 0 < p && !y && (m.connectNullData ? b.setLineDash && (0 < x.length && (m.options.nullDataLineDashType || !n[p - 1].lineDashType)) && (x[x.length - 1].newLineDashArray = B2, R = m.nullDataLineDashType) : (e(), x = [])), y = true;
                else {
                  h = a.axisX.convertValueToPixel(h);
                  y = a.axisY.convertValueToPixel(n[p].y);
                  var L = m.dataPointIds[p];
                  this._eventManager.objectMap[L] = { id: L, objectType: "dataPoint", dataSeriesIndex: k, dataPointIndex: p, x1: h, y1: y };
                  x[x.length] = { x: h, y };
                  p < n.length - 1 && (D !== (n[p].lineColor || t2) || R !== (n[p].lineDashType || m.lineDashType)) && (D = n[p].lineColor || t2, x[x.length - 1].newStrokeStyle = D, b.setLineDash && (n[p].lineDashType ? (R = n[p].lineDashType, x[x.length - 1].newLineDashArray = K(R, m.lineThickness)) : (R = m.lineDashType, x[x.length - 1].newLineDashArray = C3)));
                  if (0 !== n[p].markerSize && (0 < n[p].markerSize || 0 < m.markerSize)) {
                    var N = m.getMarkerProperties(p, h, y, b);
                    q.push(N);
                    L = T(L);
                    r && q.push({ x: h, y, ctx: d, type: N.type, size: N.size, color: L, borderColor: L, borderThickness: N.borderThickness });
                  }
                  (n[p].indexLabel || m.indexLabel || n[p].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "splineArea", dataPoint: n[p], dataSeries: m, point: { x: h, y }, direction: 0 > n[p].y === a.axisY.reversed ? 1 : -1, color: v });
                  y = false;
                }
                e();
                X.drawMarkers(q);
              }
            }
            r && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(l2.x1, l2.y1, l2.width, l2.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderStepArea = function(a) {
          var e, c;
          function b() {
            D && (0 < h.lineThickness && f.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? t2 = v : 0 > a.axisY.viewportMaximum ? t2 = l2.y1 : 0 < a.axisY.viewportMinimum && (t2 = v), f.lineTo(z, t2), f.lineTo(D.x, t2), f.closePath(), f.globalAlpha = h.fillOpacity, f.fill(), f.globalAlpha = 1, r && (q.lineTo(z, t2), q.lineTo(D.x, t2), q.closePath(), q.fill()), f.beginPath(), f.moveTo(z, s), q.beginPath(), q.moveTo(z, s), D = { x: z, y: s });
          }
          var d = a.targetCanvasCtx || this.plotArea.ctx, f = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var q = this._eventManager.ghostCtx, l2 = a.axisY.lineCoordinates, g2 = [], k = this.plotArea, m;
            f.save();
            r && q.save();
            f.beginPath();
            f.rect(
              k.x1,
              k.y1,
              k.width,
              k.height
            );
            f.clip();
            r && (q.beginPath(), q.rect(k.x1, k.y1, k.width, k.height), q.clip());
            for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
              var p = a.dataSeriesIndexes[n], h = this.data[p], y = h.dataPoints, g2 = h.id;
              this._eventManager.objectMap[g2] = { objectType: "dataSeries", dataSeriesIndex: p };
              g2 = T(g2);
              q.fillStyle = g2;
              g2 = [];
              e = true;
              var A = 0, z, s, x, v = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), t2, D = null;
              c = false;
              if (0 < y.length) {
                var R = h._colorSet[A % h._colorSet.length], u3 = h.lineColor = h.options.lineColor || R, B2 = u3;
                f.fillStyle = R;
                f.strokeStyle = u3;
                f.lineWidth = h.lineThickness;
                var L = "solid";
                if (f.setLineDash) {
                  var N = K(h.nullDataLineDashType, h.lineThickness), L = h.lineDashType, Z = K(L, h.lineThickness);
                  f.setLineDash(Z);
                }
                for (; A < y.length; A++) if (x = y[A].x.getTime ? y[A].x.getTime() : y[A].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!h.connectNullData || !c))) {
                  var $ = s;
                  "number" !== typeof y[A].y ? (h.connectNullData || (c || e) || b(), c = true) : (z = a.axisX.convertValueToPixel(x), s = a.axisY.convertValueToPixel(y[A].y), e || c ? (!e && h.connectNullData ? (f.setLineDash && (h.options.nullDataLineDashType || L === h.lineDashType && h.lineDashType !== h.nullDataLineDashType) && (e = z, c = s, z = m.x, s = m.y, b(), f.moveTo(m.x, m.y), z = e, s = c, D = m, L = h.nullDataLineDashType, f.setLineDash(N)), f.lineTo(z, $), f.lineTo(z, s), r && (q.lineTo(z, $), q.lineTo(z, s))) : (f.beginPath(), f.moveTo(z, s), r && (q.beginPath(), q.moveTo(z, s)), D = { x: z, y: s }), c = e = false) : (f.lineTo(z, $), r && q.lineTo(z, $), f.lineTo(z, s), r && q.lineTo(z, s), 0 == A % 250 && b()), m = { x: z, y: s }, A < y.length - 1 && (B2 !== (y[A].lineColor || u3) || L !== (y[A].lineDashType || h.lineDashType)) && (b(), B2 = y[A].lineColor || u3, f.strokeStyle = B2, f.setLineDash && (y[A].lineDashType ? (L = y[A].lineDashType, f.setLineDash(K(L, h.lineThickness))) : (L = h.lineDashType, f.setLineDash(Z)))), x = h.dataPointIds[A], this._eventManager.objectMap[x] = { id: x, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: A, x1: z, y1: s }, 0 !== y[A].markerSize && (0 < y[A].markerSize || 0 < h.markerSize) && ($ = h.getMarkerProperties(A, z, s, f), g2.push($), x = T(x), r && g2.push({
                    x: z,
                    y: s,
                    ctx: q,
                    type: $.type,
                    size: $.size,
                    color: x,
                    borderColor: x,
                    borderThickness: $.borderThickness
                  })), (y[A].indexLabel || h.indexLabel || y[A].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: y[A], dataSeries: h, point: { x: z, y: s }, direction: 0 > y[A].y === a.axisY.reversed ? 1 : -1, color: R }));
                }
                b();
                X.drawMarkers(g2);
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && f.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && f.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());
            f.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderStackedArea = function(a) {
          function e() {
            if (!(1 > k.length)) {
              for (0 < R.lineThickness && b.stroke(); 0 < k.length; ) {
                var a2 = k.pop();
                b.lineTo(a2.x, a2.y);
                r && z.lineTo(a2.x, a2.y);
              }
              b.closePath();
              b.globalAlpha = R.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              b.beginPath();
              r && (z.closePath(), z.fill(), z.beginPath());
              k = [];
            }
          }
          var c = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = null, f = null, q = [], l2 = this.plotArea, g2 = [], k = [], m = [], n = [], p = 0, h, y, A = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), z = this._eventManager.ghostCtx, s, x, v;
            r && z.beginPath();
            b.save();
            r && z.save();
            b.beginPath();
            b.rect(l2.x1, l2.y1, l2.width, l2.height);
            b.clip();
            r && (z.beginPath(), z.rect(l2.x1, l2.y1, l2.width, l2.height), z.clip());
            for (var d = [], t2 = 0; t2 < a.dataSeriesIndexes.length; t2++) {
              var D = a.dataSeriesIndexes[t2], R = this.data[D], u3 = R.dataPoints;
              R.dataPointIndexes = [];
              for (p = 0; p < u3.length; p++) D = u3[p].x.getTime ? u3[p].x.getTime() : u3[p].x, R.dataPointIndexes[D] = p, d[D] || (m.push(D), d[D] = true);
              m.sort(Qa);
            }
            for (t2 = 0; t2 < a.dataSeriesIndexes.length; t2++) {
              D = a.dataSeriesIndexes[t2];
              R = this.data[D];
              u3 = R.dataPoints;
              x = true;
              k = [];
              p = R.id;
              this._eventManager.objectMap[p] = { objectType: "dataSeries", dataSeriesIndex: D };
              p = T(p);
              z.fillStyle = p;
              if (0 < m.length) {
                var d = R._colorSet[0], B2 = R.lineColor = R.options.lineColor || d, L = B2;
                b.fillStyle = d;
                b.strokeStyle = B2;
                b.lineWidth = R.lineThickness;
                v = "solid";
                if (b.setLineDash) {
                  var N = K(R.nullDataLineDashType, R.lineThickness);
                  v = R.lineDashType;
                  var Z = K(v, R.lineThickness);
                  b.setLineDash(Z);
                }
                for (var $ = true, p = 0; p < m.length; p++) {
                  var f = m[p], ca = null, ca = 0 <= R.dataPointIndexes[f] ? u3[R.dataPointIndexes[f]] : { x: f, y: null };
                  if (!(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax && (!R.connectNullData || !$))) if ("number" !== typeof ca.y) R.connectNullData || ($ || x) || e(), $ = true;
                  else {
                    h = a.axisX.convertValueToPixel(f);
                    var ma = g2[f] ? g2[f] : 0;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                      n[f] = ca.y + (n[f] ? n[f] : 0);
                      if (0 >= n[f] && a.axisY.logarithmic) continue;
                      y = a.axisY.convertValueToPixel(n[f]);
                    } else y = a.axisY.convertValueToPixel(ca.y), y -= ma;
                    k.push({ x: h, y: A - ma });
                    g2[f] = A - y;
                    x || $ ? (!x && R.connectNullData ? (b.setLineDash && (R.options.nullDataLineDashType || v === R.lineDashType && R.lineDashType !== R.nullDataLineDashType) && (x = k.pop(), v = k[k.length - 1], e(), b.moveTo(s.x, s.y), k.push(v), k.push(x), v = R.nullDataLineDashType, b.setLineDash(N)), b.lineTo(h, y), r && z.lineTo(h, y)) : (b.beginPath(), b.moveTo(h, y), r && (z.beginPath(), z.moveTo(h, y))), $ = x = false) : (b.lineTo(h, y), r && z.lineTo(h, y), 0 == p % 250 && (e(), b.moveTo(h, y), r && z.moveTo(h, y), k.push({ x: h, y: A - ma })));
                    s = { x: h, y };
                    p < u3.length - 1 && (L !== (u3[p].lineColor || B2) || v !== (u3[p].lineDashType || R.lineDashType)) && (e(), b.beginPath(), b.moveTo(h, y), k.push({ x: h, y: A - ma }), L = u3[p].lineColor || B2, b.strokeStyle = L, b.setLineDash && (u3[p].lineDashType ? (v = u3[p].lineDashType, b.setLineDash(K(v, R.lineThickness))) : (v = R.lineDashType, b.setLineDash(Z))));
                    if (0 <= R.dataPointIndexes[f]) {
                      var C3 = R.dataPointIds[R.dataPointIndexes[f]];
                      this._eventManager.objectMap[C3] = { id: C3, objectType: "dataPoint", dataSeriesIndex: D, dataPointIndex: R.dataPointIndexes[f], x1: h, y1: y };
                    }
                    0 <= R.dataPointIndexes[f] && 0 !== ca.markerSize && (0 < ca.markerSize || 0 < R.markerSize) && (ma = R.getMarkerProperties(
                      R.dataPointIndexes[f],
                      h,
                      y,
                      b
                    ), q.push(ma), f = T(C3), r && q.push({ x: h, y, ctx: z, type: ma.type, size: ma.size, color: f, borderColor: f, borderThickness: ma.borderThickness }));
                    (ca.indexLabel || R.indexLabel || ca.indexLabelFormatter || R.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: ca, dataSeries: R, point: { x: h, y }, direction: 0 > ca.y === a.axisY.reversed ? 1 : -1, color: d });
                  }
                }
                e();
                b.moveTo(h, y);
                r && z.moveTo(h, y);
              }
              delete R.dataPointIndexes;
            }
            X.drawMarkers(q);
            r && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(l2.x1, l2.y1, l2.width, l2.height), z.restore());
            b.restore();
            return { source: c, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderStackedArea100 = function(a) {
          function e() {
            for (0 < u3.lineThickness && b.stroke(); 0 < k.length; ) {
              var a2 = k.pop();
              b.lineTo(a2.x, a2.y);
              r && v.lineTo(a2.x, a2.y);
            }
            b.closePath();
            b.globalAlpha = u3.fillOpacity;
            b.fill();
            b.globalAlpha = 1;
            b.beginPath();
            r && (v.closePath(), v.fill(), v.beginPath());
            k = [];
          }
          var c = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = null, f = null, q = this.plotArea, l2 = [], g2 = [], k = [], m = [], n = [], p = 0, h, y, A, z, s, x = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), v = this._eventManager.ghostCtx;
            b.save();
            r && v.save();
            b.beginPath();
            b.rect(q.x1, q.y1, q.width, q.height);
            b.clip();
            r && (v.beginPath(), v.rect(q.x1, q.y1, q.width, q.height), v.clip());
            for (var d = [], t2 = 0; t2 < a.dataSeriesIndexes.length; t2++) {
              var D = a.dataSeriesIndexes[t2], u3 = this.data[D], B2 = u3.dataPoints;
              u3.dataPointIndexes = [];
              for (p = 0; p < B2.length; p++) D = B2[p].x.getTime ? B2[p].x.getTime() : B2[p].x, u3.dataPointIndexes[D] = p, d[D] || (m.push(D), d[D] = true);
              m.sort(Qa);
            }
            for (t2 = 0; t2 < a.dataSeriesIndexes.length; t2++) {
              D = a.dataSeriesIndexes[t2];
              u3 = this.data[D];
              B2 = u3.dataPoints;
              z = true;
              d = u3.id;
              this._eventManager.objectMap[d] = { objectType: "dataSeries", dataSeriesIndex: D };
              d = T(d);
              v.fillStyle = d;
              k = [];
              if (0 < m.length) {
                var d = u3._colorSet[p % u3._colorSet.length], C3 = u3.lineColor = u3.options.lineColor || d, L = C3;
                b.fillStyle = d;
                b.strokeStyle = C3;
                b.lineWidth = u3.lineThickness;
                s = "solid";
                if (b.setLineDash) {
                  var N = K(u3.nullDataLineDashType, u3.lineThickness);
                  s = u3.lineDashType;
                  var Z = K(s, u3.lineThickness);
                  b.setLineDash(Z);
                }
                for (var $ = true, p = 0; p < m.length; p++) {
                  var f = m[p], ca = null, ca = 0 <= u3.dataPointIndexes[f] ? B2[u3.dataPointIndexes[f]] : { x: f, y: null };
                  if (!(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax && (!u3.connectNullData || !$))) if ("number" !== typeof ca.y) u3.connectNullData || ($ || z) || e(), $ = true;
                  else {
                    var ma;
                    ma = 0 !== a.dataPointYSums[f] ? 100 * (ca.y / a.dataPointYSums[f]) : 0;
                    h = a.axisX.convertValueToPixel(f);
                    var E = g2[f] ? g2[f] : 0;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                      n[f] = ma + (n[f] ? n[f] : 0);
                      if (0 >= n[f] && a.axisY.logarithmic) continue;
                      y = a.axisY.convertValueToPixel(n[f]);
                    } else y = a.axisY.convertValueToPixel(ma), y -= E;
                    k.push({ x: h, y: x - E });
                    g2[f] = x - y;
                    z || $ ? (!z && u3.connectNullData ? (b.setLineDash && (u3.options.nullDataLineDashType || s === u3.lineDashType && u3.lineDashType !== u3.nullDataLineDashType) && (z = k.pop(), s = k[k.length - 1], e(), b.moveTo(A.x, A.y), k.push(s), k.push(z), s = u3.nullDataLineDashType, b.setLineDash(N)), b.lineTo(h, y), r && v.lineTo(h, y)) : (b.beginPath(), b.moveTo(h, y), r && (v.beginPath(), v.moveTo(h, y))), $ = z = false) : (b.lineTo(h, y), r && v.lineTo(h, y), 0 == p % 250 && (e(), b.moveTo(h, y), r && v.moveTo(h, y), k.push({ x: h, y: x - E })));
                    A = { x: h, y };
                    p < B2.length - 1 && (L !== (B2[p].lineColor || C3) || s !== (B2[p].lineDashType || u3.lineDashType)) && (e(), b.beginPath(), b.moveTo(h, y), k.push({ x: h, y: x - E }), L = B2[p].lineColor || C3, b.strokeStyle = L, b.setLineDash && (B2[p].lineDashType ? (s = B2[p].lineDashType, b.setLineDash(K(s, u3.lineThickness))) : (s = u3.lineDashType, b.setLineDash(Z))));
                    if (0 <= u3.dataPointIndexes[f]) {
                      var G = u3.dataPointIds[u3.dataPointIndexes[f]];
                      this._eventManager.objectMap[G] = { id: G, objectType: "dataPoint", dataSeriesIndex: D, dataPointIndex: u3.dataPointIndexes[f], x1: h, y1: y };
                    }
                    0 <= u3.dataPointIndexes[f] && 0 !== ca.markerSize && (0 < ca.markerSize || 0 < u3.markerSize) && (E = u3.getMarkerProperties(u3.dataPointIndexes[f], h, y, b), l2.push(E), f = T(G), r && l2.push({ x: h, y, ctx: v, type: E.type, size: E.size, color: f, borderColor: f, borderThickness: E.borderThickness }));
                    (ca.indexLabel || u3.indexLabel || ca.indexLabelFormatter || u3.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea100", dataPoint: ca, dataSeries: u3, point: { x: h, y }, direction: 0 > ca.y === a.axisY.reversed ? 1 : -1, color: d });
                  }
                }
                e();
                b.moveTo(h, y);
                r && v.moveTo(
                  h,
                  y
                );
              }
              delete u3.dataPointIndexes;
            }
            X.drawMarkers(l2);
            r && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(q.x1, q.y1, q.width, q.height), v.restore());
            b.restore();
            return {
              source: c,
              dest: this.plotArea.ctx,
              animationCallback: O.xClipAnimation,
              easingFunction: O.easing.linear,
              animationBase: 0
            };
          }
        };
        t.prototype.renderBubble = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this.plotArea, d = 0, f, q;
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(b.x1, b.y1, b.width, b.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());
            for (var l2 = -Infinity, g2 = Infinity, k = 0; k < a.dataSeriesIndexes.length; k++) for (var m = a.dataSeriesIndexes[k], n = this.data[m], p = n.dataPoints, h = 0, d = 0; d < p.length; d++) f = p[d].getTime ? f = p[d].x.getTime() : f = p[d].x, f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax || "undefined" === typeof p[d].z || (h = p[d].z, h > l2 && (l2 = h), h < g2 && (g2 = h));
            for (var y = 25 * Math.PI, A = Math.max(Math.pow(0.25 * Math.min(b.height, b.width) / 2, 2) * Math.PI, y), k = 0; k < a.dataSeriesIndexes.length; k++) if (m = a.dataSeriesIndexes[k], n = this.data[m], p = n.dataPoints, 0 < p.length) {
              for (c.strokeStyle = "#4572A7 ", d = 0; d < p.length; d++) if (f = p[d].getTime ? f = p[d].x.getTime() : f = p[d].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && "number" === typeof p[d].y) {
                f = a.axisX.convertValueToPixel(f);
                q = a.axisY.convertValueToPixel(p[d].y);
                var h = p[d].z, z = 2 * Math.max(Math.sqrt((l2 === g2 ? A / 2 : y + (A - y) / (l2 - g2) * (h - g2)) / Math.PI) << 0, 1), h = n.getMarkerProperties(d, c);
                h.size = z;
                c.globalAlpha = n.fillOpacity;
                X.drawMarker(f, q, c, h.type, h.size, h.color, h.borderColor, h.borderThickness);
                c.globalAlpha = 1;
                var s = n.dataPointIds[d];
                this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: d, x1: f, y1: q, size: z };
                z = T(s);
                r && X.drawMarker(f, q, this._eventManager.ghostCtx, h.type, h.size, z, z, h.borderThickness);
                (p[d].indexLabel || n.indexLabel || p[d].indexLabelFormatter || n.indexLabelFormatter) && this._indexLabels.push({ chartType: "bubble", dataPoint: p[d], dataSeries: n, point: { x: f, y: q }, direction: 1, bounds: { x1: f - h.size / 2, y1: q - h.size / 2, x2: f + h.size / 2, y2: q + h.size / 2 }, color: null });
              }
            }
            r && (e.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return {
              source: e,
              dest: this.plotArea.ctx,
              animationCallback: O.fadeInAnimation,
              easingFunction: O.easing.easeInQuad,
              animationBase: 0
            };
          }
        };
        t.prototype.renderScatter = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this.plotArea, d = 0, f, q;
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(b.x1, b.y1, b.width, b.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());
            for (var l2 = 0; l2 < a.dataSeriesIndexes.length; l2++) {
              var g2 = a.dataSeriesIndexes[l2], k = this.data[g2], m = k.dataPoints;
              if (0 < m.length) {
                c.strokeStyle = "#4572A7 ";
                Math.pow(0.3 * Math.min(b.height, b.width) / 2, 2);
                for (var n = 0, p = 0, d = 0; d < m.length; d++) if (f = m[d].getTime ? f = m[d].x.getTime() : f = m[d].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && "number" === typeof m[d].y) {
                  f = a.axisX.convertValueToPixel(f);
                  q = a.axisY.convertValueToPixel(m[d].y);
                  var h = k.getMarkerProperties(d, f, q, c);
                  c.globalAlpha = k.fillOpacity;
                  X.drawMarker(h.x, h.y, h.ctx, h.type, h.size, h.color, h.borderColor, h.borderThickness);
                  c.globalAlpha = 1;
                  Math.sqrt((n - f) * (n - f) + (p - q) * (p - q)) < Math.min(h.size, 5) && m.length > Math.min(this.plotArea.width, this.plotArea.height) || (n = k.dataPointIds[d], this._eventManager.objectMap[n] = { id: n, objectType: "dataPoint", dataSeriesIndex: g2, dataPointIndex: d, x1: f, y1: q }, n = T(n), r && X.drawMarker(h.x, h.y, this._eventManager.ghostCtx, h.type, h.size, n, n, h.borderThickness), (m[d].indexLabel || k.indexLabel || m[d].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
                    chartType: "scatter",
                    dataPoint: m[d],
                    dataSeries: k,
                    point: { x: f, y: q },
                    direction: 1,
                    bounds: { x1: f - h.size / 2, y1: q - h.size / 2, x2: f + h.size / 2, y2: q + h.size / 2 },
                    color: null
                  }), n = f, p = q);
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(
              b.x1,
              b.y1,
              b.width,
              b.height
            ), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0 };
          }
        };
        t.prototype.renderCandlestick = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e, b = this._eventManager.ghostCtx;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = null, f = null, q = this.plotArea, w = 0, g2, k, m, n, p, h, d = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, y = a.axisX.dataInfo.minDiff;
            isFinite(y) || (y = 0.3 * Math.abs(a.axisX.range));
            y = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * q.width * (a.axisX.logarithmic ? Math.log(y) / Math.log(a.axisX.range) : Math.abs(y) / Math.abs(a.axisX.range)) << 0;
            this.dataPointMaxWidth && d > f && (d = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && f < d) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, d));
            y < d && (y = d);
            y > f && (y = f);
            c.save();
            r && b.save();
            c.beginPath();
            c.rect(q.x1, q.y1, q.width, q.height);
            c.clip();
            r && (b.beginPath(), b.rect(q.x1, q.y1, q.width, q.height), b.clip());
            for (var A = 0; A < a.dataSeriesIndexes.length; A++) {
              var z = a.dataSeriesIndexes[A], s = this.data[z], x = s.dataPoints;
              if (0 < x.length) {
                for (var v = 5 < y && s.bevelEnabled ? true : false, w = 0; w < x.length; w++) if (x[w].getTime ? h = x[w].x.getTime() : h = x[w].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && !l(x[w].y) && x[w].y.length && "number" === typeof x[w].y[0] && "number" === typeof x[w].y[1] && "number" === typeof x[w].y[2] && "number" === typeof x[w].y[3]) {
                  g2 = a.axisX.convertValueToPixel(h);
                  k = a.axisY.convertValueToPixel(x[w].y[0]);
                  m = a.axisY.convertValueToPixel(x[w].y[1]);
                  n = a.axisY.convertValueToPixel(x[w].y[2]);
                  p = a.axisY.convertValueToPixel(x[w].y[3]);
                  var t2 = g2 - y / 2 << 0, u3 = t2 + y << 0, f = s.options.fallingColor ? s.fallingColor : s._colorSet[0], d = x[w].color ? x[w].color : s._colorSet[0], B2 = Math.round(Math.max(
                    1,
                    0.15 * y
                  )), C3 = 0 === B2 % 2 ? 0 : 0.5, E = s.dataPointIds[w];
                  this._eventManager.objectMap[E] = { id: E, objectType: "dataPoint", dataSeriesIndex: z, dataPointIndex: w, x1: t2, y1: k, x2: u3, y2: m, x3: g2, y3: n, x4: g2, y4: p, borderThickness: B2, color: d };
                  c.strokeStyle = d;
                  c.beginPath();
                  c.lineWidth = B2;
                  b.lineWidth = Math.max(B2, 4);
                  "candlestick" === s.type ? (c.moveTo(g2 - C3, m), c.lineTo(g2 - C3, Math.min(k, p)), c.stroke(), c.moveTo(g2 - C3, Math.max(k, p)), c.lineTo(g2 - C3, n), c.stroke(), Y(c, t2, Math.min(k, p), u3, Math.max(k, p), x[w].y[0] <= x[w].y[3] ? s.risingColor : f, B2, d, v, v, false, false, s.fillOpacity), r && (d = T(E), b.strokeStyle = d, b.moveTo(g2 - C3, m), b.lineTo(g2 - C3, Math.min(k, p)), b.stroke(), b.moveTo(g2 - C3, Math.max(k, p)), b.lineTo(g2 - C3, n), b.stroke(), Y(b, t2, Math.min(k, p), u3, Math.max(k, p), d, 0, null, false, false, false, false))) : "ohlc" === s.type && (c.moveTo(g2 - C3, m), c.lineTo(g2 - C3, n), c.stroke(), c.beginPath(), c.moveTo(g2, k), c.lineTo(t2, k), c.stroke(), c.beginPath(), c.moveTo(g2, p), c.lineTo(u3, p), c.stroke(), r && (d = T(E), b.strokeStyle = d, b.moveTo(g2 - C3, m), b.lineTo(g2 - C3, n), b.stroke(), b.beginPath(), b.moveTo(g2, k), b.lineTo(t2, k), b.stroke(), b.beginPath(), b.moveTo(g2, p), b.lineTo(u3, p), b.stroke()));
                  (x[w].indexLabel || s.indexLabel || x[w].indexLabelFormatter || s.indexLabelFormatter) && this._indexLabels.push({ chartType: s.type, dataPoint: x[w], dataSeries: s, point: { x: t2 + (u3 - t2) / 2, y: a.axisY.reversed ? n : m }, direction: 1, bounds: { x1: t2, y1: Math.min(m, n), x2: u3, y2: Math.max(m, n) }, color: d });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(q.x1, q.y1, q.width, q.height), b.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0 };
          }
        };
        t.prototype.renderBoxAndWhisker = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e, b = this._eventManager.ghostCtx;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = null, f = this.plotArea, q = 0, g2, J, k, m, n, p, h, d = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, q = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, y = a.axisX.dataInfo.minDiff;
            isFinite(y) || (y = 0.3 * Math.abs(a.axisX.range));
            y = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * f.width * (a.axisX.logarithmic ? Math.log(y) / Math.log(a.axisX.range) : Math.abs(y) / Math.abs(a.axisX.range)) << 0;
            this.dataPointMaxWidth && d > q && (d = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, q));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && q < d) && (q = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, d));
            y < d && (y = d);
            y > q && (y = q);
            c.save();
            r && b.save();
            c.beginPath();
            c.rect(f.x1, f.y1, f.width, f.height);
            c.clip();
            r && (b.beginPath(), b.rect(f.x1, f.y1, f.width, f.height), b.clip());
            for (var A = false, A = !!a.axisY.reversed, z = 0; z < a.dataSeriesIndexes.length; z++) {
              var s = a.dataSeriesIndexes[z], x = this.data[s], v = x.dataPoints;
              if (0 < v.length) {
                for (var t2 = 5 < y && x.bevelEnabled ? true : false, q = 0; q < v.length; q++) if (v[q].getTime ? h = v[q].x.getTime() : h = v[q].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && !l(v[q].y) && v[q].y.length && "number" === typeof v[q].y[0] && "number" === typeof v[q].y[1] && "number" === typeof v[q].y[2] && "number" === typeof v[q].y[3] && "number" === typeof v[q].y[4] && 5 === v[q].y.length) {
                  g2 = a.axisX.convertValueToPixel(h);
                  J = a.axisY.convertValueToPixel(v[q].y[0]);
                  k = a.axisY.convertValueToPixel(v[q].y[1]);
                  m = a.axisY.convertValueToPixel(v[q].y[2]);
                  n = a.axisY.convertValueToPixel(v[q].y[3]);
                  p = a.axisY.convertValueToPixel(v[q].y[4]);
                  var u3 = g2 - y / 2 << 0, B2 = g2 + y / 2 << 0, d = v[q].color ? v[q].color : x._colorSet[0], C3 = Math.round(Math.max(1, 0.15 * y)), E = 0 === C3 % 2 ? 0 : 0.5, L = v[q].whiskerColor ? v[q].whiskerColor : v[q].color ? x.whiskerColor ? x.whiskerColor : v[q].color : x.whiskerColor ? x.whiskerColor : d, N = "number" === typeof v[q].whiskerThickness ? v[q].whiskerThickness : "number" === typeof x.options.whiskerThickness ? x.whiskerThickness : C3, Z = v[q].whiskerDashType ? v[q].whiskerDashType : x.whiskerDashType, $ = l(v[q].whiskerLength) ? l(x.options.whiskerLength) ? y : x.whiskerLength : v[q].whiskerLength, $ = "number" === typeof $ ? 0 >= $ ? 0 : $ >= y ? y : $ : "string" === typeof $ ? parseInt($) * y / 100 > y ? y : parseInt($) * y / 100 : y, ca = 1 === Math.round(N) % 2 ? 0.5 : 0, ma = v[q].stemColor ? v[q].stemColor : v[q].color ? x.stemColor ? x.stemColor : v[q].color : x.stemColor ? x.stemColor : d, F3 = "number" === typeof v[q].stemThickness ? v[q].stemThickness : "number" === typeof x.options.stemThickness ? x.stemThickness : C3, G = 1 === Math.round(F3) % 2 ? 0.5 : 0, P2 = v[q].stemDashType ? v[q].stemDashType : x.stemDashType, M2 = v[q].lineColor ? v[q].lineColor : v[q].color ? x.lineColor ? x.lineColor : v[q].color : x.lineColor ? x.lineColor : d, Q3 = "number" === typeof v[q].lineThickness ? v[q].lineThickness : "number" === typeof x.options.lineThickness ? x.lineThickness : C3, U2 = v[q].lineDashType ? v[q].lineDashType : x.lineDashType, aa = 1 === Math.round(Q3) % 2 ? 0.5 : 0, V2 = x.upperBoxColor, va = x.lowerBoxColor, S = l(x.options.fillOpacity) ? 1 : x.fillOpacity, H = x.dataPointIds[q];
                  this._eventManager.objectMap[H] = {
                    id: H,
                    objectType: "dataPoint",
                    dataSeriesIndex: s,
                    dataPointIndex: q,
                    x1: u3,
                    y1: J,
                    x2: B2,
                    y2: k,
                    x3: g2,
                    y3: m,
                    x4: g2,
                    y4: n,
                    y5: p,
                    borderThickness: C3,
                    color: d,
                    stemThickness: F3,
                    stemColor: ma,
                    whiskerThickness: N,
                    whiskerLength: $,
                    whiskerColor: L,
                    lineThickness: Q3,
                    lineColor: M2
                  };
                  c.save();
                  0 < F3 && (c.beginPath(), c.strokeStyle = ma, c.lineWidth = F3, c.setLineDash && c.setLineDash(K(P2, F3)), c.moveTo(g2 - G, k), c.lineTo(g2 - G, J), c.stroke(), c.moveTo(g2 - G, n), c.lineTo(g2 - G, m), c.stroke());
                  c.restore();
                  b.lineWidth = Math.max(C3, 4);
                  c.beginPath();
                  Y(c, u3, Math.min(p, k), B2, Math.max(
                    k,
                    p
                  ), va, 0, d, A ? t2 : false, A ? false : t2, false, false, S);
                  c.beginPath();
                  Y(c, u3, Math.min(m, p), B2, Math.max(p, m), V2, 0, d, A ? false : t2, A ? t2 : false, false, false, S);
                  c.beginPath();
                  c.lineWidth = C3;
                  c.strokeStyle = d;
                  c.rect(u3 - E, Math.min(k, m) - E, B2 - u3 + 2 * E, Math.max(k, m) - Math.min(k, m) + 2 * E);
                  c.stroke();
                  c.save();
                  0 < Q3 && (c.beginPath(), c.globalAlpha = 1, c.setLineDash && c.setLineDash(K(U2, Q3)), c.strokeStyle = M2, c.lineWidth = Q3, c.moveTo(u3, p - aa), c.lineTo(B2, p - aa), c.stroke());
                  c.restore();
                  c.save();
                  0 < N && (c.beginPath(), c.setLineDash && c.setLineDash(K(Z, N)), c.strokeStyle = L, c.lineWidth = N, c.moveTo(g2 - $ / 2 << 0, n - ca), c.lineTo(g2 + $ / 2 << 0, n - ca), c.stroke(), c.moveTo(g2 - $ / 2 << 0, J + ca), c.lineTo(g2 + $ / 2 << 0, J + ca), c.stroke());
                  c.restore();
                  r && (d = T(H), b.strokeStyle = d, b.lineWidth = F3, 0 < F3 && (b.moveTo(g2 - E - G, k), b.lineTo(g2 - E - G, Math.max(J, n)), b.stroke(), b.moveTo(g2 - E - G, Math.min(J, n)), b.lineTo(g2 - E - G, m), b.stroke()), Y(b, u3, Math.max(k, m), B2, Math.min(k, m), d, 0, null, false, false, false, false), 0 < N && (b.beginPath(), b.lineWidth = N, b.moveTo(g2 + $ / 2, n - ca), b.lineTo(g2 - $ / 2, n - ca), b.stroke(), b.moveTo(g2 + $ / 2, J + ca), b.lineTo(g2 - $ / 2, J + ca), b.stroke()));
                  (v[q].indexLabel || x.indexLabel || v[q].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({ chartType: x.type, dataPoint: v[q], dataSeries: x, point: { x: u3 + (B2 - u3) / 2, y: a.axisY.reversed ? J : n }, direction: 1, bounds: { x1: u3, y1: Math.min(J, n), x2: B2, y2: Math.max(J, n) }, color: d });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(
              a.axisY.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), b.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0 };
          }
        };
        t.prototype.renderRangeColumn = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = 0, q, g2, J, f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            q = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;
            var k = a.axisX.dataInfo.minDiff;
            isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range));
            k = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > q && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, q));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && q < f) && (q = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            k < f && (k = f);
            k > q && (k = q);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (var m = 0; m < a.dataSeriesIndexes.length; m++) {
              var n = a.dataSeriesIndexes[m], p = this.data[n], h = p.dataPoints;
              if (0 < h.length) {
                for (var y = 5 < k && p.bevelEnabled ? true : false, f = 0; f < h.length; f++) if (h[f].getTime ? J = h[f].x.getTime() : J = h[f].x, !(J < a.axisX.dataInfo.viewPortMin || J > a.axisX.dataInfo.viewPortMax) && !l(h[f].y) && h[f].y.length && "number" === typeof h[f].y[0] && "number" === typeof h[f].y[1]) {
                  b = a.axisX.convertValueToPixel(J);
                  q = a.axisY.convertValueToPixel(h[f].y[0]);
                  g2 = a.axisY.convertValueToPixel(h[f].y[1]);
                  var A = a.axisX.reversed ? b + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + m) * k << 0 : b - a.plotType.totalDataSeries * k / 2 + (a.previousDataSeriesCount + m) * k << 0, z = a.axisX.reversed ? A - k << 0 : A + k << 0, b = h[f].color ? h[f].color : p._colorSet[f % p._colorSet.length];
                  if (q > g2) {
                    var s = q;
                    q = g2;
                    g2 = s;
                  }
                  s = p.dataPointIds[f];
                  this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: f, x1: A, y1: q, x2: z, y2: g2 };
                  Y(c, a.axisX.reversed ? z : A, q, a.axisX.reversed ? A : z, g2, b, 0, b, y, y, false, false, p.fillOpacity);
                  b = T(s);
                  r && Y(
                    this._eventManager.ghostCtx,
                    a.axisX.reversed ? z : A,
                    q,
                    a.axisX.reversed ? A : z,
                    g2,
                    b,
                    0,
                    null,
                    false,
                    false,
                    false,
                    false
                  );
                  if (h[f].indexLabel || p.indexLabel || h[f].indexLabelFormatter || p.indexLabelFormatter) this._indexLabels.push({ chartType: "rangeColumn", dataPoint: h[f], dataSeries: p, indexKeyword: 0, point: { x: A + (z - A) / 2, y: h[f].y[1] >= h[f].y[0] ? g2 : q }, direction: h[f].y[1] >= h[f].y[0] ? -1 : 1, bounds: { x1: A, y1: Math.min(q, g2), x2: z, y2: Math.max(q, g2) }, color: b }), this._indexLabels.push({ chartType: "rangeColumn", dataPoint: h[f], dataSeries: p, indexKeyword: 1, point: { x: A + (z - A) / 2, y: h[f].y[1] >= h[f].y[0] ? q : g2 }, direction: h[f].y[1] >= h[f].y[0] ? 1 : -1, bounds: {
                    x1: A,
                    y1: Math.min(q, g2),
                    x2: z,
                    y2: Math.max(q, g2)
                  }, color: b });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0 };
          }
        };
        t.prototype.renderError = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e, b = a.axisY._position ? "left" === a.axisY._position || "right" === a.axisY._position ? false : true : false;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = null, f = false, q = this.plotArea, g2 = 0, J, k, m, n, p, h, y, A = a.axisX.dataInfo.minDiff;
            isFinite(A) || (A = 0.3 * Math.abs(a.axisX.range));
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(q.x1, q.y1, q.width, q.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(q.x1, q.y1, q.width, q.height), this._eventManager.ghostCtx.clip());
            for (var z = 0, s = 0; s < this.data.length; s++) !this.data[s].type.match(/(bar|column)/ig) || !this.data[s].visible || this.data[s].type.match(/(stacked)/ig) && z || z++;
            for (var x = 0; x < a.dataSeriesIndexes.length; x++) {
              var v = a.dataSeriesIndexes[x], t2 = this.data[v], u3 = t2.dataPoints, B2 = l(t2._linkedSeries) ? false : t2._linkedSeries.type.match(/(bar|column)/ig) && t2._linkedSeries.visible ? true : false, F3 = 0;
              if (B2) for (d = t2._linkedSeries.id, s = 0; s < d; s++) !this.data[s].type.match(/(bar|column)/ig) || !this.data[s].visible || this.data[s].type.match(/(stacked)/ig) && F3 || (this.data[s].type.match(/(range)/ig) && (f = true), F3++);
              d = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
              g2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (B2 ? z : 1))) << 0 : 0.3 * this.width;
              f && (g2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (B2 ? z : 1))) << 0 : 0.03 * this.width);
              s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((b ? q.height : q.width) * (a.axisX.logarithmic ? Math.log(A) / Math.log(a.axisX.range) : Math.abs(A) / Math.abs(a.axisX.range)) / (B2 ? z : 1)) << 0;
              this.dataPointMaxWidth && d > g2 && (d = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g2));
              !this.dataPointMaxWidth && (this.dataPointMinWidth && g2 < d) && (g2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, d));
              s < d && (s = d);
              s > g2 && (s = g2);
              if (0 < u3.length) for (var K2 = t2._colorSet, g2 = 0; g2 < u3.length; g2++) {
                var d = t2.lineColor = t2.options.color ? t2.options.color : K2[0], L = { color: u3[g2].whiskerColor ? u3[g2].whiskerColor : u3[g2].color ? t2.whiskerColor ? t2.whiskerColor : u3[g2].color : t2.whiskerColor ? t2.whiskerColor : d, thickness: l(u3[g2].whiskerThickness) ? t2.whiskerThickness : u3[g2].whiskerThickness, dashType: u3[g2].whiskerDashType ? u3[g2].whiskerDashType : t2.whiskerDashType, length: l(u3[g2].whiskerLength) ? l(t2.options.whiskerLength) ? s : t2.options.whiskerLength : u3[g2].whiskerLength, trimLength: l(u3[g2].whiskerLength) ? l(t2.options.whiskerLength) ? 50 : 0 : 0 };
                L.length = "number" === typeof L.length ? 0 >= L.length ? 0 : L.length >= s ? s : L.length : "string" === typeof L.length ? parseInt(L.length) * s / 100 > s ? s : parseInt(L.length) * s / 100 > s : s;
                L.thickness = "number" === typeof L.thickness ? 0 > L.thickness ? 0 : Math.round(L.thickness) : 2;
                var N = { color: u3[g2].stemColor ? u3[g2].stemColor : u3[g2].color ? t2.stemColor ? t2.stemColor : u3[g2].color : t2.stemColor ? t2.stemColor : d, thickness: u3[g2].stemThickness ? u3[g2].stemThickness : t2.stemThickness, dashType: u3[g2].stemDashType ? u3[g2].stemDashType : t2.stemDashType };
                N.thickness = "number" === typeof N.thickness ? 0 > N.thickness ? 0 : Math.round(N.thickness) : 2;
                u3[g2].getTime ? y = u3[g2].x.getTime() : y = u3[g2].x;
                if (!(y < a.axisX.dataInfo.viewPortMin || y > a.axisX.dataInfo.viewPortMax) && !l(u3[g2].y) && u3[g2].y.length && "number" === typeof u3[g2].y[0] && "number" === typeof u3[g2].y[1]) {
                  var Z = a.axisX.convertValueToPixel(y);
                  b ? k = Z : J = Z;
                  Z = a.axisY.convertValueToPixel(u3[g2].y[0]);
                  b ? m = Z : p = Z;
                  Z = a.axisY.convertValueToPixel(u3[g2].y[1]);
                  b ? n = Z : h = Z;
                  b ? (p = a.axisX.reversed ? k + (B2 ? z : 1) * s / 2 - (B2 ? F3 - 1 : 0) * s << 0 : k - (B2 ? z : 1) * s / 2 + (B2 ? F3 - 1 : 0) * s << 0, h = a.axisX.reversed ? p - s << 0 : p + s << 0) : (m = a.axisX.reversed ? J + (B2 ? z : 1) * s / 2 - (B2 ? F3 - 1 : 0) * s << 0 : J - (B2 ? z : 1) * s / 2 + (B2 ? F3 - 1 : 0) * s << 0, n = a.axisX.reversed ? m - s << 0 : m + s << 0);
                  !b && p > h && (Z = p, p = h, h = Z);
                  b && m > n && (Z = m, m = n, n = Z);
                  Z = t2.dataPointIds[g2];
                  this._eventManager.objectMap[Z] = { id: Z, objectType: "dataPoint", dataSeriesIndex: v, dataPointIndex: g2, x1: Math.min(m, n), y1: Math.min(p, h), x2: Math.max(n, m), y2: Math.max(
                    h,
                    p
                  ), isXYSwapped: b, stemProperties: N, whiskerProperties: L };
                  C2(c, Math.min(m, n), Math.min(p, h), Math.max(n, m), Math.max(h, p), d, L, N, b);
                  r && C2(this._eventManager.ghostCtx, m, p, n, h, d, L, N, b);
                  if (u3[g2].indexLabel || t2.indexLabel || u3[g2].indexLabelFormatter || t2.indexLabelFormatter) this._indexLabels.push({ chartType: "error", dataPoint: u3[g2], dataSeries: t2, indexKeyword: 0, point: { x: b ? u3[g2].y[1] >= u3[g2].y[0] ? m : n : m + (n - m) / 2, y: b ? p + (h - p) / 2 : u3[g2].y[1] >= u3[g2].y[0] ? h : p }, direction: u3[g2].y[1] >= u3[g2].y[0] ? -1 : 1, bounds: { x1: b ? Math.min(m, n) : m, y1: b ? p : Math.min(
                    p,
                    h
                  ), x2: b ? Math.max(m, n) : n, y2: b ? h : Math.max(p, h) }, color: d, axisSwapped: b }), this._indexLabels.push({ chartType: "error", dataPoint: u3[g2], dataSeries: t2, indexKeyword: 1, point: { x: b ? u3[g2].y[1] >= u3[g2].y[0] ? n : m : m + (n - m) / 2, y: b ? p + (h - p) / 2 : u3[g2].y[1] >= u3[g2].y[0] ? p : h }, direction: u3[g2].y[1] >= u3[g2].y[0] ? 1 : -1, bounds: { x1: b ? Math.min(m, n) : m, y1: b ? p : Math.min(p, h), x2: b ? Math.max(m, n) : n, y2: b ? h : Math.max(p, h) }, color: d, axisSwapped: b });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(q.x1, q.y1, q.width, q.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0 };
          }
        };
        t.prototype.renderRangeBar = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, d = this.plotArea, f = 0, q, g2, J, k, f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            q = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;
            var m = a.axisX.dataInfo.minDiff;
            isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));
            m = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (d.height * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > q && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, q));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && q < f) && (q = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            m < f && (m = f);
            m > q && (m = q);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(d.x1, d.y1, d.width, d.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
              var p = a.dataSeriesIndexes[n], h = this.data[p], y = h.dataPoints;
              if (0 < y.length) {
                var A = 5 < m && h.bevelEnabled ? true : false;
                c.strokeStyle = "#4572A7 ";
                for (f = 0; f < y.length; f++) if (y[f].getTime ? k = y[f].x.getTime() : k = y[f].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !l(y[f].y) && y[f].y.length && "number" === typeof y[f].y[0] && "number" === typeof y[f].y[1]) {
                  q = a.axisY.convertValueToPixel(y[f].y[0]);
                  g2 = a.axisY.convertValueToPixel(y[f].y[1]);
                  J = a.axisX.convertValueToPixel(k);
                  J = a.axisX.reversed ? J + a.plotType.totalDataSeries * m / 2 - (a.previousDataSeriesCount + n) * m << 0 : J - a.plotType.totalDataSeries * m / 2 + (a.previousDataSeriesCount + n) * m << 0;
                  var t2 = a.axisX.reversed ? J - m << 0 : J + m << 0;
                  q > g2 && (b = q, q = g2, g2 = b);
                  b = y[f].color ? y[f].color : h._colorSet[f % h._colorSet.length];
                  Y(c, q, a.axisX.reversed ? t2 : J, g2, a.axisX.reversed ? J : t2, b, 0, null, A, false, false, false, h.fillOpacity);
                  b = h.dataPointIds[f];
                  this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: f, x1: q, y1: J, x2: g2, y2: t2 };
                  b = T(b);
                  r && Y(this._eventManager.ghostCtx, q, a.axisX.reversed ? t2 : J, g2, a.axisX.reversed ? J : t2, b, 0, null, false, false, false, false);
                  if (y[f].indexLabel || h.indexLabel || y[f].indexLabelFormatter || h.indexLabelFormatter) this._indexLabels.push({
                    chartType: "rangeBar",
                    dataPoint: y[f],
                    dataSeries: h,
                    indexKeyword: 0,
                    point: { x: y[f].y[1] >= y[f].y[0] ? q : g2, y: J + (t2 - J) / 2 },
                    direction: y[f].y[1] >= y[f].y[0] ? -1 : 1,
                    bounds: { x1: Math.min(q, g2), y1: J, x2: Math.max(q, g2), y2: t2 },
                    color: b
                  }), this._indexLabels.push({ chartType: "rangeBar", dataPoint: y[f], dataSeries: h, indexKeyword: 1, point: { x: y[f].y[1] >= y[f].y[0] ? g2 : q, y: J + (t2 - J) / 2 }, direction: y[f].y[1] >= y[f].y[0] ? 1 : -1, bounds: { x1: Math.min(q, g2), y1: J, x2: Math.max(q, g2), y2: t2 }, color: b });
                }
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0 };
          }
        };
        t.prototype.renderRangeArea = function(a) {
          function e() {
            if (x) {
              for (var a2 = null, c2 = g2.length - 1; 0 <= c2; c2--) a2 = g2[c2], b.lineTo(a2.x, a2.y2), d.lineTo(a2.x, a2.y2);
              b.closePath();
              b.globalAlpha = m.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              d.fill();
              if (0 < m.lineThickness) {
                b.beginPath();
                b.moveTo(a2.x, a2.y2);
                for (c2 = 0; c2 < g2.length; c2++) a2 = g2[c2], b.lineTo(a2.x, a2.y2);
                b.moveTo(g2[0].x, g2[0].y1);
                for (c2 = 0; c2 < g2.length; c2++) a2 = g2[c2], b.lineTo(a2.x, a2.y1);
                b.stroke();
              }
              b.beginPath();
              b.moveTo(y, A);
              d.beginPath();
              d.moveTo(y, A);
              x = { x: y, y: A };
              g2 = [];
              g2.push({ x: y, y1: A, y2: t2 });
            }
          }
          var c = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx, f = [], q = this.plotArea;
            b.save();
            r && d.save();
            b.beginPath();
            b.rect(q.x1, q.y1, q.width, q.height);
            b.clip();
            r && (d.beginPath(), d.rect(q.x1, q.y1, q.width, q.height), d.clip());
            for (var l2 = 0; l2 < a.dataSeriesIndexes.length; l2++) {
              var g2 = [], k = a.dataSeriesIndexes[l2], m = this.data[k], n = m.dataPoints, f = m.id;
              this._eventManager.objectMap[f] = { objectType: "dataSeries", dataSeriesIndex: k };
              f = T(f);
              d.fillStyle = f;
              var f = [], p = true, h = 0, y, A, t2, s, x = null;
              if (0 < n.length) {
                var v = m._colorSet[h % m._colorSet.length], u3 = m.lineColor = m.options.lineColor || v, B2 = u3;
                b.fillStyle = v;
                b.strokeStyle = u3;
                b.lineWidth = m.lineThickness;
                var C3 = "solid";
                if (b.setLineDash) {
                  var E = K(m.nullDataLineDashType, m.lineThickness), C3 = m.lineDashType, F3 = K(C3, m.lineThickness);
                  b.setLineDash(F3);
                }
                for (var L = true; h < n.length; h++) if (s = n[h].x.getTime ? n[h].x.getTime() : n[h].x, !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !L))) if (null !== n[h].y && n[h].y.length && "number" === typeof n[h].y[0] && "number" === typeof n[h].y[1]) {
                  y = a.axisX.convertValueToPixel(s);
                  A = a.axisY.convertValueToPixel(n[h].y[0]);
                  t2 = a.axisY.convertValueToPixel(n[h].y[1]);
                  p || L ? (m.connectNullData && !p ? (b.setLineDash && (m.options.nullDataLineDashType || C3 === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (g2[g2.length - 1].newLineDashArray = F3, C3 = m.nullDataLineDashType, b.setLineDash(E)), b.lineTo(y, A), r && d.lineTo(y, A), g2.push({ x: y, y1: A, y2: t2 })) : (b.beginPath(), b.moveTo(y, A), x = { x: y, y: A }, g2 = [], g2.push({ x: y, y1: A, y2: t2 }), r && (d.beginPath(), d.moveTo(y, A))), L = p = false) : (b.lineTo(y, A), g2.push({ x: y, y1: A, y2: t2 }), r && d.lineTo(y, A), 0 == h % 250 && e());
                  s = m.dataPointIds[h];
                  this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: k, dataPointIndex: h, x1: y, y1: A, y2: t2 };
                  h < n.length - 1 && (B2 !== (n[h].lineColor || u3) || C3 !== (n[h].lineDashType || m.lineDashType)) && (e(), B2 = n[h].lineColor || u3, g2[g2.length - 1].newStrokeStyle = B2, b.strokeStyle = B2, b.setLineDash && (n[h].lineDashType ? (C3 = n[h].lineDashType, g2[g2.length - 1].newLineDashArray = K(C3, m.lineThickness), b.setLineDash(g2[g2.length - 1].newLineDashArray)) : (C3 = m.lineDashType, g2[g2.length - 1].newLineDashArray = F3, b.setLineDash(F3))));
                  if (0 !== n[h].markerSize && (0 < n[h].markerSize || 0 < m.markerSize)) {
                    var N = m.getMarkerProperties(h, y, t2, b);
                    f.push(N);
                    var Z = T(s);
                    r && f.push({ x: y, y: t2, ctx: d, type: N.type, size: N.size, color: Z, borderColor: Z, borderThickness: N.borderThickness });
                    N = m.getMarkerProperties(h, y, A, b);
                    f.push(N);
                    Z = T(s);
                    r && f.push({ x: y, y: A, ctx: d, type: N.type, size: N.size, color: Z, borderColor: Z, borderThickness: N.borderThickness });
                  }
                  if (n[h].indexLabel || m.indexLabel || n[h].indexLabelFormatter || m.indexLabelFormatter) this._indexLabels.push({
                    chartType: "rangeArea",
                    dataPoint: n[h],
                    dataSeries: m,
                    indexKeyword: 0,
                    point: { x: y, y: A },
                    direction: n[h].y[0] > n[h].y[1] === a.axisY.reversed ? -1 : 1,
                    color: v
                  }), this._indexLabels.push({ chartType: "rangeArea", dataPoint: n[h], dataSeries: m, indexKeyword: 1, point: { x: y, y: t2 }, direction: n[h].y[0] > n[h].y[1] === a.axisY.reversed ? 1 : -1, color: v });
                } else L || p || e(), L = true;
                e();
                X.drawMarkers(f);
              }
            }
            r && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(q.x1, q.y1, q.width, q.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderRangeSplineArea = function(a) {
          function e(a2, c2) {
            var e2 = u2(A, 2);
            if (0 < e2.length) {
              if (0 < k.lineThickness) {
                b.strokeStyle = c2;
                b.setLineDash && b.setLineDash(a2);
                b.beginPath();
                b.moveTo(e2[0].x, e2[0].y);
                for (var h2 = 0; h2 < e2.length - 3; h2 += 3) {
                  if (e2[h2].newStrokeStyle || e2[h2].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(e2[h2].x, e2[h2].y), e2[h2].newStrokeStyle && (b.strokeStyle = e2[h2].newStrokeStyle), e2[h2].newLineDashArray && b.setLineDash(e2[h2].newLineDashArray);
                  b.bezierCurveTo(e2[h2 + 1].x, e2[h2 + 1].y, e2[h2 + 2].x, e2[h2 + 2].y, e2[h2 + 3].x, e2[h2 + 3].y);
                }
              }
              b.beginPath();
              b.moveTo(e2[0].x, e2[0].y);
              r && (d.beginPath(), d.moveTo(e2[0].x, e2[0].y));
              for (h2 = 0; h2 < e2.length - 3; h2 += 3) b.bezierCurveTo(e2[h2 + 1].x, e2[h2 + 1].y, e2[h2 + 2].x, e2[h2 + 2].y, e2[h2 + 3].x, e2[h2 + 3].y), r && d.bezierCurveTo(e2[h2 + 1].x, e2[h2 + 1].y, e2[h2 + 2].x, e2[h2 + 2].y, e2[h2 + 3].x, e2[h2 + 3].y);
              e2 = u2(t2, 2);
              b.lineTo(t2[t2.length - 1].x, t2[t2.length - 1].y);
              for (h2 = e2.length - 1; 2 < h2; h2 -= 3) b.bezierCurveTo(e2[h2 - 1].x, e2[h2 - 1].y, e2[h2 - 2].x, e2[h2 - 2].y, e2[h2 - 3].x, e2[h2 - 3].y), r && d.bezierCurveTo(e2[h2 - 1].x, e2[h2 - 1].y, e2[h2 - 2].x, e2[h2 - 2].y, e2[h2 - 3].x, e2[h2 - 3].y);
              b.closePath();
              b.globalAlpha = k.fillOpacity;
              b.fill();
              r && (d.closePath(), d.fill());
              b.globalAlpha = 1;
              if (0 < k.lineThickness) {
                b.strokeStyle = c2;
                b.setLineDash && b.setLineDash(a2);
                b.beginPath();
                b.moveTo(e2[0].x, e2[0].y);
                for (var f2 = h2 = 0; h2 < e2.length - 3; h2 += 3, f2++) {
                  if (A[f2].newStrokeStyle || A[f2].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(e2[h2].x, e2[h2].y), A[f2].newStrokeStyle && (b.strokeStyle = A[f2].newStrokeStyle), A[f2].newLineDashArray && b.setLineDash(A[f2].newLineDashArray);
                  b.bezierCurveTo(e2[h2 + 1].x, e2[h2 + 1].y, e2[h2 + 2].x, e2[h2 + 2].y, e2[h2 + 3].x, e2[h2 + 3].y);
                }
                e2 = u2(A, 2);
                b.moveTo(e2[0].x, e2[0].y);
                for (f2 = h2 = 0; h2 < e2.length - 3; h2 += 3, f2++) {
                  if (A[f2].newStrokeStyle || A[f2].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(e2[h2].x, e2[h2].y), A[f2].newStrokeStyle && (b.strokeStyle = A[f2].newStrokeStyle), A[f2].newLineDashArray && b.setLineDash(A[f2].newLineDashArray);
                  b.bezierCurveTo(e2[h2 + 1].x, e2[h2 + 1].y, e2[h2 + 2].x, e2[h2 + 2].y, e2[h2 + 3].x, e2[h2 + 3].y);
                }
                b.stroke();
              }
              b.beginPath();
            }
          }
          var c = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx, f = [], q = this.plotArea;
            b.save();
            r && d.save();
            b.beginPath();
            b.rect(q.x1, q.y1, q.width, q.height);
            b.clip();
            r && (d.beginPath(), d.rect(q.x1, q.y1, q.width, q.height), d.clip());
            for (var l2 = 0; l2 < a.dataSeriesIndexes.length; l2++) {
              var g2 = a.dataSeriesIndexes[l2], k = this.data[g2], m = k.dataPoints, f = k.id;
              this._eventManager.objectMap[f] = { objectType: "dataSeries", dataSeriesIndex: g2 };
              f = T(f);
              d.fillStyle = f;
              var f = [], n = 0, p, h, y, A = [], t2 = [];
              if (0 < m.length) {
                var s = k._colorSet[n % k._colorSet.length], x = k.lineColor = k.options.lineColor || s, v = x;
                b.fillStyle = s;
                b.lineWidth = k.lineThickness;
                var B2 = "solid", D;
                if (b.setLineDash) {
                  var C3 = K(k.nullDataLineDashType, k.lineThickness), B2 = k.lineDashType;
                  D = K(B2, k.lineThickness);
                }
                for (h = false; n < m.length; n++) if (p = m[n].x.getTime ? m[n].x.getTime() : m[n].x, !(p < a.axisX.dataInfo.viewPortMin || p > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !h))) if (null !== m[n].y && m[n].y.length && "number" === typeof m[n].y[0] && "number" === typeof m[n].y[1]) {
                  p = a.axisX.convertValueToPixel(p);
                  h = a.axisY.convertValueToPixel(m[n].y[0]);
                  y = a.axisY.convertValueToPixel(m[n].y[1]);
                  var E = k.dataPointIds[n];
                  this._eventManager.objectMap[E] = {
                    id: E,
                    objectType: "dataPoint",
                    dataSeriesIndex: g2,
                    dataPointIndex: n,
                    x1: p,
                    y1: h,
                    y2: y
                  };
                  A[A.length] = { x: p, y: h };
                  t2[t2.length] = { x: p, y };
                  n < m.length - 1 && (v !== (m[n].lineColor || x) || B2 !== (m[n].lineDashType || k.lineDashType)) && (v = m[n].lineColor || x, A[A.length - 1].newStrokeStyle = v, b.setLineDash && (m[n].lineDashType ? (B2 = m[n].lineDashType, A[A.length - 1].newLineDashArray = K(B2, k.lineThickness)) : (B2 = k.lineDashType, A[A.length - 1].newLineDashArray = D)));
                  if (0 !== m[n].markerSize && (0 < m[n].markerSize || 0 < k.markerSize)) {
                    var F3 = k.getMarkerProperties(n, p, h, b);
                    f.push(F3);
                    var L = T(E);
                    r && f.push({
                      x: p,
                      y: h,
                      ctx: d,
                      type: F3.type,
                      size: F3.size,
                      color: L,
                      borderColor: L,
                      borderThickness: F3.borderThickness
                    });
                    F3 = k.getMarkerProperties(n, p, y, b);
                    f.push(F3);
                    L = T(E);
                    r && f.push({ x: p, y, ctx: d, type: F3.type, size: F3.size, color: L, borderColor: L, borderThickness: F3.borderThickness });
                  }
                  if (m[n].indexLabel || k.indexLabel || m[n].indexLabelFormatter || k.indexLabelFormatter) this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: m[n], dataSeries: k, indexKeyword: 0, point: { x: p, y: h }, direction: m[n].y[0] <= m[n].y[1] ? -1 : 1, color: s }), this._indexLabels.push({
                    chartType: "rangeSplineArea",
                    dataPoint: m[n],
                    dataSeries: k,
                    indexKeyword: 1,
                    point: { x: p, y },
                    direction: m[n].y[0] <= m[n].y[1] ? 1 : -1,
                    color: s
                  });
                  h = false;
                } else 0 < n && !h && (k.connectNullData ? b.setLineDash && (0 < A.length && (k.options.nullDataLineDashType || !m[n - 1].lineDashType)) && (A[A.length - 1].newLineDashArray = C3, B2 = k.nullDataLineDashType) : (e(D, x), A = [], t2 = [])), h = true;
                e(D, x);
                X.drawMarkers(f);
              }
            }
            r && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(q.x1, q.y1, q.width, q.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c, dest: this.plotArea.ctx, animationCallback: O.xClipAnimation, easingFunction: O.easing.linear, animationBase: 0 };
          }
        };
        t.prototype.renderWaterfall = function(a) {
          var e = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx, d = null, f = this.plotArea, q = 0, l2, g2, k, m, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), q = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            g2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;
            var p = a.axisX.dataInfo.minDiff;
            isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));
            p = this.options.dataPointWidth ? this.dataPointWidth : 0.6 * (f.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && q > g2 && (q = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g2));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g2 < q) && (g2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, q));
            p < q && (p = q);
            p > g2 && (p = g2);
            c.save();
            r && this._eventManager.ghostCtx.save();
            c.beginPath();
            c.rect(f.x1, f.y1, f.width, f.height);
            c.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());
            for (var h = 0; h < a.dataSeriesIndexes.length; h++) {
              var y = a.dataSeriesIndexes[h], t2 = this.data[y], z = t2.dataPoints, d = t2._colorSet[0];
              t2.risingColor = t2.options.risingColor ? t2.options.risingColor : d;
              t2.fallingColor = t2.options.fallingColor ? t2.options.fallingColor : "#e40a0a";
              var s = "number" === typeof t2.options.lineThickness ? Math.round(t2.lineThickness) : 1, x = 1 === Math.round(s) % 2 ? -0.5 : 0;
              if (0 < z.length) for (var v = 5 < p && t2.bevelEnabled ? true : false, u3 = false, B2 = null, C3 = null, q = 0; q < z.length; q++) if (z[q].getTime ? m = z[q].x.getTime() : m = z[q].x, "number" !== typeof z[q].y) {
                if (0 < q && !u3 && t2.connectNullData) var E = t2.options.nullDataLineDashType || !z[q - 1].lineDashType ? t2.nullDataLineDashType : z[q - 1].lineDashType;
                u3 = true;
              } else {
                l2 = a.axisX.convertValueToPixel(m);
                g2 = 0 === t2.dataPointEOs[q].cumulativeSum ? n : a.axisY.convertValueToPixel(t2.dataPointEOs[q].cumulativeSum);
                k = 0 === t2.dataPointEOs[q].cumulativeSumYStartValue ? n : a.axisY.convertValueToPixel(t2.dataPointEOs[q].cumulativeSumYStartValue);
                l2 = a.axisX.reversed ? l2 + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + h) * p << 0 : l2 - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + h) * p << 0;
                var F3 = a.axisX.reversed ? l2 - p << 0 : l2 + p << 0;
                g2 > k && (d = g2, g2 = k, k = d);
                a.axisY.reversed && (d = g2, g2 = k, k = d);
                d = t2.dataPointIds[q];
                this._eventManager.objectMap[d] = { id: d, objectType: "dataPoint", dataSeriesIndex: y, dataPointIndex: q, x1: l2, y1: g2, x2: F3, y2: k };
                var L = z[q].color ? z[q].color : 0 < z[q].y ? t2.risingColor : t2.fallingColor;
                Y(c, a.axisX.reversed ? F3 : l2, a.axisY.reversed ? k : g2, a.axisX.reversed ? l2 : F3, a.axisY.reversed ? g2 : k, L, 0, L, v, v, false, false, t2.fillOpacity);
                d = T(d);
                r && Y(this._eventManager.ghostCtx, a.axisX.reversed ? F3 : l2, g2, a.axisX.reversed ? l2 : F3, k, d, 0, null, false, false, false, false);
                var N, L = l2;
                N = "undefined" !== typeof z[q].isIntermediateSum && true === z[q].isIntermediateSum || "undefined" !== typeof z[q].isCumulativeSum && true === z[q].isCumulativeSum ? 0 < z[q].y ? g2 : k : 0 < z[q].y ? k : g2;
                0 < q && B2 && (!u3 || t2.connectNullData) && (u3 && c.setLineDash && c.setLineDash(K(E, s)), c.beginPath(), c.moveTo(B2, C3 - x), c.lineTo(L, N - x), 0 < s && c.stroke(), r && (b.beginPath(), b.moveTo(B2, C3 - x), b.lineTo(L, N - x), 0 < s && b.stroke()));
                u3 = false;
                B2 = F3;
                C3 = 0 < z[q].y ? g2 : k;
                L = z[q].lineDashType ? z[q].lineDashType : t2.options.lineDashType ? t2.options.lineDashType : "shortDash";
                c.strokeStyle = z[q].lineColor ? z[q].lineColor : t2.options.lineColor ? t2.options.lineColor : "#9e9e9e";
                c.lineWidth = s;
                c.setLineDash && (L = K(L, s), c.setLineDash(L));
                (z[q].indexLabel || t2.indexLabel || z[q].indexLabelFormatter || t2.indexLabelFormatter) && this._indexLabels.push({
                  chartType: "waterfall",
                  dataPoint: z[q],
                  dataSeries: t2,
                  point: { x: l2 + (F3 - l2) / 2, y: 0 <= z[q].y ? g2 : k },
                  direction: 0 > z[q].y === a.axisY.reversed ? 1 : -1,
                  bounds: { x1: l2, y1: Math.min(g2, k), x2: F3, y2: Math.max(g2, k) },
                  color: d
                });
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: O.fadeInAnimation, easingFunction: O.easing.easeInQuad, animationBase: 0 };
          }
        };
        var pa2 = function(a, e, c, b, d, f, q, l2, g2) {
          if (!(0 > c)) {
            "undefined" === typeof l2 && (l2 = 1);
            if (!r) {
              var k = Number((q % (2 * Math.PI)).toFixed(8));
              Number((f % (2 * Math.PI)).toFixed(8)) === k && (q -= 1e-4);
            }
            a.save();
            a.globalAlpha = l2;
            "pie" === d ? (a.beginPath(), a.moveTo(e.x, e.y), a.arc(
              e.x,
              e.y,
              c,
              f,
              q,
              false
            ), a.fillStyle = b, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === d && (a.beginPath(), a.arc(e.x, e.y, c, f, q, false), 0 <= g2 && a.arc(e.x, e.y, g2 * c, q, f, true), a.closePath(), a.fillStyle = b, a.strokeStyle = "white", a.lineWidth = 2, a.fill());
            a.globalAlpha = 1;
            a.restore();
          }
        };
        t.prototype.renderPie = function(a) {
          function e() {
            if (k && m) {
              var a2 = 0, b2 = 0, c2 = 0, e2 = 0;
              l(k.options.indexLabelMaxWidth) && (k.indexLabelMaxWidth = 0.33 * p.width);
              for (var d2 = 0; d2 < m.length; d2++) {
                var f2 = m[d2], q2 = k.dataPointIds[d2];
                h[d2].id = q2;
                h[d2].objectType = "dataPoint";
                h[d2].dataPointIndex = d2;
                h[d2].dataSeriesIndex = 0;
                var g3 = h[d2], n2 = { percent: null, total: null }, w = null, n2 = t2.getPercentAndTotal(k, f2);
                if (k.indexLabelFormatter || f2.indexLabelFormatter) w = { chart: t2.options, dataSeries: k, dataPoint: f2, total: n2.total, percent: n2.percent };
                n2 = f2.indexLabelFormatter ? f2.indexLabelFormatter(w) : f2.indexLabel ? t2.replaceKeywordsWithValue(f2.indexLabel, f2, k, d2) : k.indexLabelFormatter ? k.indexLabelFormatter(w) : k.indexLabel ? t2.replaceKeywordsWithValue(k.indexLabel, f2, k, d2) : f2.label ? f2.label : "";
                t2._eventManager.objectMap[q2] = g3;
                g3.center = { x: v.x, y: v.y };
                g3.y = f2.y;
                g3.radius = C3;
                g3.percentInnerRadius = F3;
                g3.indexLabelText = n2;
                g3.indexLabelPlacement = k.indexLabelPlacement;
                g3.indexLabelLineColor = f2.indexLabelLineColor ? f2.indexLabelLineColor : k.options.indexLabelLineColor ? k.options.indexLabelLineColor : f2.color ? f2.color : k._colorSet[d2 % k._colorSet.length];
                g3.indexLabelLineThickness = l(f2.indexLabelLineThickness) ? k.indexLabelLineThickness : f2.indexLabelLineThickness;
                g3.indexLabelLineDashType = f2.indexLabelLineDashType ? f2.indexLabelLineDashType : k.indexLabelLineDashType;
                g3.indexLabelFontColor = f2.indexLabelFontColor ? f2.indexLabelFontColor : k.indexLabelFontColor;
                g3.indexLabelFontStyle = f2.indexLabelFontStyle ? f2.indexLabelFontStyle : k.indexLabelFontStyle;
                g3.indexLabelFontWeight = f2.indexLabelFontWeight ? f2.indexLabelFontWeight : k.indexLabelFontWeight;
                g3.indexLabelFontSize = l(f2.indexLabelFontSize) ? k.indexLabelFontSize : f2.indexLabelFontSize;
                g3.indexLabelFontFamily = f2.indexLabelFontFamily ? f2.indexLabelFontFamily : k.indexLabelFontFamily;
                g3.indexLabelBackgroundColor = f2.indexLabelBackgroundColor ? f2.indexLabelBackgroundColor : k.options.indexLabelBackgroundColor ? k.options.indexLabelBackgroundColor : k.indexLabelBackgroundColor;
                g3.indexLabelBorderColor = f2.indexLabelBorderColor ? f2.indexLabelBorderColor : k.options.indexLabelBorderColor ? k.options.indexLabelBorderColor : k.indexLabelBorderColor;
                g3.indexLabelBorderThickness = f2.indexLabelBorderThickness ? f2.indexLabelBorderThickness : k.options.indexLabelBorderThickness ? k.options.indexLabelBorderThickness : k.indexLabelBorderThickness;
                g3.indexLabelPadding = f2.indexLabelPadding ? f2.indexLabelPadding : k.options.indexLabelPadding ? k.options.indexLabelPadding : k.indexLabelPadding;
                g3.indexLabelMaxWidth = f2.indexLabelMaxWidth ? f2.indexLabelMaxWidth : k.indexLabelMaxWidth;
                g3.indexLabelWrap = "undefined" !== typeof f2.indexLabelWrap ? f2.indexLabelWrap : k.indexLabelWrap;
                g3.indexLabelTextAlign = f2.indexLabelTextAlign ? f2.indexLabelTextAlign : k.indexLabelTextAlign ? k.indexLabelTextAlign : "left";
                g3.startAngle = 0 === d2 ? k.startAngle ? k.startAngle / 180 * Math.PI : 0 : h[d2 - 1].endAngle;
                g3.startAngle = (g3.startAngle + 2 * Math.PI) % (2 * Math.PI);
                g3.endAngle = g3.startAngle + 2 * Math.PI / u3 * Math.abs(f2.y);
                f2 = (g3.endAngle + g3.startAngle) / 2;
                f2 = (f2 + 2 * Math.PI) % (2 * Math.PI);
                g3.midAngle = f2;
                if (g3.midAngle > Math.PI / 2 - s && g3.midAngle < Math.PI / 2 + s) {
                  if (0 === a2 || h[c2].midAngle > g3.midAngle) c2 = d2;
                  a2++;
                } else if (g3.midAngle > 3 * Math.PI / 2 - s && g3.midAngle < 3 * Math.PI / 2 + s) {
                  if (0 === b2 || h[e2].midAngle > g3.midAngle) e2 = d2;
                  b2++;
                }
                g3.hemisphere = f2 > Math.PI / 2 && f2 <= 3 * Math.PI / 2 ? "left" : "right";
                g3.indexLabelTextBlock = new ja(t2.plotArea.ctx, {
                  fontSize: g3.indexLabelFontSize,
                  fontFamily: g3.indexLabelFontFamily,
                  fontColor: g3.indexLabelFontColor,
                  fontStyle: g3.indexLabelFontStyle,
                  fontWeight: g3.indexLabelFontWeight,
                  textAlign: g3.indexLabelTextAlign,
                  backgroundColor: g3.indexLabelBackgroundColor,
                  borderColor: g3.indexLabelBorderColor,
                  borderThickness: g3.indexLabelBorderThickness,
                  maxWidth: g3.indexLabelMaxWidth,
                  maxHeight: g3.indexLabelWrap ? 5 * g3.indexLabelFontSize : 1.5 * g3.indexLabelFontSize,
                  text: g3.indexLabelText,
                  padding: g3.indexLabelPadding,
                  textBaseline: "middle"
                });
                g3.indexLabelTextBlock.measureText();
              }
              q2 = f2 = 0;
              n2 = false;
              for (d2 = 0; d2 < m.length; d2++) g3 = h[(c2 + d2) % m.length], 1 < a2 && (g3.midAngle > Math.PI / 2 - s && g3.midAngle < Math.PI / 2 + s) && (f2 <= a2 / 2 && !n2 ? (g3.hemisphere = "right", f2++) : (g3.hemisphere = "left", n2 = true));
              n2 = false;
              for (d2 = 0; d2 < m.length; d2++) g3 = h[(e2 + d2) % m.length], 1 < b2 && (g3.midAngle > 3 * Math.PI / 2 - s && g3.midAngle < 3 * Math.PI / 2 + s) && (q2 <= b2 / 2 && !n2 ? (g3.hemisphere = "left", q2++) : (g3.hemisphere = "right", n2 = true));
            }
          }
          function c(a2, b2) {
            var c2 = t2.plotArea.ctx;
            c2.clearRect(p.x1, p.y1, p.width, p.height);
            c2.fillStyle = t2.backgroundColor;
            c2.fillRect(p.x1, p.y1, p.width, p.height);
            for (c2 = 0; c2 < m.length; c2++) {
              var e2 = h[c2].startAngle, d2 = h[c2].endAngle;
              if (d2 > e2) {
                var f2 = 0.07 * C3 * Math.cos(h[c2].midAngle), q2 = 0.07 * C3 * Math.sin(h[c2].midAngle), g3 = false;
                if (m[c2].exploded) {
                  if (1e-9 < Math.abs(h[c2].center.x - (v.x + f2)) || 1e-9 < Math.abs(h[c2].center.y - (v.y + q2))) h[c2].center.x = v.x + f2 * a2, h[c2].center.y = v.y + q2 * a2, g3 = true;
                } else if (0 < Math.abs(h[c2].center.x - v.x) || 0 < Math.abs(h[c2].center.y - v.y)) h[c2].center.x = v.x + f2 * (1 - a2), h[c2].center.y = v.y + q2 * (1 - a2), g3 = true;
                g3 && b2 && (f2 = {}, f2.dataSeries = k, f2.dataPoint = k.dataPoints[c2], f2.index = c2, t2.toolTip.highlightObjects([f2]));
                pa2(t2.plotArea.ctx, h[c2].center, h[c2].radius, m[c2].color ? m[c2].color : k._colorSet[c2 % k._colorSet.length], k.type, e2, d2, k.fillOpacity, h[c2].percentInnerRadius);
              }
            }
            c2 = t2.plotArea.ctx;
            c2.save();
            c2.fillStyle = "black";
            c2.strokeStyle = "grey";
            c2.textBaseline = "middle";
            c2.lineJoin = "round";
            for (e2 = e2 = 0; e2 < m.length; e2++) d2 = h[e2], d2.indexLabelText && (d2.indexLabelTextBlock.y -= d2.indexLabelTextBlock.height / 2 - d2.indexLabelTextBlock._lineHeight / 2, f2 = 0, f2 = "left" === d2.hemisphere ? "inside" !== k.indexLabelPlacement ? -(d2.indexLabelTextBlock.width + n) : -d2.indexLabelTextBlock.width / 2 : "inside" !== k.indexLabelPlacement ? n : -d2.indexLabelTextBlock.width / 2, d2.indexLabelTextBlock.x += f2, d2.indexLabelTextBlock.render(true), d2.indexLabelTextBlock.x -= f2, d2.indexLabelTextBlock.y += d2.indexLabelTextBlock.height / 2 - d2.indexLabelTextBlock._lineHeight / 2, "inside" !== d2.indexLabelPlacement && 0 < d2.indexLabelLineThickness && (f2 = d2.center.x + C3 * Math.cos(d2.midAngle), q2 = d2.center.y + C3 * Math.sin(d2.midAngle), c2.strokeStyle = d2.indexLabelLineColor, c2.lineWidth = d2.indexLabelLineThickness, c2.setLineDash && c2.setLineDash(K(d2.indexLabelLineDashType, d2.indexLabelLineThickness)), c2.beginPath(), c2.moveTo(f2, q2), c2.lineTo(d2.indexLabelTextBlock.x, d2.indexLabelTextBlock.y), c2.lineTo(d2.indexLabelTextBlock.x + ("left" === d2.hemisphere ? -n : n), d2.indexLabelTextBlock.y), c2.stroke()), c2.lineJoin = "miter");
            c2.save();
          }
          function b(a2, b2) {
            var c2 = 0, c2 = a2.indexLabelTextBlock.y - a2.indexLabelTextBlock.height / 2, d2 = a2.indexLabelTextBlock.y + a2.indexLabelTextBlock.height / 2, e2 = b2.indexLabelTextBlock.y - b2.indexLabelTextBlock.height / 2, f2 = b2.indexLabelTextBlock.y + b2.indexLabelTextBlock.height / 2;
            return c2 = b2.indexLabelTextBlock.y > a2.indexLabelTextBlock.y ? e2 - d2 : c2 - f2;
          }
          function d(a2) {
            for (var c2 = null, d2 = 1; d2 < m.length; d2++) if (c2 = (a2 + d2 + h.length) % h.length, h[c2].hemisphere !== h[a2].hemisphere) {
              c2 = null;
              break;
            } else if (h[c2].indexLabelText && c2 !== a2 && (0 > b(h[c2], h[a2]) || ("right" === h[a2].hemisphere ? h[c2].indexLabelTextBlock.y >= h[a2].indexLabelTextBlock.y : h[c2].indexLabelTextBlock.y <= h[a2].indexLabelTextBlock.y))) break;
            else c2 = null;
            return c2;
          }
          function f(a2, c2, e2) {
            e2 = (e2 || 0) + 1;
            if (1e3 < e2) return 0;
            c2 = c2 || 0;
            var q2 = 0, k2 = v.y - 1 * r2, g3 = v.y + 1 * r2;
            if (0 <= a2 && a2 < m.length) {
              var l2 = h[a2];
              if (0 > c2 && l2.indexLabelTextBlock.y < k2 || 0 < c2 && l2.indexLabelTextBlock.y > g3) return 0;
              var n2 = 0, p2 = 0, p2 = n2 = n2 = 0;
              0 > c2 ? l2.indexLabelTextBlock.y - l2.indexLabelTextBlock.height / 2 > k2 && l2.indexLabelTextBlock.y - l2.indexLabelTextBlock.height / 2 + c2 < k2 && (c2 = -(k2 - (l2.indexLabelTextBlock.y - l2.indexLabelTextBlock.height / 2 + c2))) : l2.indexLabelTextBlock.y + l2.indexLabelTextBlock.height / 2 < k2 && l2.indexLabelTextBlock.y + l2.indexLabelTextBlock.height / 2 + c2 > g3 && (c2 = l2.indexLabelTextBlock.y + l2.indexLabelTextBlock.height / 2 + c2 - g3);
              c2 = l2.indexLabelTextBlock.y + c2;
              k2 = 0;
              k2 = "right" === l2.hemisphere ? v.x + Math.sqrt(Math.pow(r2, 2) - Math.pow(
                c2 - v.y,
                2
              )) : v.x - Math.sqrt(Math.pow(r2, 2) - Math.pow(c2 - v.y, 2));
              p2 = v.x + C3 * Math.cos(l2.midAngle);
              n2 = v.y + C3 * Math.sin(l2.midAngle);
              n2 = Math.sqrt(Math.pow(k2 - p2, 2) + Math.pow(c2 - n2, 2));
              p2 = Math.acos(C3 / r2);
              n2 = Math.acos((r2 * r2 + C3 * C3 - n2 * n2) / (2 * C3 * r2));
              c2 = n2 < p2 ? c2 - l2.indexLabelTextBlock.y : 0;
              k2 = null;
              for (g3 = 1; g3 < m.length; g3++) if (k2 = (a2 - g3 + h.length) % h.length, h[k2].hemisphere !== h[a2].hemisphere) {
                k2 = null;
                break;
              } else if (h[k2].indexLabelText && h[k2].hemisphere === h[a2].hemisphere && k2 !== a2 && (0 > b(h[k2], h[a2]) || ("right" === h[a2].hemisphere ? h[k2].indexLabelTextBlock.y <= h[a2].indexLabelTextBlock.y : h[k2].indexLabelTextBlock.y >= h[a2].indexLabelTextBlock.y))) break;
              else k2 = null;
              p2 = k2;
              n2 = d(a2);
              g3 = k2 = 0;
              0 > c2 ? (g3 = "right" === l2.hemisphere ? p2 : n2, q2 = c2, null !== g3 && (p2 = -c2, c2 = l2.indexLabelTextBlock.y - l2.indexLabelTextBlock.height / 2 - (h[g3].indexLabelTextBlock.y + h[g3].indexLabelTextBlock.height / 2), c2 - p2 < y && (k2 = -p2, g3 = f(g3, k2, e2 + 1), +g3.toFixed(x) > +k2.toFixed(x) && (q2 = c2 > y ? -(c2 - y) : -(p2 - (g3 - k2)))))) : 0 < c2 && (g3 = "right" === l2.hemisphere ? n2 : p2, q2 = c2, null !== g3 && (p2 = c2, c2 = h[g3].indexLabelTextBlock.y - h[g3].indexLabelTextBlock.height / 2 - (l2.indexLabelTextBlock.y + l2.indexLabelTextBlock.height / 2), c2 - p2 < y && (k2 = p2, g3 = f(g3, k2, e2 + 1), +g3.toFixed(x) < +k2.toFixed(x) && (q2 = c2 > y ? c2 - y : p2 - (k2 - g3)))));
              q2 && (e2 = l2.indexLabelTextBlock.y + q2, c2 = 0, c2 = "right" === l2.hemisphere ? v.x + Math.sqrt(Math.pow(r2, 2) - Math.pow(e2 - v.y, 2)) : v.x - Math.sqrt(Math.pow(r2, 2) - Math.pow(e2 - v.y, 2)), l2.midAngle > Math.PI / 2 - s && l2.midAngle < Math.PI / 2 + s ? (k2 = (a2 - 1 + h.length) % h.length, k2 = h[k2], a2 = h[(a2 + 1 + h.length) % h.length], "left" === l2.hemisphere && "right" === k2.hemisphere && c2 > k2.indexLabelTextBlock.x ? c2 = k2.indexLabelTextBlock.x - 15 : "right" === l2.hemisphere && ("left" === a2.hemisphere && c2 < a2.indexLabelTextBlock.x) && (c2 = a2.indexLabelTextBlock.x + 15)) : l2.midAngle > 3 * Math.PI / 2 - s && l2.midAngle < 3 * Math.PI / 2 + s && (k2 = (a2 - 1 + h.length) % h.length, k2 = h[k2], a2 = h[(a2 + 1 + h.length) % h.length], "right" === l2.hemisphere && "left" === k2.hemisphere && c2 < k2.indexLabelTextBlock.x ? c2 = k2.indexLabelTextBlock.x + 15 : "left" === l2.hemisphere && ("right" === a2.hemisphere && c2 > a2.indexLabelTextBlock.x) && (c2 = a2.indexLabelTextBlock.x - 15)), l2.indexLabelTextBlock.y = e2, l2.indexLabelTextBlock.x = c2, l2.indexLabelAngle = Math.atan2(l2.indexLabelTextBlock.y - v.y, l2.indexLabelTextBlock.x - v.x));
            }
            return q2;
          }
          function q() {
            var a2 = t2.plotArea.ctx;
            a2.fillStyle = "grey";
            a2.strokeStyle = "grey";
            a2.font = "16px Arial";
            a2.textBaseline = "middle";
            for (var c2 = a2 = 0, e2 = 0, q2 = true, c2 = 0; 10 > c2 && (1 > c2 || 0 < e2); c2++) {
              if (k.radius || !k.radius && "undefined" !== typeof k.innerRadius && null !== k.innerRadius && C3 - e2 <= E) q2 = false;
              q2 && (C3 -= e2);
              e2 = 0;
              if ("inside" !== k.indexLabelPlacement) {
                r2 = C3 * z;
                for (a2 = 0; a2 < m.length; a2++) {
                  var g3 = h[a2];
                  g3.indexLabelTextBlock.x = v.x + r2 * Math.cos(g3.midAngle);
                  g3.indexLabelTextBlock.y = v.y + r2 * Math.sin(g3.midAngle);
                  g3.indexLabelAngle = g3.midAngle;
                  g3.radius = C3;
                  g3.percentInnerRadius = F3;
                }
                for (var l2, s2, a2 = 0; a2 < m.length; a2++) {
                  var g3 = h[a2], w = d(a2);
                  if (null !== w) {
                    l2 = h[a2];
                    s2 = h[w];
                    var u4 = 0, u4 = b(l2, s2) - y;
                    if (0 > u4) {
                      for (var B3 = s2 = 0, D = 0; D < m.length; D++) D !== a2 && h[D].hemisphere === g3.hemisphere && (h[D].indexLabelTextBlock.y < g3.indexLabelTextBlock.y ? s2++ : B3++);
                      s2 = u4 / (s2 + B3 || 1) * B3;
                      var B3 = -1 * (u4 - s2), K2 = D = 0;
                      "right" === g3.hemisphere ? (D = f(a2, s2), B3 = -1 * (u4 - D), K2 = f(w, B3), +K2.toFixed(x) < +B3.toFixed(x) && +D.toFixed(x) <= +s2.toFixed(x) && f(a2, -(B3 - K2))) : (D = f(w, s2), B3 = -1 * (u4 - D), K2 = f(a2, B3), +K2.toFixed(x) < +B3.toFixed(x) && +D.toFixed(x) <= +s2.toFixed(x) && f(w, -(B3 - K2)));
                    }
                  }
                }
              } else for (a2 = 0; a2 < m.length; a2++) g3 = h[a2], r2 = "pie" === k.type ? 0.7 * C3 : 0.85 * C3, w = v.x + r2 * Math.cos(g3.midAngle), s2 = v.y + r2 * Math.sin(g3.midAngle), g3.indexLabelTextBlock.x = w, g3.indexLabelTextBlock.y = s2;
              for (a2 = 0; a2 < m.length; a2++) if (g3 = h[a2], w = g3.indexLabelTextBlock.measureText(), 0 !== w.height && 0 !== w.width) w = w = 0, "right" === g3.hemisphere ? (w = p.x2 - (g3.indexLabelTextBlock.x + g3.indexLabelTextBlock.width + n), w *= -1) : w = p.x1 - (g3.indexLabelTextBlock.x - g3.indexLabelTextBlock.width - n), 0 < w && (!q2 && g3.indexLabelText && (s2 = "right" === g3.hemisphere ? p.x2 - g3.indexLabelTextBlock.x : g3.indexLabelTextBlock.x - p.x1, 0.3 * g3.indexLabelTextBlock.maxWidth > s2 ? g3.indexLabelText = "" : g3.indexLabelTextBlock.maxWidth = 0.85 * s2, 0.3 * g3.indexLabelTextBlock.maxWidth < s2 && (g3.indexLabelTextBlock.x -= "right" === g3.hemisphere ? 2 : -2)), Math.abs(g3.indexLabelTextBlock.y - g3.indexLabelTextBlock.height / 2 - v.y) < C3 || Math.abs(g3.indexLabelTextBlock.y + g3.indexLabelTextBlock.height / 2 - v.y) < C3) && (w /= Math.abs(Math.cos(g3.indexLabelAngle)), 9 < w && (w *= 0.3), w > e2 && (e2 = w)), w = w = 0, 0 < g3.indexLabelAngle && g3.indexLabelAngle < Math.PI ? (w = p.y2 - (g3.indexLabelTextBlock.y + g3.indexLabelTextBlock.height / 2 + 5), w *= -1) : w = p.y1 - (g3.indexLabelTextBlock.y - g3.indexLabelTextBlock.height / 2 - 5), 0 < w && (!q2 && g3.indexLabelText && (s2 = 0 < g3.indexLabelAngle && g3.indexLabelAngle < Math.PI ? -1 : 1, 0 === f(a2, w * s2) && f(a2, 2 * s2)), Math.abs(g3.indexLabelTextBlock.x - v.x) < C3 && (w /= Math.abs(Math.sin(g3.indexLabelAngle)), 9 < w && (w *= 0.3), w > e2 && (e2 = w)));
              var O2 = function(a3, b2, c3) {
                for (var e3 = [], d2 = 0; e3.push(h[b2]), b2 !== c3; b2 = (b2 + 1 + m.length) % m.length) ;
                e3.sort(function(a4, b3) {
                  return a4.y - b3.y;
                });
                for (b2 = 0; b2 < e3.length; b2++) if (c3 = e3[b2], d2 < 0.7 * a3) d2 += c3.indexLabelTextBlock.height, c3.indexLabelTextBlock.text = "", c3.indexLabelText = "", c3.indexLabelTextBlock.measureText();
                else break;
              };
              (function() {
                for (var a3 = -1, c3 = -1, e3 = 0, f2 = false, q3 = 0; q3 < m.length; q3++) if (f2 = false, l2 = h[q3], l2.indexLabelText) {
                  var k2 = d(q3);
                  if (null !== k2) {
                    var g4 = h[k2];
                    u4 = 0;
                    u4 = b(l2, g4);
                    var p2;
                    if (p2 = 0 > u4) {
                      p2 = l2.indexLabelTextBlock.x;
                      var w2 = l2.indexLabelTextBlock.y - l2.indexLabelTextBlock.height / 2, s3 = l2.indexLabelTextBlock.y + l2.indexLabelTextBlock.height / 2, t3 = g4.indexLabelTextBlock.y - g4.indexLabelTextBlock.height / 2, y2 = g4.indexLabelTextBlock.x + g4.indexLabelTextBlock.width, r3 = g4.indexLabelTextBlock.y + g4.indexLabelTextBlock.height / 2;
                      p2 = l2.indexLabelTextBlock.x + l2.indexLabelTextBlock.width < g4.indexLabelTextBlock.x - n || p2 > y2 + n || w2 > r3 + n || s3 < t3 - n ? false : true;
                    }
                    p2 ? (0 > a3 && (a3 = q3), k2 !== a3 && (c3 = k2, e3 += -u4), 0 === q3 % Math.max(m.length / 10, 3) && (f2 = true)) : f2 = true;
                    f2 && (0 < e3 && 0 <= a3 && 0 <= c3) && (O2(e3, a3, c3), c3 = a3 = -1, e3 = 0);
                  }
                }
                0 < e3 && O2(e3, a3, c3);
              })();
            }
          }
          function g2() {
            t2.plotArea.layoutManager.reset();
            t2.title && (t2.title.dockInsidePlotArea || "center" === t2.title.horizontalAlign && "center" === t2.title.verticalAlign) && t2.title.render();
            if (t2.subtitles) for (var a2 = 0; a2 < t2.subtitles.length; a2++) {
              var b2 = t2.subtitles[a2];
              (b2.dockInsidePlotArea || "center" === b2.horizontalAlign && "center" === b2.verticalAlign) && b2.render();
            }
            t2.legend && (t2.legend.dockInsidePlotArea || "center" === t2.legend.horizontalAlign && "center" === t2.legend.verticalAlign) && (t2.legend.setLayout(), t2.legend.render());
          }
          var t2 = this;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var k = this.data[a.dataSeriesIndexes[0]], m = k.dataPoints, n = 10, p = this.plotArea, h = k.dataPointEOs, y = 2, r2, z = 1.3, s = 20 / 180 * Math.PI, x = 6, v = { x: (p.x2 + p.x1) / 2, y: (p.y2 + p.y1) / 2 }, u3 = 0;
            a = false;
            for (var B2 = 0; B2 < m.length; B2++) u3 += Math.abs(m[B2].y), !a && ("undefined" !== typeof m[B2].indexLabel && null !== m[B2].indexLabel && 0 < m[B2].indexLabel.toString().length) && (a = true), !a && ("undefined" !== typeof m[B2].label && null !== m[B2].label && 0 < m[B2].label.toString().length) && (a = true);
            if (0 !== u3) {
              a = a || "undefined" !== typeof k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length;
              var C3 = "inside" !== k.indexLabelPlacement && a ? 0.75 * Math.min(p.width, p.height) / 2 : 0.92 * Math.min(p.width, p.height) / 2;
              k.radius && (C3 = Sa(
                k.radius,
                C3
              ));
              var E = "undefined" !== typeof k.innerRadius && null !== k.innerRadius ? Sa(k.innerRadius, C3) : 0.7 * C3, F3 = Math.min(E / C3, (C3 - 1) / C3);
              this.pieDoughnutClickHandler = function(a2) {
                t2.isAnimating || !l(this.explodeOnClick) && !this.explodeOnClick || (a2 = a2.dataPoint, a2.exploded = a2.exploded ? false : true, 1 < this.dataPoints.length && t2._animator.animate(0, 500, function(a3) {
                  c(a3, true);
                  g2();
                  t2.dispatchEvent("dataAnimationIterationEnd", { chart: t2 });
                  t2.dispatchEvent("dataAnimationEnd", { chart: t2 });
                }));
              };
              e();
              q();
              q();
              q();
              q();
              this.disableToolTip = true;
              this._animator.animate(
                0,
                this.animatedRender ? this.animationDuration : 0,
                function(a2) {
                  var b2 = t2.plotArea.ctx;
                  b2.clearRect(p.x1, p.y1, p.width, p.height);
                  b2.fillStyle = t2.backgroundColor;
                  b2.fillRect(p.x1, p.y1, p.width, p.height);
                  for (var b2 = h[0].startAngle + 2 * Math.PI * a2, c2 = 0; c2 < m.length; c2++) {
                    var e2 = 0 === c2 ? h[c2].startAngle : d2, d2 = e2 + (h[c2].endAngle - h[c2].startAngle), f2 = false;
                    d2 > b2 && (d2 = b2, f2 = true);
                    var q2 = m[c2].color ? m[c2].color : k._colorSet[c2 % k._colorSet.length];
                    d2 > e2 && pa2(t2.plotArea.ctx, h[c2].center, h[c2].radius, q2, k.type, e2, d2, k.fillOpacity, h[c2].percentInnerRadius);
                    if (f2) break;
                  }
                  g2();
                  t2.dispatchEvent("dataAnimationIterationEnd", { chart: t2 });
                  1 <= a2 && t2.dispatchEvent("dataAnimationEnd", { chart: t2 });
                },
                function() {
                  t2.disableToolTip = false;
                  t2._animator.animate(0, t2.animatedRender ? 500 : 0, function(a2) {
                    c(a2, false);
                    g2();
                    t2.dispatchEvent("dataAnimationIterationEnd", { chart: t2 });
                  });
                  t2.dispatchEvent("dataAnimationEnd", { chart: t2 });
                }
              );
              k.radius = C3;
              "doughnut" === k.type && (k.innerRadius = E);
            }
          }
        };
        var qa2 = function(a, e, c, b) {
          "undefined" === typeof c && (c = 1);
          0 >= Math.round(e.y4 - e.y1) || (a.save(), a.globalAlpha = c, a.beginPath(), a.moveTo(
            Math.round(e.x1),
            Math.round(e.y1)
          ), a.lineTo(Math.round(e.x2), Math.round(e.y2)), a.lineTo(Math.round(e.x3), Math.round(e.y3)), a.lineTo(Math.round(e.x4), Math.round(e.y4)), "undefined" !== e.x5 && (a.lineTo(Math.round(e.x5), Math.round(e.y5)), a.lineTo(Math.round(e.x6), Math.round(e.y6))), a.closePath(), a.fillStyle = b ? b : e.color, a.fill(), a.globalAplha = 1, a.restore());
        };
        t.prototype.renderFunnel = function(a) {
          function e() {
            for (var a2 = 0, b2 = [], c2 = 0; c2 < x.length; c2++) {
              if ("undefined" === typeof x[c2].y) return -1;
              x[c2].y = "number" === typeof x[c2].y ? x[c2].y : 0;
              a2 += Math.abs(x[c2].y);
            }
            if (0 === a2) return -1;
            for (c2 = b2[0] = 0; c2 < x.length; c2++) b2.push(Math.abs(x[c2].y) * E / a2);
            return b2;
          }
          function c() {
            var a2 = V2, b2 = T2, c2 = aa, e2 = X2, d2, f2;
            d2 = $;
            f2 = P2 - M2;
            e2 = Math.abs((f2 - d2) * (b2 - a2 + (e2 - c2)) / 2);
            c2 = X2 - aa;
            d2 = f2 - d2;
            f2 = c2 * (f2 - P2);
            f2 = Math.abs(f2);
            f2 = e2 + f2;
            for (var e2 = [], h2 = 0, q2 = 0; q2 < x.length; q2++) {
              if ("undefined" === typeof x[q2].y) return -1;
              x[q2].y = "number" === typeof x[q2].y ? x[q2].y : 0;
              h2 += Math.abs(x[q2].y);
            }
            if (0 === h2) return -1;
            for (var k2 = e2[0] = 0, g3 = 0, l2, m2, b2 = b2 - a2, k2 = false, q2 = 0; q2 < x.length; q2++) a2 = Math.abs(x[q2].y) * f2 / h2, k2 ? l2 = 0 == Number(c2.toFixed(3)) ? 0 : a2 / c2 : (m2 = da3 * da3 * b2 * b2 - 4 * Math.abs(da3) * a2, 0 > m2 ? (m2 = c2, k2 = (b2 + m2) * (d2 - g3) / 2, a2 -= k2, l2 = d2 - g3, g3 += d2 - g3, l2 += 0 == m2 ? 0 : a2 / m2, g3 += a2 / m2, k2 = true) : (l2 = (Math.abs(da3) * b2 - Math.sqrt(m2)) / 2, m2 = b2 - 2 * l2 / Math.abs(da3), g3 += l2, g3 > d2 && (g3 -= l2, m2 = c2, k2 = (b2 + m2) * (d2 - g3) / 2, a2 -= k2, l2 = d2 - g3, g3 += d2 - g3, l2 += a2 / m2, g3 += a2 / m2, k2 = true), b2 = m2)), e2.push(l2);
            return e2;
          }
          function b() {
            if (s && x) {
              for (var a2, b2, c2, e2, d2, f2, q2, g3, k2, m2, n2, p2, w, t3, y2, v2, u4, A2, J = [], B3 = [], C4 = { percent: null, total: null }, E2 = null, D = 0; D < x.length; D++) A2 = H[D], A2 = "undefined" !== typeof A2.x5 ? (A2.y2 + A2.y4) / 2 : (A2.y2 + A2.y3) / 2, A2 = h(A2).x2 + 1, J[D] = Z - (isNaN(A2) ? 0 : A2) - U2;
              A2 = 0.5 * U2;
              for (var D = 0, F4 = x.length - 1; D < x.length || 0 <= F4; D++, F4--) {
                b2 = s.reversed ? x[F4] : x[D];
                a2 = b2.color ? b2.color : s.reversed ? s._colorSet[(x.length - 1 - D) % s._colorSet.length] : s._colorSet[D % s._colorSet.length];
                c2 = b2.indexLabelPlacement || s.indexLabelPlacement || "outside";
                u4 = b2.indexLabelTextAlign || s.indexLabelTextAlign || "left";
                e2 = b2.indexLabelBackgroundColor || s.indexLabelBackgroundColor || (r ? "transparent" : null);
                d2 = b2.indexLabelBorderColor || s.indexLabelBorderColor || (r ? "transparent" : null);
                f2 = l(b2.indexLabelBorderThickness) ? s.indexLabelBorderThickness : b2.indexLabelBorderThickness;
                q2 = l(b2.indexLabelPadding) ? s.options.indexLabelPadding ? s.options.indexLabelPadding : s.indexLabelPadding : b2.indexLabelPadding;
                g3 = b2.indexLabelFontColor || s.indexLabelFontColor || "#979797";
                k2 = l(b2.indexLabelFontSize) ? s.indexLabelFontSize : b2.indexLabelFontSize;
                m2 = b2.indexLabelFontStyle || s.indexLabelFontStyle || "normal";
                n2 = b2.indexLabelFontFamily || s.indexLabelFontFamily || "arial";
                p2 = b2.indexLabelFontWeight || s.indexLabelFontWeight || "normal";
                a2 = b2.indexLabelLineColor || s.options.indexLabelLineColor || a2;
                w = "number" === typeof b2.indexLabelLineThickness ? b2.indexLabelLineThickness : "number" === typeof s.indexLabelLineThickness ? s.indexLabelLineThickness : 2;
                t3 = b2.indexLabelLineDashType || s.indexLabelLineDashType || "solid";
                y2 = "undefined" !== typeof b2.indexLabelWrap ? b2.indexLabelWrap : "undefined" !== typeof s.indexLabelWrap ? s.indexLabelWrap : true;
                v2 = s.dataPointIds[D];
                z._eventManager.objectMap[v2] = { id: v2, objectType: "dataPoint", dataPointIndex: D, dataSeriesIndex: 0, funnelSection: H[s.reversed ? x.length - 1 - D : D] };
                "inside" === s.indexLabelPlacement && (J[D] = D !== ea2 ? s.reversed ? H[D].x2 - H[D].x1 : H[D].x3 - H[D].x4 : H[D].x3 - H[D].x6, 20 > J[D] && (J[D] = D !== ea2 ? s.reversed ? H[D].x3 - H[D].x4 : H[D].x2 - H[D].x1 : H[D].x2 - H[D].x1, J[D] /= 2));
                v2 = b2.indexLabelMaxWidth ? b2.indexLabelMaxWidth : s.options.indexLabelMaxWidth ? s.indexLabelMaxWidth : J[D];
                if (v2 > J[D] || 0 > v2) v2 = J[D];
                B3[D] = "inside" === s.indexLabelPlacement ? y2 ? Math.max(H[D].height, k2) : 1.5 * k2 + ("object" === typeof q2 ? (q2.top || 0) + (q2.bottom || 0) : 2 * q2) : false;
                C4 = z.getPercentAndTotal(s, b2);
                if (s.indexLabelFormatter || b2.indexLabelFormatter) E2 = {
                  chart: z.options,
                  dataSeries: s,
                  dataPoint: b2,
                  total: C4.total,
                  percent: C4.percent
                };
                b2 = b2.indexLabelFormatter ? b2.indexLabelFormatter(E2) : b2.indexLabel ? z.replaceKeywordsWithValue(b2.indexLabel, b2, s, D) : s.indexLabelFormatter ? s.indexLabelFormatter(E2) : s.indexLabel ? z.replaceKeywordsWithValue(s.indexLabel, b2, s, D) : b2.label ? b2.label : "";
                0 >= w && (w = 0);
                1e3 > v2 && 1e3 - v2 < A2 && (v2 += 1e3 - v2);
                l(s.options.indexLabelMaxWidth) && (s.indexLabelMaxWidth = l(s.indexLabelMaxWidth) ? v2 : Math.max(v2, s.indexLabelMaxWidth));
                Q3.roundRect || ya(Q3);
                c2 = new ja(Q3, {
                  fontSize: k2,
                  fontFamily: n2,
                  fontColor: g3,
                  fontStyle: m2,
                  fontWeight: p2,
                  horizontalAlign: c2,
                  textAlign: u4,
                  backgroundColor: e2,
                  borderColor: d2,
                  borderThickness: f2,
                  maxWidth: v2,
                  maxHeight: false === B3[D] ? (y2 ? 4.28571429 * k2 : 1.5 * k2) + ("object" === typeof q2 ? (q2.top || 0) + (q2.bottom || 0) : 2 * q2) : B3[D],
                  text: b2,
                  padding: q2,
                  textBaseline: "middle"
                });
                c2.measureText();
                c2.height = c2.height === 2 * c2.padding ? 0 : c2.height;
                c2.width = c2.width === 2 * c2.padding ? 0 : c2.width;
                I.push({ textBlock: c2, id: s.reversed ? F4 : D, isDirty: false, lineColor: a2, lineThickness: w, lineDashType: t3, height: c2.height < c2.maxHeight ? c2.height : c2.maxHeight, width: c2.width < c2.maxWidth ? c2.width : c2.maxWidth });
              }
            }
          }
          function d() {
            var a2, b2, c2, e2, d2, f2 = [];
            d2 = false;
            c2 = 0;
            for (var h2, q2 = Z - T2 - U2 / 2, q2 = s.options.indexLabelMaxWidth ? s.indexLabelMaxWidth > q2 ? q2 : s.indexLabelMaxWidth : q2, k2 = I.length - 1; 0 <= k2; k2--) {
              h2 = x[I[k2].id];
              c2 = I[k2];
              e2 = c2.textBlock;
              b2 = (a2 = p(k2) < H.length ? I[p(k2)] : null) ? a2.textBlock : null;
              c2 = c2.height;
              a2 && e2.y + c2 + fa3 > b2.y && (d2 = true);
              c2 = h2.indexLabelMaxWidth || q2;
              if (c2 > q2 || 0 > c2) c2 = q2;
              f2.push(c2);
            }
            if (d2) for (k2 = I.length - 1; 0 <= k2; k2--) a2 = H[k2], I[k2].textBlock.maxWidth = f2[f2.length - (k2 + 1)], I[k2].textBlock.measureText(), I[k2].textBlock.height = I[k2].textBlock.height === 2 * I[k2].textBlock.padding ? 0 : I[k2].textBlock.height, I[k2].textBlock.width = I[k2].textBlock.width === 2 * I[k2].textBlock.padding ? 0 : I[k2].textBlock.width, I[k2].textBlock.x = Z - q2, c2 = I[k2].textBlock.height < I[k2].textBlock.maxHeight ? I[k2].textBlock.height : I[k2].textBlock.maxHeight, d2 = I[k2].textBlock.width < I[k2].textBlock.maxWidth ? I[k2].textBlock.width : I[k2].textBlock.maxWidth, I[k2].height = c2, I[k2].width = d2, c2 = "undefined" !== typeof a2.x5 ? (a2.y2 + a2.y4) / 2 : (a2.y2 + a2.y3) / 2, I[k2].textBlock.y = c2 - I[k2].height / 2, s.reversed ? (I[k2].textBlock.y + I[k2].height > S + u3 && (I[k2].textBlock.y = S + u3 - I[k2].height), I[k2].textBlock.y < Y2 - u3 && (I[k2].textBlock.y = Y2 - u3)) : (I[k2].textBlock.y < S - u3 && (I[k2].textBlock.y = S - u3), I[k2].textBlock.y + I[k2].height > Y2 + u3 && (I[k2].textBlock.y = Y2 + u3 - I[k2].height));
          }
          function f() {
            var a2, b2, c2, e2;
            if ("inside" !== s.indexLabelPlacement) for (var d2 = 0; d2 < H.length; d2++) 0 == I[d2].textBlock.text.length ? I[d2].isDirty = true : (a2 = H[d2], c2 = "undefined" !== typeof a2.x5 ? (a2.y2 + a2.y4) / 2 : (a2.y2 + a2.y3) / 2, b2 = s.reversed ? "undefined" !== typeof a2.x5 ? c2 > va ? h(c2).x2 + 1 : (a2.x2 + a2.x3) / 2 + 1 : (a2.x2 + a2.x3) / 2 + 1 : "undefined" !== typeof a2.x5 ? c2 < va ? h(c2).x2 + 1 : (a2.x4 + a2.x3) / 2 + 1 : (a2.x2 + a2.x3) / 2 + 1, I[d2].textBlock.x = b2 + U2, I[d2].textBlock.y = c2 - I[d2].height / 2, s.reversed ? (I[d2].textBlock.y + I[d2].height > S + u3 && (I[d2].textBlock.y = S + u3 - I[d2].height), I[d2].textBlock.y < Y2 - u3 && (I[d2].textBlock.y = Y2 - u3)) : (I[d2].textBlock.y < S - u3 && (I[d2].textBlock.y = S - u3), I[d2].textBlock.y + I[d2].height > Y2 + u3 && (I[d2].textBlock.y = Y2 + u3 - I[d2].height)));
            else for (d2 = 0; d2 < H.length; d2++) 0 == I[d2].textBlock.text.length ? I[d2].isDirty = true : (a2 = H[d2], b2 = a2.height, c2 = I[d2].height, e2 = I[d2].width, b2 >= c2 ? (b2 = d2 != ea2 ? (a2.x4 + a2.x3) / 2 - e2 / 2 : (a2.x5 + a2.x4) / 2 - e2 / 2, c2 = d2 != ea2 ? (a2.y1 + a2.y3) / 2 - c2 / 2 : (a2.y1 + a2.y4) / 2 - c2 / 2, I[d2].textBlock.x = b2, I[d2].textBlock.y = c2) : I[d2].isDirty = true);
          }
          function q() {
            function a2(b3, c3) {
              var d3;
              if (0 > b3 || b3 >= I.length) return 0;
              var e3, f3 = I[b3].textBlock;
              if (0 > c3) {
                c3 *= -1;
                e3 = n(b3);
                d3 = g2(e3, b3);
                if (d3 >= c3) return f3.y -= c3, c3;
                if (0 == b3) return 0 < d3 && (f3.y -= d3), d3;
                d3 += a2(e3, -(c3 - d3));
                0 < d3 && (f3.y -= d3);
                return d3;
              }
              e3 = p(b3);
              d3 = g2(b3, e3);
              if (d3 >= c3) return f3.y += c3, c3;
              if (b3 == H.length - 1) return 0 < d3 && (f3.y += d3), d3;
              d3 += a2(e3, c3 - d3);
              0 < d3 && (f3.y += d3);
              return d3;
            }
            function b2() {
              var a3, d3, e3, f3, h3 = 0, q3;
              f3 = (P2 - $ + 2 * u3) / l2;
              q3 = l2;
              for (var k3, g3 = 1; g3 < q3; g3++) {
                e3 = g3 * f3;
                for (var m3 = I.length - 1; 0 <= m3; m3--) !I[m3].isDirty && (I[m3].textBlock.y < e3 && I[m3].textBlock.y + I[m3].height > e3) && (k3 = p(m3), !(k3 >= I.length - 1) && I[m3].textBlock.y + I[m3].height + fa3 > I[k3].textBlock.y && (I[m3].textBlock.y = I[m3].textBlock.y + I[m3].height - e3 > e3 - I[m3].textBlock.y ? e3 + 1 : e3 - I[m3].height - 1));
              }
              for (k3 = H.length - 1; 0 < k3; k3--) if (!I[k3].isDirty) {
                e3 = n(k3);
                if (0 > e3 && (e3 = 0, I[e3].isDirty)) break;
                if (I[k3].textBlock.y < I[e3].textBlock.y + I[e3].height) {
                  d3 = d3 || k3;
                  f3 = k3;
                  for (q3 = 0; I[f3].textBlock.y < I[e3].textBlock.y + I[e3].height + fa3; ) {
                    a3 = a3 || I[f3].textBlock.y + I[f3].height;
                    q3 += I[f3].height;
                    q3 += fa3;
                    f3 = e3;
                    if (0 >= f3) {
                      f3 = 0;
                      q3 += I[f3].height;
                      break;
                    }
                    e3 = n(f3);
                    if (0 > e3) {
                      f3 = 0;
                      q3 += I[f3].height;
                      break;
                    }
                  }
                  if (f3 != k3) {
                    h3 = I[f3].textBlock.y;
                    a3 -= h3;
                    a3 = q3 - a3;
                    h3 = c2(a3, d3, f3);
                    break;
                  }
                }
              }
              return h3;
            }
            function c2(a3, b3, d3) {
              var e3 = [], f3 = 0, h3 = 0;
              for (a3 = Math.abs(a3); d3 <= b3; d3++) e3.push(H[d3]);
              e3.sort(function(a4, b4) {
                return a4.height - b4.height;
              });
              for (d3 = 0; d3 < e3.length; d3++) if (b3 = e3[d3], f3 < a3) h3++, f3 += I[b3.id].height + fa3, I[b3.id].textBlock.text = "", I[b3.id].indexLabelText = "", I[b3.id].isDirty = true, I[b3.id].textBlock.measureText();
              else break;
              return h3;
            }
            for (var d2, e2, f2, h2, q2, k2, l2 = 1, m2 = 0; m2 < 2 * l2; m2++) {
              for (var s2 = I.length - 1; 0 <= s2 && !(0 <= n(s2) && n(s2), f2 = I[s2], h2 = f2.textBlock, k2 = (q2 = p(s2) < H.length ? I[p(s2)] : null) ? q2.textBlock : null, d2 = +f2.height.toFixed(6), e2 = +h2.y.toFixed(6), !f2.isDirty && (q2 && e2 + d2 + fa3 > +k2.y.toFixed(6)) && (d2 = h2.y + d2 + fa3 - k2.y, e2 = a2(s2, -d2), e2 < d2 && (0 < e2 && (d2 -= e2), e2 = a2(p(s2), d2), e2 != d2))); s2--) ;
              b2();
            }
          }
          function g2(a2, b2) {
            return (b2 < H.length ? I[b2].textBlock.y : s.reversed ? S + u3 : Y2 + u3) - (0 > a2 ? s.reversed ? Y2 - u3 : S - u3 : I[a2].textBlock.y + I[a2].height + fa3);
          }
          function t2(a2, b2, c2) {
            var d2, e2, h2, q2 = [], g3 = u3, l2 = [];
            -1 !== b2 && (0 <= W2.indexOf(b2) ? (e2 = W2.indexOf(b2), W2.splice(
              e2,
              1
            )) : (W2.push(b2), W2 = W2.sort(function(a3, b3) {
              return a3 - b3;
            })));
            if (0 === W2.length) q2 = ia3;
            else {
              e2 = u3 * (1 != W2.length || 0 != W2[0] && W2[0] != H.length - 1 ? 2 : 1) / k();
              for (var n2 = 0; n2 < H.length; n2++) {
                if (1 == W2.length && 0 == W2[0]) {
                  if (0 === n2) {
                    q2.push(ia3[n2]);
                    d2 = g3;
                    continue;
                  }
                } else 0 === n2 && (d2 = -1 * g3);
                q2.push(ia3[n2] + d2);
                if (0 <= W2.indexOf(n2) || n2 < H.length && 0 <= W2.indexOf(n2 + 1)) d2 += e2;
              }
            }
            h2 = function() {
              for (var a3 = [], b3 = 0; b3 < H.length; b3++) a3.push(q2[b3] - H[b3].y1);
              return a3;
            }();
            var p2 = { startTime: (/* @__PURE__ */ new Date()).getTime(), duration: c2 || 500, easingFunction: function(a3, b3, c3, d3) {
              return O.easing.easeOutQuart(
                a3,
                b3,
                c3,
                d3
              );
            }, changeSection: function(a3) {
              for (var b3, c3, d3 = 0; d3 < H.length; d3++) b3 = h2[d3], c3 = H[d3], b3 *= a3, "undefined" === typeof l2[d3] && (l2[d3] = 0), 0 > l2 && (l2 *= -1), c3.y1 += b3 - l2[d3], c3.y2 += b3 - l2[d3], c3.y3 += b3 - l2[d3], c3.y4 += b3 - l2[d3], c3.y5 && (c3.y5 += b3 - l2[d3], c3.y6 += b3 - l2[d3]), l2[d3] = b3;
            } };
            a2._animator.animate(0, c2, function(c3) {
              var d3 = a2.plotArea.ctx || a2.ctx;
              ha3 = true;
              d3.clearRect(v.x1, v.y1, v.x2 - v.x1, v.y2 - v.y1);
              d3.fillStyle = a2.backgroundColor;
              d3.fillRect(v.x1, v.y1, v.width, v.height);
              p2.changeSection(c3, b2);
              var e3 = {};
              e3.dataSeries = s;
              e3.dataPoint = s.reversed ? s.dataPoints[x.length - 1 - b2] : s.dataPoints[b2];
              e3.index = s.reversed ? x.length - 1 - b2 : b2;
              a2.toolTip.highlightObjects([e3]);
              for (e3 = 0; e3 < H.length; e3++) qa2(d3, H[e3], s.fillOpacity);
              A(d3);
              L && ("inside" !== s.indexLabelPlacement ? m(d3) : f(), y(d3));
              1 <= c3 && (ha3 = false);
            }, null, O.easing.easeOutQuart);
          }
          function k() {
            for (var a2 = 0, b2 = 0; b2 < H.length - 1; b2++) (0 <= W2.indexOf(b2) || 0 <= W2.indexOf(b2 + 1)) && a2++;
            return a2;
          }
          function m(a2) {
            for (var b2, c2, d2, e2, f2 = 0; f2 < H.length; f2++) e2 = 1 === I[f2].lineThickness % 2 ? 0.5 : 0, c2 = ((H[f2].y2 + H[f2].y4) / 2 << 0) + e2, b2 = h(c2).x2 - 1, isNaN(b2) && (Math.round(H[f2].x1) === Math.round(H[f2].x4) && Math.round(H[f2].x2) === Math.round(H[f2].x3)) && (b2 = H[f2].x2), d2 = I[f2].textBlock.x, e2 = (I[f2].textBlock.y + I[f2].height / 2 << 0) + e2, I[f2].isDirty || 0 == I[f2].lineThickness || (a2.strokeStyle = I[f2].lineColor, a2.lineWidth = I[f2].lineThickness, a2.setLineDash && a2.setLineDash(K(I[f2].lineDashType, I[f2].lineThickness)), a2.beginPath(), a2.moveTo(b2, c2), a2.lineTo(d2, e2), a2.stroke());
          }
          function n(a2) {
            for (a2 -= 1; -1 <= a2 && -1 != a2 && I[a2].isDirty; a2--) ;
            return a2;
          }
          function p(a2) {
            for (a2 += 1; a2 <= H.length && a2 != H.length && I[a2].isDirty; a2++) ;
            return a2;
          }
          function h(a2) {
            for (var b2, c2 = 0; c2 < x.length; c2++) if (H[c2].y1 < a2 && H[c2].y4 > a2) {
              b2 = H[c2];
              break;
            }
            return b2 ? (a2 = b2.y6 ? a2 > b2.y6 ? b2.x3 + (b2.x4 - b2.x3) / (b2.y4 - b2.y3) * (a2 - b2.y3) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a2 - b2.y2) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a2 - b2.y2), { x1: a2, x2: a2 }) : -1;
          }
          function y(a2) {
            for (var b2 = 0; b2 < H.length; b2++) I[b2].isDirty || (a2 && (I[b2].textBlock.ctx = a2), I[b2].textBlock.y += I[b2].textBlock._lineHeight / 2, I[b2].textBlock.render(true), I[b2].textBlock.y -= I[b2].textBlock._lineHeight / 2);
          }
          function A(a2) {
            z.plotArea.layoutManager.reset();
            a2.roundRect || ya(a2);
            z.title && (z.title.dockInsidePlotArea || "center" === z.title.horizontalAlign && "center" === z.title.verticalAlign) && (z.title.ctx = a2, z.title.render());
            if (z.subtitles) for (var b2 = 0; b2 < z.subtitles.length; b2++) {
              var c2 = z.subtitles[b2];
              if (c2.dockInsidePlotArea || "center" === c2.horizontalAlign && "center" === c2.verticalAlign) z.subtitles.ctx = a2, c2.render();
            }
            z.legend && (z.legend.dockInsidePlotArea || "center" === z.legend.horizontalAlign && "center" === z.legend.verticalAlign) && (z.legend.ctx = a2, z.legend.setLayout(), z.legend.render());
            ta.fNg && ta.fNg(z);
          }
          var z = this;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            for (var s = this.data[a.dataSeriesIndexes[0]], x = s.dataPoints, v = this.plotArea, u3 = 0.025 * v.width, B2 = 0.01 * v.width, C3 = 0, E = v.height - 2 * u3 - 4, F3 = Math.min(v.width - 2 * B2, 2.8 * v.height), L = false, N = 0; N < x.length; N++) if (!L && ("undefined" !== typeof x[N].indexLabel && null !== x[N].indexLabel && 0 < x[N].indexLabel.toString().length) && (L = true), !L && ("undefined" !== typeof x[N].label && null !== x[N].label && 0 < x[N].label.toString().length) && (L = true), !L && "function" === typeof s.indexLabelFormatter || "function" === typeof x[N].indexLabelFormatter) L = true;
            L = L || "undefined" !== typeof s.indexLabel && null !== s.indexLabel && 0 < s.indexLabel.toString().length;
            "inside" !== s.indexLabelPlacement && L || (B2 = (v.width - 0.75 * F3) / 2);
            var N = v.x1 + B2, Z = v.x2 - B2, $ = v.y1 + u3 + 2, P2 = v.y2 - u3 - 2, Q3 = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;
            if (0 != s.length && (s.dataPoints && s.visible) && 0 !== x.length) {
              var M2, G;
              a = 75 * F3 / 100;
              var U2 = 30 * (Z - a) / 100;
              "funnel" === s.type ? (M2 = l(s.options.neckHeight) ? 0.35 * E : s.neckHeight, G = l(s.options.neckWidth) ? 0.25 * a : s.neckWidth, "string" === typeof M2 && M2.match(/%$/) ? (M2 = parseInt(M2), M2 = M2 * E / 100) : M2 = parseInt(M2), "string" === typeof G && G.match(/%$/) ? (G = parseInt(G), G = G * a / 100) : G = parseInt(G), M2 > E ? M2 = E : 0 >= M2 && (M2 = 0), G > a ? G = a - 0.5 : 0 >= G && (G = 0)) : "pyramid" === s.type && (G = M2 = 0, s.reversed = s.reversed ? false : true);
              var B2 = N + a / 2, V2 = N, T2 = N + a, S = s.reversed ? P2 : $, aa = B2 - G / 2, X2 = B2 + G / 2, va = s.reversed ? $ + M2 : P2 - M2, Y2 = s.reversed ? $ : P2;
              G = s.valueRepresents = s.valueRepresents ? s.valueRepresents : "height";
              N = [];
              a = [];
              var H = [], B2 = [], ba3 = $, ea2, da3 = (va - S) / (aa - V2), ga3 = -da3, F3 = "area" === G ? c() : e();
              if (-1 !== F3) {
                if (s.reversed) for (B2.push(ba3), G = F3.length - 1; 0 < G; G--) ba3 += F3[G], B2.push(Math.round(ba3));
                else for (G = 0; G < F3.length; G++) ba3 += F3[G], B2.push(Math.round(ba3));
                if (s.reversed) for (G = 0; G < F3.length; G++) B2[G] < va ? (N.push(aa), a.push(X2), ea2 = G) : (N.push((B2[G] - S + da3 * V2) / da3), a.push((B2[G] - S + ga3 * T2) / ga3));
                else for (G = 0; G < F3.length; G++) B2[G] < va ? (N.push((B2[G] - S + da3 * V2) / da3), a.push((B2[G] - S + ga3 * T2) / ga3), ea2 = G) : (N.push(aa), a.push(X2));
                for (G = 0; G < F3.length - 1; G++) ba3 = s.reversed ? x[x.length - 1 - G].color ? x[x.length - 1 - G].color : s._colorSet[(x.length - 1 - G) % s._colorSet.length] : x[G].color ? x[G].color : s._colorSet[G % s._colorSet.length], G === ea2 ? H.push({
                  x1: N[G],
                  y1: B2[G],
                  x2: a[G],
                  y2: B2[G],
                  x3: X2,
                  y3: va,
                  x4: a[G + 1],
                  y4: B2[G + 1],
                  x5: N[G + 1],
                  y5: B2[G + 1],
                  x6: aa,
                  y6: va,
                  id: G,
                  height: B2[G + 1] - B2[G],
                  color: ba3
                }) : H.push({ x1: N[G], y1: B2[G], x2: a[G], y2: B2[G], x3: a[G + 1], y3: B2[G + 1], x4: N[G + 1], y4: B2[G + 1], id: G, height: B2[G + 1] - B2[G], color: ba3 }), s.dataPointEOs[G] && H[G] && (s.dataPointEOs[G].sectionsofFunnel = H[G]);
                var fa3 = 2, I = [], ha3 = false, W2 = [], ia3 = [], N = false;
                a = a = 0;
                Ca(W2);
                for (G = 0; G < x.length; G++) x[G].exploded && (N = true, s.reversed ? W2.push(x.length - 1 - G) : W2.push(G));
                Q3.clearRect(v.x1, v.y1, v.width, v.height);
                Q3.fillStyle = z.backgroundColor;
                Q3.fillRect(v.x1, v.y1, v.width, v.height);
                if (L && s.visible && (b(), f(), "inside" !== s.indexLabelPlacement)) {
                  d();
                  q();
                  for (G = 0; G < x.length; G++) I[G].isDirty || (a = I[G].textBlock.x + I[G].width, a = (Z - a) / 2, 0 == G && (C3 = a), C3 > a && (C3 = a));
                  for (G = 0; G < H.length; G++) H[G].x1 += C3, H[G].x2 += C3, H[G].x3 += C3, H[G].x4 += C3, H[G].x5 && (H[G].x5 += C3, H[G].x6 += C3), I[G].textBlock.x += C3;
                }
                for (G = 0; G < H.length; G++) C3 = H[G], qa2(Q3, C3, s.fillOpacity), ia3.push(C3.y1);
                A(Q3);
                L && s.visible && ("inside" === s.indexLabelPlacement || z.animationEnabled || m(Q3), z.animationEnabled || y());
                if (!L) for (G = 0; G < x.length; G++) C3 = s.dataPointIds[G], a = { id: C3, objectType: "dataPoint", dataPointIndex: G, dataSeriesIndex: 0, funnelSection: H[s.reversed ? x.length - 1 - G : G] }, z._eventManager.objectMap[C3] = a;
                !z.animationEnabled && N ? t2(z, -1, 0) : z.animationEnabled && !z.animatedRender && t2(z, -1, 0);
                this.funnelPyramidClickHandler = function(a2) {
                  var b2 = -1;
                  if (!ha3 && !z.isAnimating && (l(a2.dataSeries.explodeOnClick) || a2.dataSeries.explodeOnClick) && (b2 = s.reversed ? x.length - 1 - a2.dataPointIndex : a2.dataPointIndex, 0 <= b2)) {
                    a2 = b2;
                    if ("funnel" === s.type || "pyramid" === s.type) s.reversed ? x[x.length - 1 - a2].exploded = x[x.length - 1 - a2].exploded ? false : true : x[a2].exploded = x[a2].exploded ? false : true;
                    t2(z, b2, 500);
                  }
                };
                return { source: Q3, dest: this.plotArea.ctx, animationCallback: function(a2, b2) {
                  O.fadeInAnimation(a2, b2);
                  1 <= a2 && (t2(z, -1, 500), A(z.plotArea.ctx || z.ctx));
                }, easingFunction: O.easing.easeInQuad, animationBase: 0 };
              }
            }
          }
        };
        t.prototype.requestAnimFrame = function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
            window.setTimeout(a, 1e3 / 60);
          };
        }();
        t.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
        t.prototype.set = function(a, e, c) {
          c = "undefined" === typeof c ? true : c;
          "options" === a ? (this.options = e, c && this.render()) : t.base.set.call(this, a, e, c);
        };
        t.prototype.exportChart = function(a) {
          a = "undefined" === typeof a ? {} : a;
          var e = a.format ? a.format : "png", c = a.fileName ? a.fileName : this.exportFileName;
          if (a.toDataURL) return this.canvas.toDataURL("image/" + e);
          var b = this.canvas;
          if (b && e && c) {
            c = c + "." + e;
            a = "image/" + e;
            var b = b.toDataURL(a), d = false, f = document.createElement("a");
            f.download = c;
            f.href = b;
            if ("undefined" !== typeof Blob && new Blob()) {
              for (var q = b.replace(/^data:[a-z\/]*;base64,/, ""), q = atob(q), g2 = new ArrayBuffer(q.length), g2 = new Uint8Array(g2), l2 = 0; l2 < q.length; l2++) g2[l2] = q.charCodeAt(l2);
              e = new Blob([g2.buffer], { type: "image/" + e });
              try {
                window.navigator.msSaveBlob(e, c), d = true;
              } catch (k) {
                f.dataset.downloadurl = [a, f.download, f.href].join(":"), f.href = window.URL.createObjectURL(e);
              }
            }
            if (!d) try {
              event = document.createEvent("MouseEvents"), event.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null), f.dispatchEvent ? f.dispatchEvent(event) : f.fireEvent && f.fireEvent("onclick");
            } catch (m) {
              e = window.open(), e.document.write("<img src='" + b + "'></img><div>Please right click on the image and save it to your device</div>"), e.document.close();
            }
          }
        };
        t.prototype.print = function() {
          var a = this.exportChart({ toDataURL: true }), e = document.createElement("iframe");
          e.setAttribute("class", "canvasjs-chart-print-frame");
          P(e, { position: "absolute", width: "100%", border: "0px", margin: "0px 0px 0px 0px", padding: "0px 0px 0px 0px" });
          e.style.height = this.height + "px";
          this._canvasJSContainer.appendChild(e);
          var c = this, b = e.contentWindow || e.contentDocument.document || e.contentDocument;
          b.document.open();
          b.document.write('<!DOCTYPE HTML>\n<html><body><img src="' + a + '"/><body/></html>');
          b.document.body && b.document.body.style && (b.document.body.style.margin = "0px 0px 0px 0px", b.document.body.style.padding = "0px 0px 0px 0px");
          b.document.close();
          setTimeout(function() {
            b.focus();
            b.print();
            setTimeout(function() {
              c._canvasJSContainer.removeChild(e);
            }, 1e3);
          }, 500);
        };
        t.prototype.getPercentAndTotal = function(a, e) {
          var c = null, b = null, d = c = null;
          if (0 <= a.type.indexOf("stacked")) b = 0, c = e.x.getTime ? e.x.getTime() : e.x, c in a.plotUnit.yTotals && (b = a.plotUnit.yTotals[c], c = a.plotUnit.yAbsTotals[c], d = isNaN(e.y) ? 0 : 0 === c ? 0 : 100 * (e.y / c));
          else if ("pie" === a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type) {
            for (c = b = 0; c < a.dataPoints.length; c++) isNaN(a.dataPoints[c].y) || (b += a.dataPoints[c].y);
            d = isNaN(e.y) ? 0 : 100 * (e.y / b);
          }
          return { percent: d, total: b };
        };
        t.prototype.replaceKeywordsWithValue = function(a, e, c, b, d) {
          var f = this;
          d = "undefined" === typeof d ? 0 : d;
          if ((0 <= c.type.indexOf("stacked") || "pie" === c.type || "doughnut" === c.type || "funnel" === c.type || "pyramid" === c.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) {
            var q = "#percent", g2 = "#total", l2 = this.getPercentAndTotal(c, e), g2 = isNaN(l2.total) ? g2 : l2.total, q = isNaN(l2.percent) ? q : l2.percent;
            do {
              l2 = "";
              if (c.percentFormatString) l2 = c.percentFormatString;
              else {
                var l2 = "#,##0.", k = Math.max(Math.ceil(Math.log(1 / Math.abs(q)) / Math.LN10), 2);
                if (isNaN(k) || !isFinite(k)) k = 2;
                for (var m = 0; m < k; m++) l2 += "#";
                c.percentFormatString = l2;
              }
              a = a.replace("#percent", ea(q, l2, f._cultureInfo));
              a = a.replace("#total", ea(g2, c.yValueFormatString ? c.yValueFormatString : "#,##0.########", f._cultureInfo));
            } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"));
          }
          return a.replace(
            /\{.*?\}|"[^"]*"|'[^']*'/g,
            function(a2) {
              if ('"' === a2[0] && '"' === a2[a2.length - 1] || "'" === a2[0] && "'" === a2[a2.length - 1]) return a2.slice(1, a2.length - 1);
              a2 = Fa(a2.slice(1, a2.length - 1));
              a2 = a2.replace("#index", d);
              var q2 = null;
              try {
                var h = a2.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
                h && 0 < h.length && (q2 = Fa(h[2]), a2 = Fa(h[1]));
              } catch (k2) {
              }
              h = null;
              if ("color" === a2) return "waterfall" === c.type ? e.color ? e.color : 0 < e.y ? c.risingColor : c.fallingColor : "error" === c.type ? c.color ? c.color : c._colorSet[q2 % c._colorSet.length] : e.color ? e.color : c.color ? c.color : c._colorSet[b % c._colorSet.length];
              if (e.hasOwnProperty(a2)) h = e;
              else if (c.hasOwnProperty(a2)) h = c;
              else return "";
              h = h[a2];
              null !== q2 && (h = h[q2]);
              return "x" === a2 ? (c.axisX && "dateTime" === c.axisX.valueType || "dateTime" === c.xValueType || e.x && e.x.getTime) && !c.axisX.logarithmic ? Ba(h, e.xValueFormatString ? e.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : c.xValueFormatString = f.axisX && f.axisX.autoValueFormatString ? f.axisX.autoValueFormatString : "DD MMM YY", f._cultureInfo) : ea(h, e.xValueFormatString ? e.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : c.xValueFormatString = "#,##0.########", f._cultureInfo) : "y" === a2 ? ea(h, e.yValueFormatString ? e.yValueFormatString : c.yValueFormatString ? c.yValueFormatString : c.yValueFormatString = "#,##0.########", f._cultureInfo) : "z" === a2 ? ea(h, e.zValueFormatString ? e.zValueFormatString : c.zValueFormatString ? c.zValueFormatString : c.zValueFormatString = "#,##0.########", f._cultureInfo) : h;
            }
          );
        };
        oa(F2, U);
        F2.prototype.setLayout = function() {
          var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, e = a.layoutManager.getFreeSpace(), c = null, b = 0, d = 0, f = 0, q = 0, g2 = this.markerMargin = this.chart.options.legend && !l(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;
          this.height = 0;
          var t2 = [], k = [];
          if ("top" === this.verticalAlign || "bottom" === this.verticalAlign) this.orientation = "horizontal", c = this.verticalAlign, f = this.maxWidth = null !== this.maxWidth ? this.maxWidth : e.width, q = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * e.height;
          else if ("center" === this.verticalAlign) {
            this.orientation = "vertical";
            if ("left" === this.horizontalAlign || "center" === this.horizontalAlign || "right" === this.horizontalAlign) c = this.horizontalAlign;
            f = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * e.width;
            q = this.maxHeight = null !== this.maxHeight ? this.maxHeight : e.height;
          }
          this.errorMarkerColor = [];
          for (var m = 0; m < this.dataSeries.length; m++) {
            var n = this.dataSeries[m];
            if (n.dataPoints && n.dataPoints.length) {
              if ("pie" !== n.type && "doughnut" !== n.type && "funnel" !== n.type && "pyramid" !== n.type) {
                var p = n.legendMarkerType = n.legendMarkerType ? n.legendMarkerType : "line" !== n.type && "stepLine" !== n.type && "spline" !== n.type && "scatter" !== n.type && "bubble" !== n.type || !n.markerType ? "error" === n.type && n._linkedSeries ? n._linkedSeries.legendMarkerType ? n._linkedSeries.legendMarkerType : Q2.getDefaultLegendMarker(n._linkedSeries.type) : Q2.getDefaultLegendMarker(n.type) : n.markerType, h = n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: n, dataPoint: null }) : n.name, y = n.legendMarkerColor = n.legendMarkerColor ? n.legendMarkerColor : n.markerColor ? n.markerColor : "error" === n.type ? l(n.whiskerColor) ? n._colorSet[0] : n.whiskerColor : n._colorSet[0], r2 = n.markerSize || "line" !== n.type && "stepLine" !== n.type && "spline" !== n.type ? 0.75 * this.lineHeight : 0, u3 = n.legendMarkerBorderColor ? n.legendMarkerBorderColor : n.markerBorderColor, s = n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : n.markerBorderThickness ? Math.max(1, Math.round(0.2 * r2)) : 0;
                "error" === n.type && this.errorMarkerColor.push(y);
                h = n.legendText = this.chart.replaceKeywordsWithValue(h, n.dataPoints[0], n, m);
                p = {
                  markerType: p,
                  markerColor: y,
                  text: h,
                  textBlock: null,
                  chartType: n.type,
                  markerSize: r2,
                  lineColor: n._colorSet[0],
                  dataSeriesIndex: n.index,
                  dataPointIndex: null,
                  markerBorderColor: u3,
                  markerBorderThickness: s
                };
                t2.push(p);
              } else for (var x = 0; x < n.dataPoints.length; x++) {
                var v = n.dataPoints[x], p = v.legendMarkerType ? v.legendMarkerType : n.legendMarkerType ? n.legendMarkerType : Q2.getDefaultLegendMarker(n.type), h = v.legendText ? v.legendText : v.name ? v.name : n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                  chart: this.chart,
                  legend: this.options,
                  dataSeries: n,
                  dataPoint: v
                }) : v.name ? v.name : "DataPoint: " + (x + 1), y = v.legendMarkerColor ? v.legendMarkerColor : n.legendMarkerColor ? n.legendMarkerColor : v.color ? v.color : n.color ? n.color : n._colorSet[x % n._colorSet.length], r2 = 0.75 * this.lineHeight, u3 = v.legendMarkerBorderColor ? v.legendMarkerBorderColor : n.legendMarkerBorderColor ? n.legendMarkerBorderColor : v.markerBorderColor ? v.markerBorderColor : n.markerBorderColor, s = v.legendMarkerBorderThickness ? v.legendMarkerBorderThickness : n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : v.markerBorderThickness || n.markerBorderThickness ? Math.max(1, Math.round(0.2 * r2)) : 0, h = this.chart.replaceKeywordsWithValue(h, v, n, x), p = { markerType: p, markerColor: y, text: h, textBlock: null, chartType: n.type, markerSize: r2, dataSeriesIndex: m, dataPointIndex: x, markerBorderColor: u3, markerBorderThickness: s };
                (v.showInLegend || n.showInLegend && false !== v.showInLegend) && t2.push(p);
              }
              l(n.legendText) && (n.legendText = n.name);
            }
          }
          true === this.reversed && t2.reverse();
          if (0 < t2.length) {
            n = null;
            h = v = x = 0;
            v = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, f) : this.itemMaxWidth = Math.min(this.itemWidth, f) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, f) : this.itemMaxWidth = f;
            r2 = 0 === r2 ? 0.75 * this.lineHeight : r2;
            v = (this.itemMaxWidth ? this.itemMaxWidth : v) - (r2 + g2);
            for (m = 0; m < t2.length; m++) {
              p = t2[m];
              y = v;
              if ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType) y -= 2 * 0.1 * this.lineHeight;
              if (!(0 >= q || "undefined" === typeof q || 0 >= y || "undefined" === typeof y)) if ("horizontal" === this.orientation) {
                p.textBlock = new ja(
                  this.ctx,
                  { x: 0, y: 0, maxWidth: y, maxHeight: this.itemWrap ? q : this.lineHeight, angle: 0, text: p.text, textAlign: this.itemTextAlign, fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }
                );
                p.textBlock.measureText();
                null !== this.itemWidth && (p.textBlock.width = this.itemWidth - (r2 + g2 + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? 2 * 0.1 * this.lineHeight : 0)));
                if (!n || n.width + Math.round(p.textBlock.width + r2 + g2 + (0 === n.width ? 0 : this.horizontalSpacing) + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? 2 * 0.1 * this.lineHeight : 0)) > f) n = { items: [], width: 0 }, k.push(n), this.height += h, h = 0;
                h = Math.max(h, p.textBlock.height ? p.textBlock.height : this.lineHeight);
                p.textBlock.x = n.width;
                p.textBlock.y = 0;
                n.width += Math.round(p.textBlock.width + r2 + g2 + (0 === n.width ? 0 : this.horizontalSpacing) + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? 2 * 0.1 * this.lineHeight : 0));
                n.items.push(p);
                this.width = Math.max(
                  n.width,
                  this.width
                );
              } else p.textBlock = new ja(this.ctx, { x: 0, y: 0, maxWidth: v, maxHeight: true === this.itemWrap ? q : 1.5 * this.fontSize, angle: 0, text: p.text, textAlign: this.itemTextAlign, fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }), p.textBlock.measureText(), null !== this.itemWidth && (p.textBlock.width = this.itemWidth - (r2 + g2 + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < q - this.lineHeight ? (n = { items: [], width: 0 }, k.push(n)) : (n = k[x], x = (x + 1) % k.length), n && (this.height += p.textBlock.height ? p.textBlock.height : this.lineHeight, p.textBlock.x = n.width, p.textBlock.y = 0, n.width += Math.round(p.textBlock.width + r2 + g2 + (0 === n.width ? 0 : this.horizontalSpacing) + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? 2 * 0.1 * this.lineHeight : 0)), n.items.push(p), this.width = Math.max(n.width, this.width));
            }
            this.height = false === this.itemWrap ? k.length * this.lineHeight : this.height + h;
            this.height = Math.min(q, this.height);
            this.width = Math.min(f, this.width);
          }
          "top" === this.verticalAlign ? (d = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, b = e.y1) : "center" === this.verticalAlign ? (d = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, b = e.y1 + e.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (d = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, b = e.y2 - this.height);
          this.items = t2;
          for (m = 0; m < this.items.length; m++) p = t2[m], p.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[p.id] = { id: p.id, objectType: "legendItem", legendItemIndex: m, dataSeriesIndex: p.dataSeriesIndex, dataPointIndex: p.dataPointIndex };
          this.markerSize = r2;
          this.rows = k;
          0 < t2.length && a.layoutManager.registerSpace(c, { width: this.width + 2 + 2, height: this.height + 5 + 5 });
          this.bounds = { x1: d, y1: b, x2: d + this.width, y2: b + this.height };
        };
        F2.prototype.render = function() {
          var a = this.bounds.x1, e = this.bounds.y1, c = this.markerMargin, b = this.maxWidth, d = this.maxHeight, f = this.markerSize, q = this.rows;
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(a, e, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
          for (var g2 = 0, l2 = 0; l2 < q.length; l2++) {
            for (var k = q[l2], m = 0, n = 0; n < k.items.length; n++) {
              var p = k.items[n], h = p.textBlock.x + a + (0 === n ? 0.2 * f : this.horizontalSpacing), t2 = e + g2, r2 = h;
              this.chart.data[p.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(a, e, b, Math.max(d - d % this.lineHeight, 0));
              this.ctx.clip();
              if ("line" === p.chartType || "stepLine" === p.chartType || "spline" === p.chartType) this.ctx.strokeStyle = p.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(h - 0.1 * this.lineHeight, t2 + this.lineHeight / 2), this.ctx.lineTo(h + 0.85 * this.lineHeight, t2 + this.lineHeight / 2), this.ctx.stroke(), r2 -= 0.1 * this.lineHeight;
              if ("error" === p.chartType) {
                this.ctx.strokeStyle = this.errorMarkerColor[0];
                this.ctx.lineWidth = f / 8;
                this.ctx.beginPath();
                var u3 = h - 0.08 * this.lineHeight + 0.1 * this.lineHeight, s = t2 + 0.15 * this.lineHeight, x = 0.7 * this.lineHeight, v = x + 0.02 * this.lineHeight;
                this.ctx.moveTo(u3, s);
                this.ctx.lineTo(u3 + x, s);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(u3 + x / 2, s);
                this.ctx.lineTo(u3 + x / 2, s + v);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(u3, s + v);
                this.ctx.lineTo(u3 + x, s + v);
                this.ctx.stroke();
                this.errorMarkerColor.shift();
              }
              X.drawMarker(
                h + f / 2,
                t2 + this.lineHeight / 2,
                this.ctx,
                p.markerType,
                "error" === p.chartType || "line" === p.chartType || "spline" === p.chartType ? p.markerSize / 2 : p.markerSize,
                p.markerColor,
                p.markerBorderColor,
                p.markerBorderThickness
              );
              p.textBlock.x = h + c + f;
              if ("line" === p.chartType || "stepLine" === p.chartType || "spline" === p.chartType) p.textBlock.x += 0.1 * this.lineHeight;
              p.textBlock.y = Math.round(t2 + this.lineHeight / 2);
              p.textBlock.render(true);
              this.ctx.restore();
              m = 0 < n ? Math.max(m, p.textBlock.height ? p.textBlock.height : this.lineHeight) : p.textBlock.height ? p.textBlock.height : this.lineHeight;
              this.chart.data[p.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);
              h = T(p.id);
              this.ghostCtx.fillStyle = h;
              this.ghostCtx.beginPath();
              this.ghostCtx.fillRect(r2, p.textBlock.y - this.lineHeight / 2, p.textBlock.x + p.textBlock.width - r2, p.textBlock.height ? p.textBlock.height : this.lineHeight);
              p.x1 = this.chart._eventManager.objectMap[p.id].x1 = r2;
              p.y1 = this.chart._eventManager.objectMap[p.id].y1 = p.textBlock.y - this.lineHeight / 2;
              p.x2 = this.chart._eventManager.objectMap[p.id].x2 = p.textBlock.x + p.textBlock.width;
              p.y2 = this.chart._eventManager.objectMap[p.id].y2 = p.textBlock.y + (p.textBlock.height ? p.textBlock.height : this.lineHeight) - this.lineHeight / 2;
            }
            g2 += m;
          }
        };
        oa(Q2, U);
        Q2.prototype.getDefaultAxisPlacement = function() {
          var a = this.type;
          if ("column" === a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "normal";
          if ("bar" === a || "stackedBar" === a || "stackedBar100" === a || "rangeBar" === a) return "xySwapped";
          if ("pie" === a || "doughnut" === a || "funnel" === a || "pyramid" === a) return "none";
          "error" !== a && window.console.log("Unknown Chart Type: " + a);
          return null;
        };
        Q2.getDefaultLegendMarker = function(a) {
          if ("column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "square";
          if ("line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a) return "circle";
          if ("area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a || "funnel" === a || "pyramid" === a) return "triangle";
          if ("error" === a) return "none";
          window.console.log("Unknown Chart Type: " + a);
          return null;
        };
        Q2.prototype.getDataPointAtX = function(a, e, c) {
          if (!this.dataPoints || 0 === this.dataPoints.length) return null;
          var b = { dataPoint: null, distance: Infinity, index: NaN }, d = null, f = 0, q = 0, g2 = 1, t2 = Infinity, k = 0, m = 0, n = 0;
          "none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), n = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, n = 0 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));
          for (; ; ) {
            q = 0 < g2 ? n + f : n - f;
            if (0 <= q && q < this.dataPoints.length) {
              var d = this.dataPoints[q], p = this.axisX && this.axisX.logarithmic ? d.x > a ? d.x / a : a / d.x : Math.abs(d.x - a);
              p < b.distance && (l(c) || c && !l(d.y)) && (b.dataPoint = d, b.distance = p, b.index = q);
              d = p;
              d <= t2 ? t2 = d : 0 < g2 ? k++ : m++;
              if (1e3 < k && 1e3 < m) break;
            } else if (0 > n - f && n + f >= this.dataPoints.length) break;
            -1 === g2 ? (f++, g2 = 1) : g2 = -1;
          }
          return e || (b.dataPoint.x.getTime ? b.dataPoint.x.getTime() : b.dataPoint.x) !== (a.getTime ? a.getTime() : a) ? e && null !== b.dataPoint ? b : null : b;
        };
        Q2.prototype.getDataPointAtXY = function(a, e, c) {
          if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || e < this.chart.plotArea.y1 || e > this.chart.plotArea.y2) return null;
          c = c || false;
          var b = [], d = 0, f = 0, q = 1, g2 = false, t2 = Infinity, k = 0, m = 0, n = 0;
          if ("none" !== this.chart.plotInfo.axisPlacement) if (n = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a, y: e }), this.axisX.logarithmic) var p = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), n = 1 < p ? Math.min(Math.max((this.dataPoints.length - 1) / p * Math.log(n / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
          else p = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, n = 0 < p ? Math.min(Math.max((this.dataPoints.length - 1) / p * (n - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
          for (; ; ) {
            f = 0 < q ? n + d : n - d;
            if (0 <= f && f < this.dataPoints.length) {
              var p = this.chart._eventManager.objectMap[this.dataPointIds[f]], h = this.dataPoints[f], r2 = null;
              if (p) {
                switch (this.type) {
                  case "column":
                  case "stackedColumn":
                  case "stackedColumn100":
                  case "bar":
                  case "stackedBar":
                  case "stackedBar100":
                  case "rangeColumn":
                  case "rangeBar":
                  case "waterfall":
                  case "error":
                    a >= p.x1 && (a <= p.x2 && e >= p.y1 && e <= p.y2) && (b.push({ dataPoint: h, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(p.x1 - a), Math.abs(p.x2 - a), Math.abs(p.y1 - e), Math.abs(p.y2 - e)) }), g2 = true);
                    break;
                  case "line":
                  case "stepLine":
                  case "spline":
                  case "area":
                  case "stepArea":
                  case "stackedArea":
                  case "stackedArea100":
                  case "splineArea":
                  case "scatter":
                    var u3 = W("markerSize", h, this) || 4, z = c ? 20 : u3, r2 = Math.sqrt(Math.pow(p.x1 - a, 2) + Math.pow(p.y1 - e, 2));
                    r2 <= z && b.push({ dataPoint: h, dataPointIndex: f, dataSeries: this, distance: r2 });
                    p = Math.abs(p.x1 - a);
                    p <= t2 ? t2 = p : 0 < q ? k++ : m++;
                    r2 <= u3 / 2 && (g2 = true);
                    break;
                  case "rangeArea":
                  case "rangeSplineArea":
                    u3 = W("markerSize", h, this) || 4;
                    z = c ? 20 : u3;
                    r2 = Math.min(Math.sqrt(Math.pow(p.x1 - a, 2) + Math.pow(p.y1 - e, 2)), Math.sqrt(Math.pow(p.x1 - a, 2) + Math.pow(p.y2 - e, 2)));
                    r2 <= z && b.push({ dataPoint: h, dataPointIndex: f, dataSeries: this, distance: r2 });
                    p = Math.abs(p.x1 - a);
                    p <= t2 ? t2 = p : 0 < q ? k++ : m++;
                    r2 <= u3 / 2 && (g2 = true);
                    break;
                  case "bubble":
                    u3 = p.size;
                    r2 = Math.sqrt(Math.pow(p.x1 - a, 2) + Math.pow(p.y1 - e, 2));
                    r2 <= u3 / 2 && (b.push({
                      dataPoint: h,
                      dataPointIndex: f,
                      dataSeries: this,
                      distance: r2
                    }), g2 = true);
                    break;
                  case "pie":
                  case "doughnut":
                    u3 = p.center;
                    z = "doughnut" === this.type ? p.percentInnerRadius * p.radius : 0;
                    r2 = Math.sqrt(Math.pow(u3.x - a, 2) + Math.pow(u3.y - e, 2));
                    r2 < p.radius && r2 > z && (r2 = Math.atan2(e - u3.y, a - u3.x), 0 > r2 && (r2 += 2 * Math.PI), r2 = Number(((180 * (r2 / Math.PI) % 360 + 360) % 360).toFixed(12)), u3 = Number(((180 * (p.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), z = Number(((180 * (p.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === z && 1 < p.endAngle && (z = 360), u3 >= z && (0 !== h.y && !l(h.y)) && (z += 360, r2 < u3 && (r2 += 360)), r2 > u3 && r2 < z && (b.push({ dataPoint: h, dataPointIndex: f, dataSeries: this, distance: 0 }), g2 = true));
                    break;
                  case "funnel":
                  case "pyramid":
                    r2 = p.funnelSection;
                    e > r2.y1 && e < r2.y4 && (r2.y6 ? e > r2.y6 ? (f = r2.x6 + (r2.x5 - r2.x6) / (r2.y5 - r2.y6) * (e - r2.y6), r2 = r2.x3 + (r2.x4 - r2.x3) / (r2.y4 - r2.y3) * (e - r2.y3)) : (f = r2.x1 + (r2.x6 - r2.x1) / (r2.y6 - r2.y1) * (e - r2.y1), r2 = r2.x2 + (r2.x3 - r2.x2) / (r2.y3 - r2.y2) * (e - r2.y2)) : (f = r2.x1 + (r2.x4 - r2.x1) / (r2.y4 - r2.y1) * (e - r2.y1), r2 = r2.x2 + (r2.x3 - r2.x2) / (r2.y3 - r2.y2) * (e - r2.y2)), a > f && a < r2 && (b.push({ dataPoint: h, dataPointIndex: p.dataPointIndex, dataSeries: this, distance: 0 }), g2 = true));
                    break;
                  case "boxAndWhisker":
                    if (a >= p.x1 - p.borderThickness / 2 && a <= p.x2 + p.borderThickness / 2 && e >= p.y4 - p.borderThickness / 2 && e <= p.y1 + p.borderThickness / 2 || Math.abs(p.x2 - a + p.x1 - a) < p.borderThickness && e >= p.y1 && e <= p.y4) b.push({ dataPoint: h, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(p.x1 - a), Math.abs(p.x2 - a), Math.abs(p.y2 - e), Math.abs(p.y3 - e)) }), g2 = true;
                    break;
                  case "candlestick":
                    if (a >= p.x1 - p.borderThickness / 2 && a <= p.x2 + p.borderThickness / 2 && e >= p.y2 - p.borderThickness / 2 && e <= p.y3 + p.borderThickness / 2 || Math.abs(p.x2 - a + p.x1 - a) < p.borderThickness && e >= p.y1 && e <= p.y4) b.push({ dataPoint: h, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(p.x1 - a), Math.abs(p.x2 - a), Math.abs(p.y2 - e), Math.abs(p.y3 - e)) }), g2 = true;
                    break;
                  case "ohlc":
                    if (Math.abs(p.x2 - a + p.x1 - a) < p.borderThickness && e >= p.y2 && e <= p.y3 || a >= p.x1 && a <= (p.x2 + p.x1) / 2 && e >= p.y1 - p.borderThickness / 2 && e <= p.y1 + p.borderThickness / 2 || a >= (p.x1 + p.x2) / 2 && a <= p.x2 && e >= p.y4 - p.borderThickness / 2 && e <= p.y4 + p.borderThickness / 2) b.push({ dataPoint: h, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(p.x1 - a), Math.abs(p.x2 - a), Math.abs(p.y2 - e), Math.abs(p.y3 - e)) }), g2 = true;
                }
                if (g2 || 1e3 < k && 1e3 < m) break;
              }
            } else if (0 > n - d && n + d >= this.dataPoints.length) break;
            -1 === q ? (d++, q = 1) : q = -1;
          }
          a = null;
          for (e = 0; e < b.length; e++) a ? b[e].distance <= a.distance && (a = b[e]) : a = b[e];
          return a;
        };
        Q2.prototype.getMarkerProperties = function(a, e, c, b) {
          var d = this.dataPoints, f = d[a].markerColor ? d[a].markerColor : this.markerColor ? this.markerColor : d[a].color ? d[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], q = d[a].markerBorderColor ? d[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, g2 = l(d[a].markerBorderThickness) ? this.markerBorderThickness ? this.markerBorderThickness : null : d[a].markerBorderThickness, r2 = d[a].markerType ? d[a].markerType : this.markerType;
          a = l(d[a].markerSize) ? this.markerSize : d[a].markerSize;
          return { x: e, y: c, ctx: b, type: r2, size: a, color: f, borderColor: q, borderThickness: g2 };
        };
        oa(B, U);
        B.prototype.createExtraLabelsForLog = function(a) {
          a = (a || 0) + 1;
          if (!(5 < a)) {
            var e = this.logLabelValues[0] || this.intervalStartPosition;
            if (Math.log(this.range) / Math.log(e / this.viewportMinimum) < this.noTicks - 1) {
              for (var c = B.getNiceNumber((e - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), true), b = Math.ceil(this.viewportMinimum / c) * c; b < e; b += c) b < this.viewportMinimum || this.logLabelValues.push(b);
              this.logLabelValues.sort(Qa);
              this.createExtraLabelsForLog(a);
            }
          }
        };
        B.prototype.createLabels = function() {
          var a, e, c = 0, b = 0, d, f = 0, q = 0, b = 0, b = this.interval, g2 = 0, t2, k = 0.6 * this.chart.height, m;
          a = false;
          var n = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], p = n.length ? l(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;
          if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
            d = this.viewportMaximum;
            if (this.labels) {
              a = Math.ceil(b);
              for (var b = Math.ceil(this.intervalStartPosition), h = false, c = b; c < this.viewportMaximum; c += a) if (this.labels[c]) h = true;
              else {
                h = false;
                break;
              }
              h && (this.interval = a, this.intervalStartPosition = b);
            }
            if (this.logarithmic && !this.equidistantInterval) for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), b = 0, h = p; b < this.logLabelValues.length; b++) if (c = this.logLabelValues[b], c < this.viewportMinimum) b++;
            else {
              for (; h < n.length && c > n[h].endValue; h++) ;
              a = h < n.length && c >= n[h].startValue && c <= n[h].endValue;
              m = c;
              a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : ea(m, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {
                x: 0,
                y: 0,
                maxWidth: f,
                maxHeight: q,
                angle: this.labelAngle,
                text: this.prefix + a + this.suffix,
                backgroundColor: this.labelBackgroundColor,
                borderColor: this.labelBorderColor,
                cornerRadius: this.labelCornerRadius,
                textAlign: this.labelTextAlign,
                fontSize: this.labelFontSize,
                fontFamily: this.labelFontFamily,
                fontWeight: this.labelFontWeight,
                fontColor: this.labelFontColor,
                fontStyle: this.labelFontStyle,
                textBaseline: "middle",
                borderThickness: this.labelBorderThickness,
                padding: this.labelPadding
              }), this._labels.push({ position: m, textBlock: a, effectiveHeight: null }));
            }
            h = p;
            for (c = this.intervalStartPosition; c <= d; c = parseFloat(1e-12 > this.interval ? this.logarithmic && this.equidistantInterval ? c * Math.pow(this.logarithmBase, this.interval) : c + this.interval : (this.logarithmic && this.equidistantInterval ? c * Math.pow(this.logarithmBase, this.interval) : c + this.interval).toFixed(12))) {
              for (; h < n.length && c > n[h].endValue; h++) ;
              a = h < n.length && c >= n[h].startValue && c <= n[h].endValue;
              m = c;
              a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : ea(m, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {
                x: 0,
                y: 0,
                maxWidth: f,
                maxHeight: q,
                angle: this.labelAngle,
                text: this.prefix + a + this.suffix,
                textAlign: this.labelTextAlign,
                backgroundColor: this.labelBackgroundColor,
                borderColor: this.labelBorderColor,
                borderThickness: this.labelBorderThickness,
                cornerRadius: this.labelCornerRadius,
                fontSize: this.labelFontSize,
                fontFamily: this.labelFontFamily,
                fontWeight: this.labelFontWeight,
                fontColor: this.labelFontColor,
                fontStyle: this.labelFontStyle,
                textBaseline: "middle",
                padding: this.labelPadding
              }), this._labels.push({ position: m, textBlock: a, effectiveHeight: null }));
            }
          } else for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), d = Wa(new Date(this.viewportMaximum), this.interval, this.intervalType), h = p, c = this.intervalStartPosition; c < d; Wa(c, b, this.intervalType)) {
            for (a = c.getTime(); h < n.length && a > n[h].endValue; h++) ;
            m = a;
            a = h < n.length && a >= n[h].startValue && a <= n[h].endValue;
            a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: new Date(m), label: this.labels[m] ? this.labels[m] : null }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : Ba(m, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {
              x: 0,
              y: 0,
              maxWidth: f,
              backgroundColor: this.labelBackgroundColor,
              borderColor: this.labelBorderColor,
              borderThickness: this.labelBorderThickness,
              cornerRadius: this.labelCornerRadius,
              maxHeight: q,
              angle: this.labelAngle,
              text: this.prefix + a + this.suffix,
              textAlign: this.labelTextAlign,
              fontSize: this.labelFontSize,
              fontFamily: this.labelFontFamily,
              fontWeight: this.labelFontWeight,
              fontColor: this.labelFontColor,
              fontStyle: this.labelFontStyle,
              textBaseline: "middle",
              padding: this.labelPadding
            }), this._labels.push({ position: m, textBlock: a, effectiveHeight: null, breaksLabelType: void 0 }));
          }
          if ("bottom" === this._position || "top" === this._position) g2 = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * V[this.intervalType + "Duration"] * this.interval, f = "undefined" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (q = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize + ("object" === typeof this.labelPadding ? (this.labelPadding.top || 0) + (this.labelPadding.bottom || 0) : 2 * this.labelPadding));
          else if ("left" === this._position || "right" === this._position) g2 = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * V[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (f = "undefined" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), q = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
          for (b = 0; b < this._labels.length; b++) {
            a = this._labels[b].textBlock;
            a.maxWidth = f;
            a.maxHeight = q;
            var u3 = a.measureText();
            t2 = u3.height;
          }
          d = [];
          p = n = 0;
          if (this.labelAutoFit || this.options.labelAutoFit) {
            if (l(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position) if (f = Math.floor(0.9 * g2), p = 0, !this.chart.panEnabled && 1 <= this._labels.length) {
              this.sessionVariables.labelFontSize = this.labelFontSize;
              this.sessionVariables.labelMaxWidth = f;
              this.sessionVariables.labelMaxHeight = q;
              this.sessionVariables.labelAngle = this.labelAngle;
              this.sessionVariables.labelWrap = this.labelWrap;
              for (c = 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {
                a = this._labels[c].textBlock;
                for (var A, h = a.text.split(" "), b = 0; b < h.length; b++) m = h[b], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, m = this.ctx.measureText(m), m.width > p && (A = c, p = m.width);
              }
              c = 0;
              for (c = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {
                a = this._labels[c].textBlock;
                u3 = a.measureText();
                for (h = c + 1; h < this._labels.length; h++) if (!this._labels[h].breaksLabelType) {
                  e = this._labels[h].textBlock;
                  e = e.measureText();
                  break;
                }
                d.push(a.height);
                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, d);
                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                b = f * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (q - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                if (l(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle) if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? q : Math.min((b - f * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), m = (k - (t2 + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !l(this.options.labelWrap)) this.labelWrap ? l(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(f, p), m), this.sessionVariables.labelWrap = this.labelWrap, e && u3.width + e.width >> 0 > 2 * f && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > f ? -25 : this.sessionVariables.labelAngle) : l(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelMaxWidth = f, e && u3.width + e.width >> 0 > 2 * f && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > f ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelWrap = this.labelWrap);
                else {
                  if (l(this.options.labelWrap)) {
                    if (!l(this.options.labelMaxWidth)) this.options.labelMaxWidth < f ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = q);
                    else if (!l(e)) {
                      if (b = u3.width + e.width >> 0, h = this.labelFontSize, p < f) b - 2 * f > n && (n = b - 2 * f, b >= 2 * f && b < 2.2 * f ? (this.sessionVariables.labelMaxWidth = f, l(this.options.labelFontSize) && 12 < h && (h = Math.floor(12 / 13 * h), a.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? h : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 2.2 * f && b < 2.8 * f ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = h) : b >= 2.8 * f && b < 3.2 * f ? (this.sessionVariables.labelMaxWidth = Math.max(f, p), this.sessionVariables.labelWrap = true, l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? h : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 3.2 * f && b < 3.6 * f ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = this.labelFontSize) : b > 3.6 * f && b < 5 * f ? (l(this.options.labelFontSize) && 12 < h && (h = Math.floor(12 / 13 * h), a.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? h : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m) : b > 5 * f && (this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = f, this.sessionVariables.labelFontSize = h, this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelAngle = this.labelAngle));
                      else if (A === c && (0 === A && p + this._labels[A + 1].textBlock.measureText().width - 2 * f > n || A === this._labels.length - 1 && p + this._labels[A - 1].textBlock.measureText().width - 2 * f > n || 0 < A && A < this._labels.length - 1 && p + this._labels[A + 1].textBlock.measureText().width - 2 * f > n && p + this._labels[A - 1].textBlock.measureText().width - 2 * f > n)) n = 0 === A ? p + this._labels[A + 1].textBlock.measureText().width - 2 * f : p + this._labels[A - 1].textBlock.measureText().width - 2 * f, this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? h : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m;
                      else if (0 === n) for (this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? h : this.options.labelFontSize, this.sessionVariables.labelWrap = true, b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(f, p), m), u3 = a.measureText(), b < this._labels.length - 1 && (h = b + 1, e = this._labels[h].textBlock, e.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(f, p), m), e = e.measureText(), u3.width + e.width >> 0 > 2 * f && (this.sessionVariables.labelAngle = -25));
                    }
                  }
                }
                else (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? q : Math.min((b - f * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), m = 0 != this.labelAngle ? (k - (t2 + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : f, this.sessionVariables.labelMaxHeight = this.labelWrap ? (k - m * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, l(this.options.labelWrap)) ? l(this.options.labelWrap) && (this.labelWrap && !l(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelMaxHeight = q) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelMaxHeight = Math.max(b, 0.9 * g2), this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m) : (l(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = q);
              }
              this.sessionVariables.labelMaxHeight = Math.max(this.sessionVariables.labelMaxHeight, 1.5 * this.labelFontSize);
              for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
            } else for (c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = l(this.options.labelMaxWidth) ? l(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = f : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = l(this.options.labelFontSize) ? l(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = l(this.options.labelAngle) ? l(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = l(this.options.labelWrap) ? l(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = l(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = q : this.sessionVariables.labelMaxHeight, a.measureText();
            else if ("left" === this._position || "right" === this._position) if (f = l(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, q = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
              this.sessionVariables.labelFontSize = this.labelFontSize;
              this.sessionVariables.labelMaxWidth = f;
              this.sessionVariables.labelMaxHeight = q;
              this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
              this.sessionVariables.labelWrap = this.labelWrap;
              for (c = 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {
                a = this._labels[c].textBlock;
                u3 = a.measureText();
                for (h = c + 1; h < this._labels.length; h++) if (!this._labels[h].breaksLabelType) {
                  e = this._labels[h].textBlock;
                  e = e.measureText();
                  break;
                }
                d.push(a.height);
                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, d);
                b = f * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (q - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                l(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? l(this.options.labelWrap) ? l(this.options.labelWrap) && (l(this.options.labelMaxWidth) ? l(e) || (g2 = u3.height + e.height >> 0, g2 - 2 * q > p && (p = g2 - 2 * q, g2 >= 2 * q && g2 < 2.4 * q ? (l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : g2 >= 2.4 * q && g2 < 2.8 * q ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = true) : g2 >= 2.8 * q && g2 < 3.2 * q ? (this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelWrap = true, l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : g2 >= 3.2 * q && g2 < 3.6 * q ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelWrap = true, this.sessionVariables.labelFontSize = this.labelFontSize) : g2 > 3.6 * q && g2 < 10 * q ? (l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = f, this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : g2 > 10 * q && g2 < 50 * q && (l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelMaxWidth = f, this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = q, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : f, this.sessionVariables.labelMaxHeight = q) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? f : Math.min((b - q * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), q), l(this.options.labelWrap)) ? l(this.options.labelWrap) && (this.labelWrap && !l(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : f, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? q : b, l(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? q : b, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = f) : (this.sessionVariables.labelMaxHeight = q, l(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);
              }
              for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
            } else for (l(this.chart.stockChart) || this.chart.isNavigator || (this.sessionVariables.labelMaxHeight = q), c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = l(this.options.labelMaxWidth) ? l(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = f : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = l(this.options.labelFontSize) ? l(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = l(this.options.labelAngle) ? l(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = l(this.options.labelWrap) ? l(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = l(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = q : this.sessionVariables.labelMaxHeight, a.measureText();
          }
          for (c = 0; c < this.stripLines.length; c++) {
            var f = this.stripLines[c], z;
            f.labelFontSize = "outside" === f.labelPlacement && l(f.options.labelFontSize) ? this.labelFontSize : f.labelFontSize;
            f.labelFontFamily = "outside" === f.labelPlacement && l(f.options.labelFontFamily) ? this.labelFontFamily : f.labelFontFamily;
            f.labelFontWeight = "outside" === f.labelPlacement && l(f.options.labelFontWeight) ? this.labelFontWeight : f.labelFontWeight;
            f.labelFontStyle = "outside" === f.labelPlacement && l(f.options.labelFontStyle) ? this.labelFontStyle : f.labelFontStyle;
            if ("outside" === f.labelPlacement) {
              q = this.sessionVariables.labelMaxWidth;
              if ("bottom" === this._position || "top" === this._position) l(f.options.labelWrap) && !l(this.sessionVariables.stripLineLabelMaxHeight) ? z = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = z = f.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * f.labelFontSize + ("object" === typeof f.labelPadding ? (f.labelPadding.top || 0) + (f.labelPadding.bottom || 0) : 2 * f.labelPadding);
              if ("left" === this._position || "right" === this._position) l(f.options.labelWrap) && !l(this.sessionVariables.stripLineLabelMaxHeight) ? z = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = z = f.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * f.labelFontSize + ("object" === typeof f.labelPadding ? (f.labelPadding.top || 0) + (f.labelPadding.bottom || 0) : 2 * f.labelPadding);
              l(f.labelBackgroundColor) && (f.labelBackgroundColor = "#EEEEEE");
            } else q = "bottom" === this._position || "top" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, z = l(f.options.labelWrap) || f.labelWrap ? "bottom" === this._position || "top" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * f.labelFontSize + ("object" === typeof f.labelPadding ? (f.labelPadding.top || 0) + (f.labelPadding.bottom || 0) : 2 * f.labelPadding), l(f.labelBackgroundColor) && (l(f.startValue) && 0 !== f.startValue ? f.labelBackgroundColor = r ? "transparent" : null : f.labelBackgroundColor = "#EEEEEE");
            a = new ja(this.ctx, {
              x: 0,
              y: 0,
              backgroundColor: f.labelBackgroundColor,
              borderColor: f.labelBorderColor,
              borderThickness: f.labelBorderThickness,
              cornerRadius: f.labelCornerRadius,
              maxWidth: f.options.labelMaxWidth ? f.options.labelMaxWidth : q,
              maxHeight: z,
              angle: this.labelAngle,
              text: f.labelFormatter ? f.labelFormatter({ chart: this.chart, axis: this, stripLine: f }) : f.label,
              textAlign: f.labelTextAlign,
              fontSize: f.labelFontSize,
              fontFamily: f.labelFontFamily,
              fontWeight: f.labelFontWeight,
              fontColor: f.labelFontColor || f.color,
              fontStyle: f.labelFontStyle,
              textBaseline: "middle",
              padding: f.labelPadding
            });
            this._stripLineLabels.push({ position: f.value, textBlock: a, effectiveHeight: null, stripLine: f });
          }
        };
        B.prototype.createLabelsAndCalculateWidth = function() {
          var a = 0, e = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var c = this.chart.isNavigator ? 0 : 5;
          this.labelEffectiveWidth = l(this.labelEffectiveWidth) ? 0 : this.labelEffectiveWidth;
          if ("left" === this._position || "right" === this._position) {
            this.createLabels();
            for (e = 0; e < this._labels.length; e++) {
              var b = this._labels[e].textBlock, b = b.measureText(), d = 0, d = 0 === this.labelAngle ? b.width : b.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + b.height * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
              a <= d && (this.labelEffectiveWidth = a = d);
              this._labels[e].effectiveWidth = d;
            }
            for (e = 0; e < this._stripLineLabels.length; e++) "outside" === this._stripLineLabels[e].stripLine.labelPlacement && (this._stripLineLabels[e].stripLine.value >= this.viewportMinimum && this._stripLineLabels[e].stripLine.value <= this.viewportMaximum) && (b = this._stripLineLabels[e].textBlock, b = b.measureText(), d = 0 === this.labelAngle ? b.width : b.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + b.height * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), "inside" === this.tickPlacement && (d += this.tickLength), "inside" === this.labelPlacement && (a += d + c), a <= d && (a = d), this.stripLineLabelEffectiveWidth = this._stripLineLabels[e].effectiveWidth = d);
          }
          return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + this.tickLength + c;
        };
        B.prototype.createLabelsAndCalculateHeight = function() {
          var a = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var e, c = 0, b = this.chart.isNavigator ? 0 : 5;
          this.labelEffectiveHeight = l(this.labelEffectiveHeight) ? 0 : this.labelEffectiveHeight;
          if ("bottom" === this._position || "top" === this._position) {
            this.createLabels();
            for (c = 0; c < this._labels.length; c++) {
              e = this._labels[c].textBlock;
              e = e.measureText();
              var d = 0, d = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + e.height * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
              a <= d && (this.labelEffectiveHeight = a = d);
              this._labels[c].effectiveHeight = d;
            }
            for (c = 0; c < this._stripLineLabels.length; c++) "outside" === this._stripLineLabels[c].stripLine.labelPlacement && (this._stripLineLabels[c].stripLine.value >= this.viewportMinimum && this._stripLineLabels[c].stripLine.value <= this.viewportMaximum) && (e = this._stripLineLabels[c].textBlock, e = e.measureText(), d = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + e.height * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), "inside" === this.tickPlacement && (d += this.tickLength), "inside" === this.labelPlacement && (a += d + b), a <= d && (a = d), this.stripLineLabelEffectiveHeight = this._stripLineLabels[c].effectiveHeight = d);
          }
          return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + this.tickLength + b;
        };
        B.setLayout = function(a, e, c, b, d, f) {
          var q, g2, r2, k, m = a[0] ? a[0].chart : e[0].chart, n = m.isNavigator ? 0 : 10, p = m._axes;
          if (a && 0 < a.length) for (var h = 0; h < a.length; h++) a[h] && a[h].calculateAxisParameters();
          if (e && 0 < e.length) for (h = 0; h < e.length; h++) e[h].calculateAxisParameters();
          if (c && 0 < c.length) for (h = 0; h < c.length; h++) c[h].calculateAxisParameters();
          if (b && 0 < b.length) for (h = 0; h < b.length; h++) b[h].calculateAxisParameters();
          for (h = 0; h < p.length; h++) if (p[h] && p[h].scaleBreaks && p[h].scaleBreaks._appliedBreaks.length) for (var t2 = p[h].scaleBreaks._appliedBreaks, u3 = 0; u3 < t2.length && !(t2[u3].startValue > p[h].viewportMaximum); u3++) t2[u3].endValue < p[h].viewportMinimum || (l(p[h].scaleBreaks.firstBreakIndex) && (p[h].scaleBreaks.firstBreakIndex = u3), t2[u3].startValue >= p[h].viewPortMinimum && (p[h].scaleBreaks.lastBreakIndex = u3));
          for (var z = u3 = 0, s = 0, x = 0, v = 0, B2 = 0, C3 = 0, E, F3, K2 = g2 = 0, L, N, O2, t2 = L = N = O2 = false, h = 0; h < p.length; h++) p[h] && p[h].title && (p[h]._titleTextBlock = new ja(p[h].ctx, {
            text: p[h].title,
            fontSize: p[h].titleFontSize,
            fontFamily: p[h].titleFontFamily,
            fontWeight: p[h].titleFontWeight,
            fontColor: p[h].titleFontColor,
            fontStyle: p[h].titleFontStyle,
            borderColor: p[h].titleBorderColor,
            borderThickness: p[h].titleBorderThickness,
            backgroundColor: p[h].titleBackgroundColor,
            cornerRadius: p[h].titleCornerRadius,
            textBaseline: "middle",
            textAlign: p[h].titleTextAlign,
            padding: p[h].titlePadding
          }));
          for (h = 0; h < p.length; h++) if (p[h].title) {
            var M2 = 1.5 * p[h].titleFontSize + ("object" === typeof p[h].titlePadding ? (p[h].titlePadding.top || 0) + (p[h].titlePadding.bottom || 0) : 2 * p[h].titlePadding);
            p[h]._titleTextBlock.maxWidth = p[h].titleMaxWidth || f.height;
            p[h]._titleTextBlock.maxHeight = p[h].titleWrap ? 0.8 * f.width : Math.min(M2, 0.8 * f.width);
            switch (p[h]._position) {
              case "left":
                p[h]._titleTextBlock.angle = -90;
                break;
              case "right":
                p[h]._titleTextBlock.angle = 90;
                break;
              default:
                p[h]._titleTextBlock.maxWidth = p[h].titleMaxWidth || f.width, p[h]._titleTextBlock.maxHeight = p[h].titleWrap ? 0.8 * f.height : Math.min(M2, 0.8 * f.height), p[h]._titleTextBlock.angle = 0;
            }
          }
          if ("normal" === d) {
            for (var x = [], v = [], B2 = [], C3 = [], P2 = [], Q3 = [], S = [], G = []; 4 > u3; ) {
              var U2 = 0, V2 = 0, T2 = 0, W2 = 0, aa = M2 = d = 0, X2 = g2 = 0, Y2 = 0, ba3 = q = 0;
              if (c && 0 < c.length) for (B2 = [], h = q = 0; h < c.length; h++) B2.push(Math.ceil(c[h] ? c[h].createLabelsAndCalculateWidth() : 0)), q += B2[h], aa += c[h] && !m.isNavigator ? c[h].margin : 0;
              else B2.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));
              S.push(B2);
              if (b && 0 < b.length) for (C3 = [], h = ba3 = 0; h < b.length; h++) C3.push(Math.ceil(b[h] ? b[h].createLabelsAndCalculateWidth() : 0)), ba3 += C3[h], g2 += b[h] ? b[h].margin : 0;
              else C3.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));
              G.push(C3);
              q = Math.round(f.x1 + q + aa - (c[0] ? ("inside" === c[0].labelPlacement ? c[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === c[0].tickPlacement ? c[0].tickLength : 0) : 0));
              r2 = Math.round(Math.min(f.x2 - ba3 - g2 + (b[0] ? ("inside" === b[0].labelPlacement ? b[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === b[0].tickPlacement ? b[0].tickLength : 0) : 0), m.width - n));
              if (a && 0 < a.length) for (x = [], h = X2 = 0; h < a.length; h++) a[h] && (a[h].lineCoordinates = {}), a[h].lineCoordinates.width = Math.abs(r2 - q), a[h].title && (a[h]._titleTextBlock.maxWidth = 0 < a[h].titleMaxWidth && a[h].titleMaxWidth < a[h].lineCoordinates.width ? a[h].titleMaxWidth : a[h].lineCoordinates.width), x.push(Math.ceil(a[h] ? a[h].createLabelsAndCalculateHeight() : 0)), X2 += x[h], d += a[h] && !m.isNavigator ? a[h].margin : 0;
              else x.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));
              P2.push(x);
              if (e && 0 < e.length) for (v = [], h = Y2 = 0; h < e.length; h++) e[h] && (e[h].lineCoordinates = {}), e[h].lineCoordinates.width = Math.abs(r2 - q), e[h].title && (e[h]._titleTextBlock.maxWidth = 0 < e[h].titleMaxWidth && e[h].titleMaxWidth < e[h].lineCoordinates.width ? e[h].titleMaxWidth : e[h].lineCoordinates.width), v.push(Math.ceil(e[h] ? e[h].createLabelsAndCalculateHeight() : 0)), Y2 += v[h], M2 += e[h] && !m.isNavigator ? e[h].margin : 0;
              else v.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateHeight() : 0));
              Q3.push(v);
              if (a && 0 < a.length) for (h = 0; h < a.length; h++) {
                if (a[h]) {
                  a[h].lineCoordinates.x1 = q;
                  a[h].lineCoordinates.x2 = r2;
                  if (a[h]._labels && 1 < a[h]._labels.length) {
                    var H = g2 = 0;
                    g2 = a[h]._labels[1];
                    H = "dateTime" === a[h].valueType ? a[h]._labels[a[h]._labels.length - 2] : a[h]._labels[a[h]._labels.length - 1];
                    z = g2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(g2.textBlock.angle)) + (g2.textBlock.height - g2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(g2.textBlock.angle));
                    s = H.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(H.textBlock.angle)) + H.textBlock.height * Math.sin(Math.PI / 180 * Math.abs(H.textBlock.angle));
                  }
                  !a[h] || (!a[h].labelAutoFit || l(E) || l(F3) || m.isNavigator || m.stockChart) || (g2 = 0, 0 < a[h].labelAngle ? (k = s - (H.textBlock.height - H.textBlock._lineHeight / 2) * Math.sin(Math.PI / 180 * H.textBlock.angle), F3 + k > r2 && (a[h].convertPixelToValue(F3) >= a[h].viewportMinimum && a[h].convertPixelToValue(F3) <= a[h].viewportMaximum) && (g2 += F3 + k - r2 - ba3)) : 0 > a[h].labelAngle ? E - z < q && E - z < a[h].viewportMinimum && (K2 = q - (aa + a[h].tickLength + B2 + E - z + a[h].labelFontSize / 2)) : 0 === a[h].labelAngle && (F3 + s > r2 && (a[h].convertPixelToValue(F3) >= a[h].viewportMinimum && a[h].convertPixelToValue(F3) <= a[h].viewportMaximum) && (g2 = F3 + s / 2 - r2 - ba3), E - z < q && E - z < a[h].viewportMinimum && (K2 = q - aa - a[h].tickLength - B2 - E + z / 2)), a[h].viewportMaximum === a[h].maximum && a[h].viewportMinimum === a[h].minimum && 0 < a[h].labelAngle && 0 < g2 ? r2 -= g2 : a[h].viewportMaximum === a[h].maximum && a[h].viewportMinimum === a[h].minimum && 0 > a[h].labelAngle && 0 < K2 ? q += K2 : a[h].viewportMaximum === a[h].maximum && a[h].viewportMinimum === a[h].minimum && 0 === a[h].labelAngle && (0 < K2 && (q += K2), 0 < g2 && (r2 -= g2)));
                  m.panEnabled ? X2 = l(m.sessionVariables.axisX.height) || m.stockChart ? m.sessionVariables.axisX.height = X2 : m.sessionVariables.axisX.height : m.sessionVariables.axisX.height = X2;
                  g2 = Math.round(f.y2 - X2 - d + U2);
                  k = Math.round(f.y2);
                  a[h].lineCoordinates.width = r2 - q;
                  a[h].lineCoordinates.y1 = g2;
                  a[h].lineCoordinates.y2 = g2;
                  a[h].bounds = { x1: q, y1: g2, x2: r2, y2: k - (X2 + d - x[h] - U2), width: r2 - q };
                  a[h].bounds.height = a[h].bounds.y2 - a[h].bounds.y1;
                  "inside" === a[h].labelPlacement && (a[h].lineCoordinates.y1 = a[0].bounds.y1 + U2 + (a[h].labelEffectiveHeight || 0) + (m.isNavigator ? 0 : 5), a[h].lineCoordinates.y2 = a[h].lineCoordinates.y1 + a[h].lineThickness / 2);
                  "inside" === a[h].tickPlacement && (a[h].lineCoordinates.y1 += a[h].tickLength, a[h].lineCoordinates.y2 = a[h].lineCoordinates.y1 + a[h].lineThickness / 2);
                }
                U2 += x[h] + a[h].margin;
              }
              if (e && 0 < e.length) for (h = 0; h < e.length; h++) e[h].lineCoordinates.x1 = q, e[h].lineCoordinates.x2 = r2, e[h].lineCoordinates.width = Math.abs(r2 - q), e[h]._labels && 1 < e[h]._labels.length && (g2 = e[h]._labels[1], H = "dateTime" === e[h].valueType ? e[h]._labels[e[h]._labels.length - 2] : e[h]._labels[e[h]._labels.length - 1], z = g2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(g2.textBlock.angle)) + (g2.textBlock.height - H.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(g2.textBlock.angle)), s = H.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(H.textBlock.angle)) + (H.textBlock.height - H.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(H.textBlock.angle))), m.panEnabled ? Y2 = l(m.sessionVariables.axisX2.height) || m.stockChart ? m.sessionVariables.axisX2.height = Y2 : m.sessionVariables.axisX2.height : m.sessionVariables.axisX2.height = Y2, g2 = Math.round(f.y1), k = e[h].lineCoordinates.y1 = g2 + Y2 + M2 - V2, e[h].lineCoordinates.y2 = g2, e[h].bounds = { x1: q, y1: g2 + (Y2 + M2 - v[h] - V2), x2: r2, y2: k, width: r2 - q }, e[h].bounds.height = e[h].bounds.y2 - e[h].bounds.y1, "inside" === e[h].labelPlacement && (e[h].lineCoordinates.y1 = e[0].bounds.y2 - V2 - (e[h].labelEffectiveHeight || 0) - 5), "inside" === e[h].tickPlacement && (e[h].lineCoordinates.y1 -= e[h].tickLength), V2 += v[h] + e[h].margin;
              if (c && 0 < c.length) for (h = 0; h < c.length; h++) aa = m.isNavigator ? 0 : 10, c[h] && (q = r2 = Math.round((a[0] ? a[0].lineCoordinates.x1 : e[0].lineCoordinates.x1) + (c[0] ? ("inside" === c[0].labelPlacement ? c[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === c[0].tickPlacement ? c[0].tickLength : 0) : 0)), aa = c[h]._labels && 0 < c[h]._labels.length ? c[h]._labels[c[h]._labels.length - 1].textBlock._lineHeight / 2 : n, g2 = Math.round(Math.max(f.y1 + Y2 + M2 - (e[0] ? ("inside" === e[0].labelPlacement ? e[0].labelEffectiveHeight + 5 : 0) + ("inside" === e[0].tickPlacement ? e[0].tickLength : 0) : 0), Math.max(aa, n))), aa = 0 < a.length ? 0 : c[h]._labels && 0 < c[h]._labels.length ? c[h]._labels[0].textBlock.height / 2 : n, k = Math.round(f.y2 - X2 + (a[0] ? ("inside" === a[0].labelPlacement ? a[0].labelEffectiveHeight + (m.isNavigator ? 0 : 5) : 0) + ("inside" === a[0].tickPlacement ? a[0].tickLength : 0) : 0) - d - aa), c[h].lineCoordinates = { x1: q - T2, y1: g2, x2: r2 - T2, y2: k, height: Math.abs(k - g2) }, c[h].bounds = { x1: q - (B2[h] + T2), y1: g2, x2: r2 - T2, y2: k, height: k - g2 }, c[h].bounds.width = c[h].bounds.x2 - c[h].bounds.x1, "inside" === c[h].labelPlacement && (c[h].lineCoordinates.x1 = c[0].bounds.x1 + B2[0] - T2 - (c[h].labelEffectiveWidth || 0) - 5, c[h].lineCoordinates.x2 = c[h].lineCoordinates.x1 + c[h].lineThickness / 2), "inside" === c[h].tickPlacement && (c[h].lineCoordinates.x1 -= c[h].tickLength, c[h].lineCoordinates.x2 = c[h].lineCoordinates.x1 + c[h].lineThickness / 2), c[h].title && (c[h]._titleTextBlock.maxWidth = 0 < c[h].titleMaxWidth && c[h].titleMaxWidth < c[h].lineCoordinates.height ? c[h].titleMaxWidth : c[h].lineCoordinates.height), T2 += B2[h] + c[h].margin);
              if (b && 0 < b.length) for (h = 0; h < b.length; h++) b[h] && (q = r2 = Math.round((a[0] ? a[0].lineCoordinates.x2 : e[0].lineCoordinates.x2) - (b[0] ? ("inside" === b[0].labelPlacement ? b[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === b[0].tickPlacement ? b[0].tickLength : 0) : 0)), aa = b[h]._labels && 0 < b[h]._labels.length ? b[h]._labels[b[h]._labels.length - 1].textBlock.height / 2 : 0, g2 = Math.round(Math.max(f.y1 + Y2 + M2 - (e[0] ? ("inside" === e[0].labelPlacement ? e[0].labelEffectiveHeight + (m.isNavigator ? 0 : 5) : 0) + ("inside" === e[0].tickPlacement ? e[0].tickLength : 0) : 0), Math.max(aa, n))), aa = 0 < a.length ? 0 : b[h]._labels && 0 < b[h]._labels.length ? b[h]._labels[0].textBlock.height / 2 : 0, k = Math.round(f.y2 - (X2 + d + aa) + (a[0] ? ("inside" === a[0].labelPlacement ? a[0].labelEffectiveHeight + (m.isNavigator ? 0 : 5) : 0) + ("inside" === a[0].tickPlacement ? a[0].tickLength : 0) : 0)), b[h].lineCoordinates = { x1: q + W2, y1: g2, x2: q + W2, y2: k, height: Math.abs(k - g2) }, b[h].bounds = { x1: q + W2, y1: g2, x2: r2 + C3[h] + W2, y2: k, height: k - g2 }, b[h].bounds.width = b[h].bounds.x2 - b[h].bounds.x1, "inside" === b[h].labelPlacement && (b[h].lineCoordinates.x1 = b[0].bounds.x1 + W2 + (b[h].labelEffectiveWidth || 0) + (m.isNavigator ? 0 : 5), b[h].lineCoordinates.x2 = b[h].lineCoordinates.x1 + b[h].lineThickness / 2), "inside" === b[h].tickPlacement && (b[h].lineCoordinates.x1 += b[h].tickLength, b[h].lineCoordinates.x2 = b[h].lineCoordinates.x1 + b[h].lineThickness / 2), b[h].title && (b[h]._titleTextBlock.maxWidth = 0 < b[h].titleMaxWidth && b[h].titleMaxWidth < b[h].lineCoordinates.height ? b[h].titleMaxWidth : b[h].lineCoordinates.height), W2 += C3[h] + b[h].margin);
              if (a && 0 < a.length) for (h = 0; h < a.length; h++) a[h] && (a[h].calculateValueToPixelConversionParameters(), a[h].calculateBreaksSizeInValues(), a[h]._labels && 1 < a[h]._labels.length && (E = (a[h].logarithmic ? Math.log(a[h]._labels[1].position / a[h].viewportMinimum) / a[h].conversionParameters.lnLogarithmBase : a[h]._labels[1].position - a[h].viewportMinimum) * Math.abs(a[h].conversionParameters.pixelPerUnit) + a[h].lineCoordinates.x1, q = a[h]._labels[a[h]._labels.length - ("dateTime" === a[h].valueType ? 2 : 1)].position, q = a[h].getApparentDifference(a[h].viewportMinimum, q), F3 = a[h].logarithmic ? (1 < q ? Math.log(q) / a[h].conversionParameters.lnLogarithmBase * Math.abs(a[h].conversionParameters.pixelPerUnit) : 0) + a[h].lineCoordinates.x1 : (0 < q ? q * Math.abs(a[h].conversionParameters.pixelPerUnit) : 0) + a[h].lineCoordinates.x1));
              if (e && 0 < e.length) for (h = 0; h < e.length; h++) e[h].calculateValueToPixelConversionParameters(), e[h].calculateBreaksSizeInValues(), e[h]._labels && 1 < e[h]._labels.length && (E = (e[h].logarithmic ? Math.log(e[h]._labels[1].position / e[h].viewportMinimum) / e[h].conversionParameters.lnLogarithmBase : e[h]._labels[1].position - e[h].viewportMinimum) * Math.abs(e[h].conversionParameters.pixelPerUnit) + e[h].lineCoordinates.x1, q = e[h]._labels[e[h]._labels.length - ("dateTime" === e[h].valueType ? 2 : 1)].position, q = e[h].getApparentDifference(
                e[h].viewportMinimum,
                q
              ), F3 = e[h].logarithmic ? (1 < q ? Math.log(q) / e[h].conversionParameters.lnLogarithmBase * Math.abs(e[h].conversionParameters.pixelPerUnit) : 0) + e[h].lineCoordinates.x1 : (0 < q ? q * Math.abs(e[h].conversionParameters.pixelPerUnit) : 0) + e[h].lineCoordinates.x1);
              for (h = 0; h < p.length; h++) "axisY" === p[h].type && (p[h].calculateValueToPixelConversionParameters(), p[h].calculateBreaksSizeInValues());
              if (0 < u3) {
                if (a && 0 < a.length) for (h = 0; h < a.length; h++) t2 = P2[u3 - 1][h] === P2[u3][h] ? true : false;
                else t2 = true;
                if (e && 0 < e.length) for (h = 0; h < e.length; h++) L = Q3[u3 - 1][h] === Q3[u3][h] ? true : false;
                else L = true;
                if (c && 0 < c.length) for (h = 0; h < c.length; h++) N = S[u3 - 1][h] === S[u3][h] ? true : false;
                else N = true;
                if (b && 0 < b.length) for (h = 0; h < b.length; h++) O2 = G[u3 - 1][h] === G[u3][h] ? true : false;
                else O2 = true;
              }
              if (t2 && L && N && O2) break;
              u3++;
            }
            if (a && 0 < a.length) for (h = 0; h < a.length; h++) a[h].calculateStripLinesThicknessInValues(), a[h].calculateBreaksInPixels();
            if (e && 0 < e.length) for (h = 0; h < e.length; h++) e[h].calculateStripLinesThicknessInValues(), e[h].calculateBreaksInPixels();
            if (c && 0 < c.length) for (h = 0; h < c.length; h++) c[h].calculateStripLinesThicknessInValues(), c[h].calculateBreaksInPixels();
            if (b && 0 < b.length) for (h = 0; h < b.length; h++) b[h].calculateStripLinesThicknessInValues(), b[h].calculateBreaksInPixels();
          } else {
            n = [];
            E = [];
            K2 = [];
            z = [];
            s = [];
            F3 = [];
            P2 = [];
            for (Q3 = []; 4 > u3; ) {
              X2 = W2 = T2 = g2 = aa = M2 = d = G = S = U2 = Y2 = 0;
              if (a && 0 < a.length) for (K2 = [], h = W2 = 0; h < a.length; h++) K2.push(Math.ceil(a[h] ? a[h].createLabelsAndCalculateWidth() : 0)), W2 += K2[h], d += a[h] && !m.isNavigator ? a[h].margin : 0;
              else K2.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));
              P2.push(K2);
              if (e && 0 < e.length) for (z = [], h = X2 = 0; h < e.length; h++) z.push(Math.ceil(e[h] ? e[h].createLabelsAndCalculateWidth() : 0)), X2 += z[h], M2 += e[h] ? e[h].margin : 0;
              else z.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateWidth() : 0));
              Q3.push(z);
              if (c && 0 < c.length) for (h = 0; h < c.length; h++) c[h].lineCoordinates = {}, q = Math.round(f.x1 + W2 + d - (a[0] ? ("inside" === a[0].labelPlacement ? a[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === a[0].tickPlacement ? a[0].tickLength : 0) : 0)), r2 = Math.round(Math.min(f.x2 - X2 - M2 + (e[0] ? ("inside" === e[0].labelPlacement ? e[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === e[0].tickPlacement ? e[0].tickLength : 0) : 0), m.width - 10)), c[h].labelAutoFit && !l(x) && (0 < !a.length && (q = 0 > c[h].labelAngle ? Math.max(q, x) : 0 === c[h].labelAngle ? Math.max(q, x / 2) : q), 0 < !e.length && (r2 = 0 < c[h].labelAngle ? r2 - v / 2 : 0 === c[h].labelAngle ? r2 - v / 2 : r2)), c[h].lineCoordinates.x1 = q, c[h].lineCoordinates.x2 = r2, c[h].lineCoordinates.width = Math.abs(r2 - q), c[h].title && (c[h]._titleTextBlock.maxWidth = 0 < c[h].titleMaxWidth && c[h].titleMaxWidth < c[h].lineCoordinates.width ? c[h].titleMaxWidth : c[h].lineCoordinates.width);
              if (b && 0 < b.length) for (h = 0; h < b.length; h++) b[h].lineCoordinates = {}, q = Math.round(f.x1 + W2 + d - (a[0] ? ("inside" === a[0].labelPlacement ? a[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === a[0].tickPlacement ? a[0].tickLength : 0) : 0)), r2 = Math.round(Math.min(f.x2 - X2 - M2 + (e[0] ? ("inside" === e[0].labelPlacement ? e[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === e[0].tickPlacement ? e[0].tickLength : 0) : 0), b[h].chart.width - 10)), b[h] && b[h].labelAutoFit && !l(B2) && (0 < !a.length && (q = 0 < b[h].labelAngle ? Math.max(q, B2) : 0 === b[h].labelAngle ? Math.max(
                q,
                B2 / 2
              ) : q), 0 < !e.length && (r2 -= C3 / 2)), b[h].lineCoordinates.x1 = q, b[h].lineCoordinates.x2 = r2, b[h].lineCoordinates.width = Math.abs(r2 - q), b[h].title && (b[h]._titleTextBlock.maxWidth = 0 < b[h].titleMaxWidth && b[h].titleMaxWidth < b[h].lineCoordinates.width ? b[h].titleMaxWidth : b[h].lineCoordinates.width);
              if (c && 0 < c.length) for (n = [], h = T2 = 0; h < c.length; h++) n.push(Math.ceil(c[h] ? c[h].createLabelsAndCalculateHeight() : 0)), T2 += n[h] + c[h].margin, aa += c[h].margin;
              else n.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0));
              s.push(n);
              if (b && 0 < b.length) for (E = [], h = 0; h < b.length; h++) E.push(Math.ceil(b[h] ? b[h].createLabelsAndCalculateHeight() : 0)), g2 += b[h].margin;
              else E.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));
              F3.push(E);
              if (c && 0 < c.length) for (h = 0; h < c.length; h++) 0 < c[h]._labels.length && (g2 = c[h]._labels[0], H = c[h]._labels[c[h]._labels.length - 1], x = g2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(g2.textBlock.angle)) + (g2.textBlock.height - H.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(g2.textBlock.angle)), v = H.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(H.textBlock.angle)) + (H.textBlock.height - H.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(H.textBlock.angle)));
              if (b && 0 < b.length) for (h = 0; h < b.length; h++) b[h] && 0 < b[h]._labels.length && (g2 = b[h]._labels[0], H = b[h]._labels[b[h]._labels.length - 1], B2 = g2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(g2.textBlock.angle)) + (g2.textBlock.height - H.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(g2.textBlock.angle)), C3 = H.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(H.textBlock.angle)) + (H.textBlock.height - H.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(H.textBlock.angle)));
              if (m.panEnabled) for (h = 0; h < c.length; h++) n[h] = l(m.sessionVariables.axisY[h].height) ? m.sessionVariables.axisY[h].height = n[h] : m.sessionVariables.axisY[h].height;
              else for (h = 0; h < c.length; h++) m.sessionVariables.axisY[h].height = n[h];
              if (c && 0 < c.length) for (h = c.length - 1; 0 <= h; h--) g2 = Math.round(f.y2), k = Math.round(f.y2 > c[h].chart.height ? c[h].chart.height : f.y2), c[h].lineCoordinates.y1 = g2 - (n[h] + c[h].margin + Y2), c[h].lineCoordinates.y2 = g2 - (n[h] + c[h].margin + Y2), "inside" === c[h].labelPlacement && (c[h].lineCoordinates.y1 = c[h].lineCoordinates.y1 + c[h].labelEffectiveHeight + (m.isNavigator ? 0 : 5), c[h].lineCoordinates.y2 = c[h].lineCoordinates.y1 + c[h].lineThickness / 2), "inside" === c[h].tickPlacement && (c[h].lineCoordinates.y1 += c[h].tickLength, c[h].lineCoordinates.y2 = c[h].lineCoordinates.y1 + c[h].lineThickness / 2), c[h].bounds = { x1: q, y1: g2 - (n[h] + Y2 + c[h].margin), x2: r2, y2: k - (Y2 + c[h].margin), width: r2 - q, height: n[h] }, c[h].title && (c[h]._titleTextBlock.maxWidth = 0 < c[h].titleMaxWidth && c[h].titleMaxWidth < c[h].lineCoordinates.width ? c[h].titleMaxWidth : c[h].lineCoordinates.width), Y2 += n[h] + c[h].margin;
              if (b && 0 < b.length) for (h = b.length - 1; 0 <= h; h--) b[h] && (g2 = Math.round(f.y1), k = Math.round(f.y1 + (E[h] + b[h].margin + U2)), b[h].lineCoordinates.y1 = k, b[h].lineCoordinates.y2 = k, "inside" === b[h].labelPlacement && (b[h].lineCoordinates.y1 = k - b[h].labelEffectiveHeight - 5, b[h].lineCoordinates.y2 = b[h].lineCoordinates.y1 - b[h].lineThickness / 2), "inside" === b[h].tickPlacement && (b[h].lineCoordinates.y1 -= b[h].tickLength, b[h].lineCoordinates.y2 = b[h].lineCoordinates.y1 - b[h].lineThickness / 2), b[h].bounds = { x1: q, y1: g2 + (b[h].margin + U2), x2: r2, y2: k, width: r2 - q }, b[h].bounds.height = b[h].bounds.y2 - b[h].bounds.y1, b[h].title && (b[h]._titleTextBlock.maxWidth = 0 < b[h].titleMaxWidth && b[h].titleMaxWidth < b[h].lineCoordinates.width ? b[h].titleMaxWidth : b[h].lineCoordinates.width), U2 += E[h] + b[h].margin);
              if (a && 0 < a.length) for (h = 0; h < a.length; h++) {
                aa = a[h]._labels && 0 < a[h]._labels.length ? a[h]._labels[0].textBlock.fontSize / 2 : 0;
                q = Math.round(f.x1 + d);
                g2 = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : f.y1 < Math.max(aa, 10) ? Math.max(aa, 10) : f.y1) : f.y1 < Math.max(aa, 10) ? Math.max(aa, 10) : f.y1;
                r2 = Math.round(f.x1 + W2 + d);
                k = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y1 : f.y2 - T2 > m.height - Math.max(aa, 10) ? m.height - Math.max(aa, 10) : f.y2 - T2) : f.y2 > m.height - Math.max(aa, 10) ? m.height - Math.max(aa, 10) : f.y2;
                if (c && 0 < c.length) for (H = 0; H < c.length; H++) c[H] && c[H].labelAutoFit && (r2 = c[H].lineCoordinates.x1 + (a[0] ? ("inside" === a[0].labelPlacement ? a[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === a[0].tickPlacement ? a[0].tickLength : 0) : 0), q = 0 > c[H].labelAngle || 0 === c[H].labelAngle ? r2 - W2 : q);
                if (b && 0 < b.length) for (H = 0; H < b.length; H++) b[H] && b[H].labelAutoFit && (r2 = b[H].lineCoordinates.x1 + (a[0] ? ("inside" === a[0].labelPlacement ? a[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === a[0].tickPlacement ? a[0].tickLength : 0) : 0), q = r2 - W2);
                a[h].lineCoordinates = { x1: r2 - S, y1: g2, x2: r2 - S, y2: k, height: Math.abs(k - g2) };
                "inside" === a[h].labelPlacement && (a[h].lineCoordinates.x1 = a[h].lineCoordinates.x1 - a[h].labelEffectiveWidth - 5, a[h].lineCoordinates.x2 = a[h].lineCoordinates.x1 + a[h].lineThickness / 2);
                "inside" === a[h].tickPlacement && (a[h].lineCoordinates.x1 -= a[h].tickLength, a[h].lineCoordinates.x2 = a[h].lineCoordinates.x1 + a[h].lineThickness / 2);
                a[h].bounds = { x1: r2 - (K2[h] + S), y1: g2, x2: r2 - S, y2: k, height: k - g2 };
                a[h].bounds.width = a[h].bounds.x2 - a[h].bounds.x1;
                a[h].title && (a[h]._titleTextBlock.maxWidth = 0 < a[h].titleMaxWidth && a[h].titleMaxWidth < a[h].lineCoordinates.height ? a[h].titleMaxWidth : a[h].lineCoordinates.height);
                a[h].calculateValueToPixelConversionParameters();
                a[h].calculateBreaksSizeInValues();
                S += K2[h] + a[h].margin;
              }
              if (e && 0 < e.length) for (h = 0; h < e.length; h++) {
                aa = e[h]._labels && 0 < e[h]._labels.length ? e[h]._labels[0].textBlock.fontSize / 2 : 0;
                r2 = Math.round(f.x1 - M2);
                g2 = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : f.y1 < Math.max(aa, 10) ? Math.max(aa, 10) : f.y1) : f.y1 < Math.max(aa, 10) ? Math.max(aa, 10) : f.y1;
                q = Math.round(f.x2 - X2 - M2);
                k = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y1 : f.y2 - T2 > m.height - Math.max(aa, 10) ? m.height - Math.max(aa, 10) : f.y2 - T2) : f.y2 > m.height - Math.max(aa, 10) ? m.height - Math.max(aa, 10) : f.y2;
                if (c && 0 < c.length) for (H = 0; H < c.length; H++) c[H] && c[H].labelAutoFit && (q = c[H].lineCoordinates.x2 - (e[0] ? ("inside" === e[0].labelPlacement ? e[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === e[0].tickPlacement ? e[0].tickLength : 0) : 0), r2 = 0 > c[H].labelAngle || 0 === c[H].labelAngle ? q + X2 : q);
                if (b && 0 < b.length) for (H = 0; H < b.length; H++) b[H] && b[H].labelAutoFit && (q = b[H].lineCoordinates.x2 - (e[0] ? ("inside" === e[0].labelPlacement ? e[0].labelEffectiveWidth + (m.isNavigator ? 0 : 5) : 0) + ("inside" === e[0].tickPlacement ? e[0].tickLength : 0) : 0), r2 = q + X2);
                e[h].lineCoordinates = { x1: q + G, y1: g2, x2: q + G, y2: k, height: Math.abs(k - g2) };
                "inside" === e[h].labelPlacement && (e[h].lineCoordinates.x1 = e[h].lineCoordinates.x1 + e[h].labelEffectiveWidth + (m.isNavigator ? 0 : 5), e[h].lineCoordinates.x2 = e[h].lineCoordinates.x1 + e[h].lineThickness / 2);
                "inside" === e[h].tickPlacement && (e[h].lineCoordinates.x1 += e[h].tickLength, e[h].lineCoordinates.x2 = e[h].lineCoordinates.x1 + e[h].lineThickness / 2);
                e[h].bounds = { x1: q + G, y1: g2, x2: q + z[h] + G, y2: k, height: k - g2 };
                e[h].bounds.width = e[h].bounds.x2 - e[h].bounds.x1;
                e[h].title && (e[h]._titleTextBlock.maxWidth = 0 < e[h].titleMaxWidth && e[h].titleMaxWidth < e[h].lineCoordinates.height ? e[h].titleMaxWidth : e[h].lineCoordinates.height);
                e[h].calculateValueToPixelConversionParameters();
                e[h].calculateBreaksSizeInValues();
                G += z[h] + e[h].margin;
              }
              for (h = 0; h < p.length; h++) "axisY" === p[h].type && (p[h].calculateValueToPixelConversionParameters(), p[h].calculateBreaksSizeInValues());
              if (0 < u3) {
                if (a && 0 < a.length) for (h = 0; h < a.length; h++) t2 = P2[u3 - 1][h] === P2[u3][h] ? true : false;
                else t2 = true;
                if (e && 0 < e.length) for (h = 0; h < e.length; h++) L = Q3[u3 - 1][h] === Q3[u3][h] ? true : false;
                else L = true;
                if (c && 0 < c.length) for (h = 0; h < c.length; h++) N = s[u3 - 1][h] === s[u3][h] ? true : false;
                else N = true;
                if (b && 0 < b.length) for (h = 0; h < b.length; h++) O2 = F3[u3 - 1][h] === F3[u3][h] ? true : false;
                else O2 = true;
              }
              if (t2 && L && N && O2) break;
              u3++;
            }
            if (c && 0 < c.length) for (h = 0; h < c.length; h++) c[h].calculateStripLinesThicknessInValues(), c[h].calculateBreaksInPixels();
            if (b && 0 < b.length) for (h = 0; h < b.length; h++) b[h].calculateStripLinesThicknessInValues(), b[h].calculateBreaksInPixels();
            if (a && 0 < a.length) for (h = 0; h < a.length; h++) a[h].calculateStripLinesThicknessInValues(), a[h].calculateBreaksInPixels();
            if (e && 0 < e.length) for (h = 0; h < e.length; h++) e[h].calculateStripLinesThicknessInValues(), e[h].calculateBreaksInPixels();
          }
        };
        B.render = function(a, e, c, b, d) {
          d = a[0] ? a[0].chart : e[0].chart;
          var f = d.ctx;
          d.alignVerticalAxes && d.alignVerticalAxes();
          f.save();
          f.beginPath();
          a && a.length && f.rect(2, a[0].bounds.y1, a[0].chart.width - 4, a[a.length - 1].bounds.y2);
          e && e.length && f.rect(
            2,
            e[e.length - 1].bounds.y1,
            e[0].chart.width - 4,
            e[0].bounds.y2
          );
          f.clip();
          if (a && 0 < a.length) for (var g2 = 0; g2 < a.length; g2++) a[g2].renderLabelsTicksAndTitle();
          if (e && 0 < e.length) for (g2 = 0; g2 < e.length; g2++) e[g2].renderLabelsTicksAndTitle();
          f.restore();
          if (c && 0 < c.length) for (g2 = 0; g2 < c.length; g2++) c[g2].renderLabelsTicksAndTitle();
          if (b && 0 < b.length) for (g2 = 0; g2 < b.length; g2++) b[g2].renderLabelsTicksAndTitle();
          d.preparePlotArea();
          g2 = d.plotArea;
          f.save();
          f.beginPath();
          f.rect(g2.x1, g2.y1, Math.abs(g2.x2 - g2.x1), Math.abs(g2.y2 - g2.y1));
          f.clip();
          if (a && 0 < a.length) for (g2 = 0; g2 < a.length; g2++) a[g2].renderStripLinesOfThicknessType("value");
          if (e && 0 < e.length) for (g2 = 0; g2 < e.length; g2++) e[g2].renderStripLinesOfThicknessType("value");
          if (c && 0 < c.length) for (g2 = 0; g2 < c.length; g2++) c[g2].renderStripLinesOfThicknessType("value");
          if (b && 0 < b.length) for (g2 = 0; g2 < b.length; g2++) b[g2].renderStripLinesOfThicknessType("value");
          if (a && 0 < a.length) for (g2 = 0; g2 < a.length; g2++) a[g2].renderInterlacedColors();
          if (e && 0 < e.length) for (g2 = 0; g2 < e.length; g2++) e[g2].renderInterlacedColors();
          if (c && 0 < c.length) for (g2 = 0; g2 < c.length; g2++) c[g2].renderInterlacedColors();
          if (b && 0 < b.length) for (g2 = 0; g2 < b.length; g2++) b[g2].renderInterlacedColors();
          f.restore();
          if (a && 0 < a.length) for (g2 = 0; g2 < a.length; g2++) a[g2].renderGrid(), r && (a[g2].createMask(), a[g2].renderBreaksBackground());
          if (e && 0 < e.length) for (g2 = 0; g2 < e.length; g2++) e[g2].renderGrid(), r && (e[g2].createMask(), e[g2].renderBreaksBackground());
          if (c && 0 < c.length) for (g2 = 0; g2 < c.length; g2++) c[g2].renderGrid(), r && (c[g2].createMask(), c[g2].renderBreaksBackground());
          if (b && 0 < b.length) for (g2 = 0; g2 < b.length; g2++) b[g2].renderGrid(), r && (b[g2].createMask(), b[g2].renderBreaksBackground());
          if (a && 0 < a.length) for (g2 = 0; g2 < a.length; g2++) a[g2].renderAxisLine();
          if (e && 0 < e.length) for (g2 = 0; g2 < e.length; g2++) e[g2].renderAxisLine();
          if (c && 0 < c.length) for (g2 = 0; g2 < c.length; g2++) c[g2].renderAxisLine();
          if (b && 0 < b.length) for (g2 = 0; g2 < b.length; g2++) b[g2].renderAxisLine();
          f = false;
          if (a && 0 < a.length) for (g2 = 0; g2 < a.length; g2++) a[g2].renderStripLinesOfThicknessType("pixel"), a[g2].crosshair && a[g2].crosshair.enabled && (f = true, d.clearedOverlayedCanvas = a[g2].type);
          if (e && 0 < e.length) for (g2 = 0; g2 < e.length; g2++) e[g2].renderStripLinesOfThicknessType("pixel"), e[g2].crosshair && e[g2].crosshair.enabled && (f = true, d.clearedOverlayedCanvas = e[g2].type);
          if (c && 0 < c.length) for (g2 = 0; g2 < c.length; g2++) c[g2].renderStripLinesOfThicknessType("pixel"), c[g2].crosshair && c[g2].crosshair.enabled && (f = true, d.clearedOverlayedCanvas = c[g2].type);
          if (b && 0 < b.length) for (g2 = 0; g2 < b.length; g2++) b[g2].renderStripLinesOfThicknessType("pixel"), b[g2].crosshair && b[g2].crosshair.enabled && (f = true, d.clearedOverlayedCanvas = b[g2].type);
          if (f || !f && d.clearedOverlayedCanvas && 0 <= d.clearedOverlayedCanvas.indexOf("axis")) d.resetOverlayedCanvas(), d.renderCrosshairs(null, l(d.sessionVariables.crosshairShownByPixel) || d.sessionVariables.crosshairShownByPixel ? true : d.sessionVariables.crosshairShownByPixel);
        };
        B.prototype.calculateStripLinesThicknessInValues = function() {
          for (var a = 0; a < this.stripLines.length; a++) if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {
            var e = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue), c = Math.max(
              this.stripLines[a].startValue,
              this.stripLines[a].endValue
            ), b = this.getApparentDifference(e, c);
            this.stripLines[a].value = this.convertPixelToValue((this.convertValueToPixel(e) + this.convertValueToPixel(c)) / 2);
            this.stripLines[a].thickness = b;
            this.stripLines[a]._thicknessType = "value";
          }
        };
        B.prototype.calculateBreaksSizeInValues = function() {
          for (var a = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), b = this.scaleBreaks && !l(this.scaleBreaks.options.spacing), d, f = 0; f < e.length; f++) d = b || !l(e[f].options.spacing), e[f].spacing = Sa(e[f].spacing, a, 8, d ? 0.1 * a : 8, d ? 0 : 3) << 0, e[f].size = 0 > e[f].spacing ? 0 : Math.abs(e[f].spacing / c), this.logarithmic && (e[f].size = Math.pow(this.logarithmBase, e[f].size));
        };
        B.prototype.calculateBreaksInPixels = function() {
          if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
            var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);
            for (var e = 0; e < a.length && !(a[e].startValue > this.conversionParameters.maximum); e++) a[e].endValue < this.conversionParameters.minimum || (l(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = e), a[e].startValue >= this.conversionParameters.minimum && (a[e].startPixel = this.convertValueToPixel(a[e].startValue), this.scaleBreaks.lastBreakIndex = e), a[e].endValue <= this.conversionParameters.maximum && (a[e].endPixel = this.convertValueToPixel(a[e].endValue)));
          }
        };
        B.prototype.renderLabelsTicksAndTitle = function() {
          var a = this, e = false, c = 0, b = 0, d = 1, f = 0;
          0 !== this.labelAngle && 360 !== this.labelAngle && (d = 1.2);
          if ("undefined" === typeof this.options.interval) {
            if ("bottom" === this._position || "top" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
              for (var c = [], d = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, g2, l2 = this.viewportMaximum, r2 = this.lineCoordinates.width / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {
                n = this._labels[k];
                if (n.position < this.viewportMinimum) break;
                n.position > this.viewportMaximum || !(k === this._labels.length - 1 || g2 < Math.log(l2 / n.position) * r2 / d) || (c.push(n), l2 = n.position, g2 = n.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + n.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
              }
              this._labels = c;
            } else {
              for (k = 0; k < this._labels.length; k++) n = this._labels[k], n.position < this.viewportMinimum || (g2 = n.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + n.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += g2);
              c > this.lineCoordinates.width * d && this.labelAutoFit && (e = true);
            }
            if ("left" === this._position || "right" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
              for (var c = [], m, l2 = this.viewportMaximum, r2 = this.lineCoordinates.height / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {
                n = this._labels[k];
                if (n.position < this.viewportMinimum) break;
                n.position > this.viewportMaximum || !(k === this._labels.length - 1 || m < Math.log(l2 / n.position) * r2) || (c.push(n), l2 = n.position, m = n.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + n.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
              }
              this._labels = c;
            } else {
              for (k = 0; k < this._labels.length; k++) n = this._labels[k], n.position < this.viewportMinimum || (m = n.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + n.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += m);
              b > this.lineCoordinates.height * d && this.labelAutoFit && (e = true);
            }
          }
          this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function(a2, b2) {
            return a2.position - b2.position;
          });
          var k = 0, n, p;
          if ("bottom" === this._position) {
            for (k = 0; k < this._labels.length; k++) n = this._labels[k], n.position < this.viewportMinimum || n.position > this.viewportMaximum || (p = this.getPixelCoordinatesOnAxis(n.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (p.x << 0) + 0.5 : p.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, p.y << 0), this.ctx.lineTo(b, p.y + this.tickLength << 0), this.ctx.stroke()), e && 0 !== f++ % 2 && this.labelAutoFit || (0 === n.textBlock.angle ? (p.x -= n.textBlock.width / 2, p.y = "inside" === this.labelPlacement ? p.y - (("inside" === this.tickPlacement ? this.tickLength : 0) + n.textBlock.height - n.textBlock._lineHeight / 2 + 5) : p.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + n.textBlock._lineHeight / 2 + 5) : 0 > this.labelAngle ? (p.x = p.x - ("inside" === this.labelPlacement ? 0 : n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + n.textBlock.topPadding * Math.sin(Math.PI / 180 * this.labelAngle), p.y = "inside" === this.labelPlacement ? p.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 - (n.textBlock.height - n.textBlock._lineHeight / 2) * Math.cos(Math.PI / 180 * this.labelAngle) : p.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5 + Math.abs(n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - n.textBlock._lineHeight / 2 * Math.cos(Math.PI / 180 * this.labelAngle))) : (p.x = p.x - ("inside" === this.labelPlacement ? n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0) + n.textBlock.topPadding * Math.sin(Math.PI / 180 * this.labelAngle), p.y = "inside" === this.labelPlacement ? p.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 - n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - (n.textBlock.height - n.textBlock._lineHeight / 2) * Math.cos(Math.PI / 180 * this.labelAngle) : p.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5 + Math.abs(n.textBlock._lineHeight / 2 * Math.cos(Math.PI / 180 * this.labelAngle))), n.textBlock.x = p.x, n.textBlock.y = p.y));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a._labels.length; k++) if (n = a._labels[k], !(n.position < a.viewportMinimum || n.position > a.viewportMaximum) && (p = a.getPixelCoordinatesOnAxis(n.position), a.tickThickness)) {
                a.ctx.lineWidth = a.tickThickness;
                a.ctx.strokeStyle = a.tickColor;
                var b2 = 1 === a.ctx.lineWidth % 2 ? (p.x << 0) + 0.5 : p.x << 0;
                a.ctx.save();
                a.ctx.beginPath();
                a.ctx.moveTo(b2, p.y << 0);
                a.ctx.lineTo(b2, p.y - a.tickLength << 0);
                a.ctx.stroke();
                a.ctx.restore();
              }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height + this._titleTextBlock._lineHeight / 2 - 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("top" === this._position) {
            for (k = 0; k < this._labels.length; k++) n = this._labels[k], n.position < this.viewportMinimum || n.position > this.viewportMaximum || (p = this.getPixelCoordinatesOnAxis(n.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (p.x << 0) + 0.5 : p.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, p.y << 0), this.ctx.lineTo(b, p.y - this.tickLength << 0), this.ctx.stroke()), e && 0 !== f++ % 2 && this.labelAutoFit || (0 === n.textBlock.angle ? (p.x -= n.textBlock.width / 2, p.y = "inside" === this.labelPlacement ? p.y + n.textBlock._lineHeight / 2 + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : p.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + n.textBlock.height - n.textBlock._lineHeight / 2) - 5) : 0 > this.labelAngle ? (p.x = p.x - ("inside" === this.labelPlacement ? n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0) + n.textBlock.topPadding * Math.sin(Math.PI / 180 * this.labelAngle), p.y = "inside" === this.labelPlacement ? p.y + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 - n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + n.textBlock._lineHeight / 2 * Math.cos(Math.PI / 180 * this.labelAngle) : p.y - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5 - (n.textBlock.height - n.textBlock._lineHeight / 2) * Math.cos(Math.PI / 180 * this.labelAngle)) : (p.x = p.x - ("inside" === this.labelPlacement ? 0 : n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + n.textBlock.topPadding * Math.sin(Math.PI / 180 * this.labelAngle), p.y = "inside" === this.labelPlacement ? p.y + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 + n.textBlock._lineHeight / 2 * Math.cos(Math.PI / 180 * this.labelAngle) : p.y - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5 - ((n.textBlock.height - n.textBlock._lineHeight / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle))), n.textBlock.x = p.x, n.textBlock.y = p.y));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a._labels.length; k++) if (n = a._labels[k], !(n.position < a.viewportMinimum || n.position > a.viewportMaximum) && (p = a.getPixelCoordinatesOnAxis(n.position), a.tickThickness)) {
                a.ctx.lineWidth = a.tickThickness;
                a.ctx.strokeStyle = a.tickColor;
                var b2 = 1 === a.ctx.lineWidth % 2 ? (p.x << 0) + 0.5 : p.x << 0;
                a.ctx.save();
                a.ctx.beginPath();
                a.ctx.moveTo(b2, p.y << 0);
                a.ctx.lineTo(b2, p.y + a.tickLength << 0);
                a.ctx.stroke();
                a.ctx.restore();
              }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + this._titleTextBlock._lineHeight / 2 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("left" === this._position) {
            for (k = 0; k < this._labels.length; k++) n = this._labels[k], n.position < this.viewportMinimum || n.position > this.viewportMaximum || (p = this.getPixelCoordinatesOnAxis(n.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (p.y << 0) + 0.5 : p.y << 0, this.ctx.beginPath(), this.ctx.moveTo(p.x << 0, b), this.ctx.lineTo(p.x - this.tickLength << 0, b), this.ctx.stroke()), e && 0 !== f++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (n.textBlock.y = p.y - n.textBlock.topPadding, n.textBlock.x = "inside" === this.labelPlacement ? p.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : p.x - n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5) : 0 > this.labelAngle ? (n.textBlock.y = ("inside" === this.labelPlacement ? p.y : p.y - n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)) - n.textBlock.topPadding * Math.cos(Math.PI / 180 * this.labelAngle), n.textBlock.x = "inside" === this.labelPlacement ? p.x - n.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : p.x - n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (n.textBlock.height - n.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5) : (n.textBlock.y = ("inside" === this.labelPlacement ? p.y : p.y - n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)) - n.textBlock.topPadding * Math.cos(Math.PI / 180 * this.labelAngle), n.textBlock.x = "inside" === this.labelPlacement ? p.x + (n.textBlock.height - n.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : p.x - n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - n.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5)));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a._labels.length; k++) if (n = a._labels[k], !(n.position < a.viewportMinimum || n.position > a.viewportMaximum) && (p = a.getPixelCoordinatesOnAxis(n.position), a.tickThickness)) {
                a.ctx.lineWidth = a.tickThickness;
                a.ctx.strokeStyle = a.tickColor;
                var b2 = 1 === a.ctx.lineWidth % 2 ? (p.y << 0) + 0.5 : p.y << 0;
                a.ctx.save();
                a.ctx.beginPath();
                a.ctx.moveTo(p.x << 0, b2);
                a.ctx.lineTo(p.x + a.tickLength << 0, b2);
                a.ctx.stroke();
                a.ctx.restore();
              }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + this._titleTextBlock._lineHeight / 2, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("right" === this._position) {
            for (k = 0; k < this._labels.length; k++) n = this._labels[k], n.position < this.viewportMinimum || n.position > this.viewportMaximum || (p = this.getPixelCoordinatesOnAxis(n.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (p.y << 0) + 0.5 : p.y << 0, this.ctx.beginPath(), this.ctx.moveTo(p.x << 0, b), this.ctx.lineTo(p.x + this.tickLength << 0, b), this.ctx.stroke()), e && 0 !== f++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (n.textBlock.y = p.y - n.textBlock.topPadding, n.textBlock.x = "inside" === this.labelPlacement ? p.x - n.textBlock.width - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : p.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5) : 0 > this.labelAngle ? (n.textBlock.y = ("inside" === this.labelPlacement ? p.y - n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : p.y) - n.textBlock.topPadding * Math.cos(Math.PI / 180 * this.labelAngle), n.textBlock.x = "inside" === this.labelPlacement ? p.x - n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (n.textBlock.height - n.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : p.x - n.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5) : (n.textBlock.y = ("inside" === this.labelPlacement ? p.y - n.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : p.y) - n.textBlock.topPadding * Math.cos(Math.PI / 180 * this.labelAngle), n.textBlock.x = "inside" === this.labelPlacement ? p.x - n.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - n.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : p.x + (n.textBlock.height - n.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5)));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a._labels.length; k++) if (n = a._labels[k], !(n.position < a.viewportMinimum || n.position > a.viewportMaximum) && (p = a.getPixelCoordinatesOnAxis(n.position), a.tickThickness)) {
                a.ctx.lineWidth = a.tickThickness;
                a.ctx.strokeStyle = a.tickColor;
                var b2 = 1 === a.ctx.lineWidth % 2 ? (p.y << 0) + 0.5 : p.y << 0;
                a.ctx.save();
                a.ctx.beginPath();
                a.ctx.moveTo(p.x << 0, b2);
                a.ctx.lineTo(p.x - a.tickLength << 0, b2);
                a.ctx.stroke();
                a.ctx.restore();
              }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - this._titleTextBlock._lineHeight / 2, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          }
          f = 0;
          if ("inside" === this.labelPlacement) this.chart.addEventListener(
            "dataAnimationIterationEnd",
            function() {
              for (k = 0; k < a._labels.length; k++) n = a._labels[k], n.position < a.viewportMinimum || (n.position > a.viewportMaximum || e && 0 !== f++ % 2 && a.labelAutoFit) || (a.ctx.save(), a.ctx.beginPath(), n.textBlock.render(true), a.ctx.restore());
            },
            this
          );
          else for (k = 0; k < this._labels.length; k++) n = this._labels[k], n.position < this.viewportMinimum || (n.position > this.viewportMaximum || e && 0 !== f++ % 2 && this.labelAutoFit) || n.textBlock.render(true);
        };
        B.prototype.renderInterlacedColors = function() {
          var a = this.chart.plotArea.ctx, e, c, b = this.chart.plotArea, d = 0;
          e = true;
          if (("bottom" === this._position || "top" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, d = 0; d < this._labels.length; d++) e ? (e = this.getPixelCoordinatesOnAxis(this._labels[d].position), c = d + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[d + 1].position), a.fillRect(Math.min(c.x, e.x), b.y1, Math.abs(c.x - e.x), Math.abs(b.y1 - b.y2)), e = false) : e = true;
          else if (("left" === this._position || "right" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, d = 0; d < this._labels.length; d++) e ? (c = this.getPixelCoordinatesOnAxis(this._labels[d].position), e = d + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[d + 1].position), a.fillRect(b.x1, Math.min(c.y, e.y), Math.abs(b.x1 - b.x2), Math.abs(e.y - c.y)), e = false) : e = true;
          a.beginPath();
        };
        B.prototype.renderStripLinesOfThicknessType = function(a) {
          if (this.stripLines && 0 < this.stripLines.length && a) {
            var e = this, c, b, d = 0, f = 0, g2 = false;
            b = false;
            for (var r2 = [], t2 = [], k = false, m, d = 0; d < this.stripLines.length; d++) {
              var n = this.stripLines[d];
              n._thicknessType === a && ("pixel" === a && (n.value < this.viewportMinimum || n.value > this.viewportMaximum || l(n.value) || isNaN(this.range)) || "value" === a && (n.startValue <= this.viewportMinimum && n.endValue <= this.viewportMinimum || n.startValue >= this.viewportMaximum && n.endValue >= this.viewportMaximum || l(n.startValue) || l(n.endValue) || isNaN(this.range)) || r2.push(n));
            }
            for (d = 0; d < this._stripLineLabels.length; d++) if (n = this.stripLines[d], c = this._stripLineLabels[d], !(c.position < this.viewportMinimum || c.position > this.viewportMaximum || isNaN(this.range))) if (b = this.getPixelCoordinatesOnAxis(c.position), "outside" === c.stripLine.labelPlacement) {
              n && (this.ctx.strokeStyle = n.color, this.ctx.lineWidth = "pixel" === n._thicknessType ? n.thickness : this.tickThickness, l(n.opacity) || "pixel" !== n._thicknessType || (m = n.ctx.globalAlpha, n.ctx.globalAlpha = n.opacity));
              if ("bottom" === this._position) {
                var p = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + 0.5 : b.x << 0;
                this.ctx.beginPath();
                this.ctx.moveTo(p, b.y << 0);
                this.ctx.lineTo(p, b.y + this.tickLength << 0);
                this.ctx.stroke();
                0 === this.labelAngle ? (b.x -= c.textBlock.width / 2, b.y += this.tickLength + c.textBlock.fontSize / 2 + 5) : (b.x -= (0 > this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0) - c.textBlock.topPadding * Math.sin(Math.PI / 180 * this.labelAngle), b.y += this.tickLength + 5 + (0 > this.labelAngle ? Math.abs(c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - c.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle)) : Math.abs(c.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle))));
              } else "top" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + 0.5 : b.x << 0, this.ctx.beginPath(), this.ctx.moveTo(p, b.y << 0), this.ctx.lineTo(p, b.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (b.x -= c.textBlock.width / 2, b.y -= this.tickLength + c.textBlock.height - c.textBlock.fontSize / 2) : (b.x -= (0 < this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0) - c.textBlock.topPadding * Math.sin(Math.PI / 180 * this.labelAngle), b.y -= this.tickLength + 2 + (0 < this.labelAngle ? (c.textBlock.height - c.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : (c.textBlock.height - c.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle)))) : "left" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + 0.5 : b.y << 0, this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, p), this.ctx.lineTo(b.x - this.tickLength << 0, p), this.ctx.stroke(), 0 === this.labelAngle ? (b.x = b.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5, b.y -= c.textBlock.topPadding) : (b.y -= c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + c.textBlock.topPadding * Math.cos(Math.PI / 180 * this.labelAngle), b.x -= this.tickLength + 5 + (0 < this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + c.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) : c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - (c.textBlock.height - c.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)))) : "right" === this._position && (p = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + 0.5 : b.y << 0, this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, p), this.ctx.lineTo(b.x + this.tickLength << 0, p), this.ctx.stroke(), 0 === this.labelAngle ? (b.x = b.x + this.tickLength + 5, b.y -= c.textBlock.topPadding) : (b.y -= c.textBlock.topPadding * Math.cos(Math.PI / 180 * this.labelAngle), b.x = this.tickLength + 5 + (0 < this.labelAngle ? b.x + (c.textBlock.height - c.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) : b.x - c.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle))));
              m && (n.ctx.globalAlpha = m);
              c.textBlock.x = b.x;
              c.textBlock.y = b.y;
              t2.push(c);
            } else n._thicknessType === a && (c.textBlock.angle = -90, "bottom" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[d].labelMaxWidth ? this.options.stripLines[d].labelMaxWidth : this.chart.plotArea.height - 3, c.textBlock.measureText(), b.x - c.textBlock.height - n.thickness / 2 > this.chart.plotArea.x1 ? l(n.startValue) ? b.x -= c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : (c.textBlock.angle = 90, l(n.startValue) ? b.x += c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2), b.y = -90 === c.textBlock.angle ? "near" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y1 + c.textBlock.width + 3 : "near" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - c.textBlock.width - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[d].labelMaxWidth ? this.options.stripLines[d].labelMaxWidth : this.chart.plotArea.height - 3, c.textBlock.measureText(), b.x - c.textBlock.height - n.thickness / 2 > this.chart.plotArea.x1 ? l(n.startValue) ? b.x -= c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : (c.textBlock.angle = 90, l(n.startValue) ? b.x += c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2), b.y = -90 === c.textBlock.angle ? "near" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + c.textBlock.width + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y2 - c.textBlock.width - 3) : "left" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[d].labelMaxWidth ? this.options.stripLines[d].labelMaxWidth : this.chart.plotArea.width - 3, c.textBlock.angle = 0, c.textBlock.measureText(), b.y - c.textBlock.height - n.thickness / 2 > this.chart.plotArea.y1 ? l(n.startValue) ? b.y -= c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : l(n.startValue) ? b.y += c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.y += c.textBlock.height / 2 - c.textBlock.fontSize + 3, b.x = "near" === c.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x2 - c.textBlock.width - 3) : "right" === this._position && (c.textBlock.maxWidth = this.options.stripLines[d].labelMaxWidth ? this.options.stripLines[d].labelMaxWidth : this.chart.plotArea.width - 3, c.textBlock.angle = 0, c.textBlock.measureText(), b.y - c.textBlock.height - n.thickness / 2 > this.chart.plotArea.y1 ? l(n.startValue) ? b.y -= c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : l(n.startValue) ? b.y += c.textBlock.height - c.textBlock.fontSize / 2 + n.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3, b.x = "near" === c.stripLine.labelAlign ? this.chart.plotArea.x2 - c.textBlock.width - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x1 + 3), c.textBlock.x = b.x, c.textBlock.y = b.y, t2.push(c));
            if (!k) {
              b = false;
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
              this.ctx.clip();
              for (d = 0; d < r2.length; d++) n = r2[d], n.showOnTop ? g2 || (g2 = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                this.ctx.clip();
                for (f = 0; f < r2.length; f++) n = r2[f], n.showOnTop && n.render();
                this.ctx.restore();
              }, n)) : n.render();
              for (d = 0; d < t2.length; d++) c = t2[d], c.stripLine.showOnTop ? b || (b = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                for (f = 0; f < t2.length; f++) c = t2[f], "inside" === c.stripLine.labelPlacement && c.stripLine.showOnTop && (e.ctx.save(), e.ctx.beginPath(), e.ctx.rect(
                  e.chart.plotArea.x1,
                  e.chart.plotArea.y1,
                  e.chart.plotArea.width,
                  e.chart.plotArea.height
                ), e.ctx.clip(), c.textBlock.render(true), e.ctx.restore());
              }, c.textBlock)) : "inside" === c.stripLine.labelPlacement && c.textBlock.render(true);
              this.ctx.restore();
              k = true;
            }
            if (k) for (b = false, d = 0; d < t2.length; d++) c = t2[d], "outside" === c.stripLine.labelPlacement && c.textBlock.render(true);
          }
        };
        B.prototype.renderBreaksBackground = function() {
          this.chart._breaksCanvas && (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());
        };
        B.prototype.createMask = function() {
          if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
            var a = this.scaleBreaks._appliedBreaks;
            r ? (this.maskCanvas = sa(
              this.chart.width,
              this.chart.height
            ), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);
            this.maskCtx.save();
            this.maskCtx.beginPath();
            this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.maskCtx.clip();
            for (var e = 0; e < a.length; e++) a[e].endValue < this.viewportMinimum || (a[e].startValue > this.viewportMaximum || isNaN(this.range)) || a[e].render(this.maskCtx);
            this.maskCtx.restore();
          }
        };
        B.prototype.renderCrosshair = function(a, e) {
          isFinite(this.minimum) && isFinite(this.maximum) && this.crosshair.render(a, e);
        };
        B.prototype.showCrosshair = function(a) {
          l(a) || (a < this.viewportMinimum || a > this.viewportMaximum) || ("top" === this._position || "bottom" === this._position ? this.crosshair.render(this.convertValueToPixel(a), null, a) : this.crosshair.render(null, this.convertValueToPixel(a), a));
        };
        B.prototype.renderGrid = function() {
          if (this.gridThickness && 0 < this.gridThickness) {
            var a = this.chart.ctx;
            a.save();
            var e, c = this.chart.plotArea;
            a.lineWidth = this.gridThickness;
            a.strokeStyle = this.gridColor;
            a.setLineDash && a.setLineDash(K(this.gridDashType, this.gridThickness));
            if ("bottom" === this._position || "top" === this._position) for (b = 0; b < this._labels.length; b++) this._labels[b].position < this.viewportMinimum || (this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType) || (a.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[b].position), e = 1 === a.lineWidth % 2 ? (e.x << 0) + 0.5 : e.x << 0, a.moveTo(e, c.y1 << 0), a.lineTo(e, c.y2 << 0), a.stroke());
            else if ("left" === this._position || "right" === this._position) for (var b = 0; b < this._labels.length; b++) this._labels[b].position < this.viewportMinimum || (this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType) || (a.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[b].position), e = 1 === a.lineWidth % 2 ? (e.y << 0) + 0.5 : e.y << 0, a.moveTo(c.x1 << 0, e), a.lineTo(c.x2 << 0, e), a.stroke());
            a.restore();
          }
        };
        B.prototype.renderAxisLine = function() {
          var a = this.chart.ctx, e = r ? this.chart._preRenderCtx : a, c = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), b = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)), d, f;
          e.save();
          if ("bottom" === this._position || "top" === this._position) {
            if (this.lineThickness) {
              this.reversed ? (d = this.lineCoordinates.x2, f = this.lineCoordinates.x1) : (d = this.lineCoordinates.x1, f = this.lineCoordinates.x2);
              e.lineWidth = this.lineThickness;
              e.strokeStyle = this.lineColor ? this.lineColor : "black";
              e.setLineDash && e.setLineDash(K(this.lineDashType, this.lineThickness));
              var g2 = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;
              e.beginPath();
              if (this.scaleBreaks && !l(this.scaleBreaks.firstBreakIndex)) if (l(this.scaleBreaks.lastBreakIndex)) d = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;
              else for (var t2 = this.scaleBreaks.firstBreakIndex; t2 <= this.scaleBreaks.lastBreakIndex; t2++) e.moveTo(d, g2), e.lineTo(this.scaleBreaks._appliedBreaks[t2].startPixel + c, g2), d = this.scaleBreaks._appliedBreaks[t2].endPixel + b;
              d && (e.moveTo(d, g2), e.lineTo(f, g2));
              e.stroke();
            }
          } else if (("left" === this._position || "right" === this._position) && this.lineThickness) {
            this.reversed ? (d = this.lineCoordinates.y1, f = this.lineCoordinates.y2) : (d = this.lineCoordinates.y2, f = this.lineCoordinates.y1);
            e.lineWidth = this.lineThickness;
            e.strokeStyle = this.lineColor;
            e.setLineDash && e.setLineDash(K(this.lineDashType, this.lineThickness));
            g2 = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;
            e.beginPath();
            if (this.scaleBreaks && !l(this.scaleBreaks.firstBreakIndex)) if (l(this.scaleBreaks.lastBreakIndex)) d = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c;
            else for (t2 = this.scaleBreaks.firstBreakIndex; t2 <= this.scaleBreaks.lastBreakIndex; t2++) e.moveTo(g2, d), e.lineTo(g2, this.scaleBreaks._appliedBreaks[t2].startPixel + b), d = this.scaleBreaks._appliedBreaks[t2].endPixel + c;
            d && (e.moveTo(g2, d), e.lineTo(g2, f));
            e.stroke();
          }
          r && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), e.clearRect(
            0,
            0,
            this.chart.width,
            this.chart.height
          ));
          e.restore();
        };
        B.prototype.getPixelCoordinatesOnAxis = function(a) {
          var e = {};
          if ("bottom" === this._position || "top" === this._position) e.x = this.convertValueToPixel(a), e.y = this.lineCoordinates.y1;
          if ("left" === this._position || "right" === this._position) e.y = this.convertValueToPixel(a), e.x = this.lineCoordinates.x2;
          return e;
        };
        B.prototype.convertPixelToValue = function(a) {
          if ("undefined" === typeof a) return null;
          var e = 0, c = 0, b, e = true, d = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c = "number" === typeof a ? a : "left" === this._position || "right" === this._position ? a.y : a.x;
          if (this.logarithmic) {
            a = b = Math.pow(this.logarithmBase, (c - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);
            if (c <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) for (c = 0; c < d.length; c++) {
              if (!(d[c].endValue < this.conversionParameters.minimum)) if (e) if (d[c].startValue < this.conversionParameters.minimum) {
                if (1 < d[c].size && this.conversionParameters.minimum * Math.pow(d[c].endValue / d[c].startValue, Math.log(b) / Math.log(d[c].size)) < d[c].endValue) {
                  a = Math.pow(d[c].endValue / d[c].startValue, Math.log(b) / Math.log(d[c].size));
                  break;
                } else a *= d[c].endValue / this.conversionParameters.minimum / Math.pow(d[c].size, Math.log(d[c].endValue / this.conversionParameters.minimum) / Math.log(d[c].endValue / d[c].startValue)), b /= Math.pow(d[c].size, Math.log(d[c].endValue / this.conversionParameters.minimum) / Math.log(d[c].endValue / d[c].startValue));
                e = false;
              } else if (b > d[c].startValue / this.conversionParameters.minimum) {
                b /= d[c].startValue / this.conversionParameters.minimum;
                if (b < d[c].size) {
                  a *= Math.pow(d[c].endValue / d[c].startValue, 1 === d[c].size ? 1 : Math.log(b) / Math.log(d[c].size)) / b;
                  break;
                } else a *= d[c].endValue / d[c].startValue / d[c].size;
                b /= d[c].size;
                e = false;
              } else break;
              else if (b > d[c].startValue / d[c - 1].endValue) {
                b /= d[c].startValue / d[c - 1].endValue;
                if (b < d[c].size) {
                  a *= Math.pow(d[c].endValue / d[c].startValue, 1 === d[c].size ? 1 : Math.log(b) / Math.log(d[c].size)) / b;
                  break;
                } else a *= d[c].endValue / d[c].startValue / d[c].size;
                b /= d[c].size;
              } else break;
            }
            else for (c = d.length - 1; 0 <= c; c--) if (!(d[c].startValue > this.conversionParameters.minimum)) if (e) if (d[c].endValue > this.conversionParameters.minimum) {
              if (1 < d[c].size && this.conversionParameters.minimum * Math.pow(d[c].endValue / d[c].startValue, Math.log(b) / Math.log(d[c].size)) > d[c].startValue) {
                a = Math.pow(d[c].endValue / d[c].startValue, Math.log(b) / Math.log(d[c].size));
                break;
              } else a *= d[c].startValue / this.conversionParameters.minimum * Math.pow(d[c].size, Math.log(d[c].startValue / this.conversionParameters.minimum) / Math.log(d[c].endValue / d[c].startValue)) * b, b *= Math.pow(d[c].size, Math.log(this.conversionParameters.minimum / d[c].startValue) / Math.log(d[c].endValue / d[c].startValue));
              e = false;
            } else if (b < d[c].endValue / this.conversionParameters.minimum) {
              b /= d[c].endValue / this.conversionParameters.minimum;
              if (b > 1 / d[c].size) {
                a *= Math.pow(d[c].endValue / d[c].startValue, 1 >= d[c].size ? 1 : Math.log(b) / Math.log(d[c].size)) * b;
                break;
              } else a /= d[c].endValue / d[c].startValue / d[c].size;
              b *= d[c].size;
              e = false;
            } else break;
            else if (b < d[c].endValue / d[c + 1].startValue) {
              b /= d[c].endValue / d[c + 1].startValue;
              if (b > 1 / d[c].size) {
                a *= Math.pow(d[c].endValue / d[c].startValue, 1 >= d[c].size ? 1 : Math.log(b) / Math.log(d[c].size)) * b;
                break;
              } else a /= d[c].endValue / d[c].startValue / d[c].size;
              b *= d[c].size;
            } else break;
            e = a * this.viewportMinimum;
          } else {
            a = b = (c - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;
            if (c <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) for (c = 0; c < d.length; c++) {
              if (!(d[c].endValue < this.conversionParameters.minimum)) if (e) if (d[c].startValue < this.conversionParameters.minimum) {
                if (d[c].size && this.conversionParameters.minimum + b * (d[c].endValue - d[c].startValue) / d[c].size < d[c].endValue) {
                  a = 0 >= d[c].size ? 0 : b * (d[c].endValue - d[c].startValue) / d[c].size;
                  break;
                } else a += d[c].endValue - this.conversionParameters.minimum - d[c].size * (d[c].endValue - this.conversionParameters.minimum) / (d[c].endValue - d[c].startValue), b -= d[c].size * (d[c].endValue - this.conversionParameters.minimum) / (d[c].endValue - d[c].startValue);
                e = false;
              } else if (b > d[c].startValue - this.conversionParameters.minimum) {
                b -= d[c].startValue - this.conversionParameters.minimum;
                if (b < d[c].size) {
                  a += (d[c].endValue - d[c].startValue) * (0 === d[c].size ? 1 : b / d[c].size) - b;
                  break;
                } else a += d[c].endValue - d[c].startValue - d[c].size;
                b -= d[c].size;
                e = false;
              } else break;
              else if (b > d[c].startValue - d[c - 1].endValue) {
                b -= d[c].startValue - d[c - 1].endValue;
                if (b < d[c].size) {
                  a += (d[c].endValue - d[c].startValue) * (0 === d[c].size ? 1 : b / d[c].size) - b;
                  break;
                } else a += d[c].endValue - d[c].startValue - d[c].size;
                b -= d[c].size;
              } else break;
            }
            else for (c = d.length - 1; 0 <= c; c--) if (!(d[c].startValue > this.conversionParameters.minimum)) if (e) if (d[c].endValue > this.conversionParameters.minimum) if (d[c].size && this.conversionParameters.minimum + b * (d[c].endValue - d[c].startValue) / d[c].size > d[c].startValue) {
              a = 0 >= d[c].size ? 0 : b * (d[c].endValue - d[c].startValue) / d[c].size;
              break;
            } else a += d[c].startValue - this.conversionParameters.minimum + d[c].size * (this.conversionParameters.minimum - d[c].startValue) / (d[c].endValue - d[c].startValue), b += d[c].size * (this.conversionParameters.minimum - d[c].startValue) / (d[c].endValue - d[c].startValue), e = false;
            else if (b < d[c].endValue - this.conversionParameters.minimum) {
              b -= d[c].endValue - this.conversionParameters.minimum;
              if (b > -1 * d[c].size) {
                a += (d[c].endValue - d[c].startValue) * (0 === d[c].size ? 1 : b / d[c].size) + b;
                break;
              } else a -= d[c].endValue - d[c].startValue - d[c].size;
              b += d[c].size;
              e = false;
            } else break;
            else if (b < d[c].endValue - d[c + 1].startValue) {
              b -= d[c].endValue - d[c + 1].startValue;
              if (b > -1 * d[c].size) {
                a += (d[c].endValue - d[c].startValue) * (0 === d[c].size ? 1 : b / d[c].size) + b;
                break;
              } else a -= d[c].endValue - d[c].startValue - d[c].size;
              b += d[c].size;
            } else break;
            e = this.conversionParameters.minimum + a;
          }
          return e;
        };
        B.prototype.convertValueToPixel = function(a) {
          a = this.getApparentDifference(this.conversionParameters.minimum, a, a);
          return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5;
        };
        B.prototype.getApparentDifference = function(a, e, c, b) {
          var d = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          if (this.logarithmic) {
            c = l(c) ? e / a : c;
            for (var f = 0; f < d.length && !(e < d[f].startValue); f++) a > d[f].endValue || (a <= d[f].startValue && e >= d[f].endValue ? c = c / d[f].endValue * d[f].startValue * d[f].size : a >= d[f].startValue && e >= d[f].endValue ? c = c / d[f].endValue * a * Math.pow(d[f].size, Math.log(d[f].endValue / a) / Math.log(d[f].endValue / d[f].startValue)) : a <= d[f].startValue && e <= d[f].endValue ? c = c / e * d[f].startValue * Math.pow(d[f].size, Math.log(e / d[f].startValue) / Math.log(d[f].endValue / d[f].startValue)) : !b && (a > d[f].startValue && e < d[f].endValue) && (c = a * Math.pow(d[f].size, Math.log(e / a) / Math.log(d[f].endValue / d[f].startValue))));
          } else for (c = l(c) ? Math.abs(e - a) : c, f = 0; f < d.length && !(e < d[f].startValue); f++) a > d[f].endValue || (a <= d[f].startValue && e >= d[f].endValue ? c = c - d[f].endValue + d[f].startValue + d[f].size : a > d[f].startValue && e >= d[f].endValue ? c = c - d[f].endValue + a + d[f].size * (d[f].endValue - a) / (d[f].endValue - d[f].startValue) : a <= d[f].startValue && e < d[f].endValue ? c = c - e + d[f].startValue + d[f].size * (e - d[f].startValue) / (d[f].endValue - d[f].startValue) : !b && (a > d[f].startValue && e < d[f].endValue) && (c = a + d[f].size * (e - a) / (d[f].endValue - d[f].startValue)));
          return c;
        };
        B.prototype.setViewPortRange = function(a, e) {
          this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, e);
          this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, e);
        };
        B.prototype.getXValueAt = function(a) {
          if (!a) return null;
          var e = null;
          "left" === this._position ? e = this.convertPixelToValue(a.y) : "bottom" === this._position && (e = this.convertPixelToValue(a.x));
          return e;
        };
        B.prototype.calculateValueToPixelConversionParameters = function(a) {
          a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          var e = { pixelPerUnit: null, minimum: null, reference: null }, c = this.lineCoordinates.width, b = this.lineCoordinates.height, c = "bottom" === this._position || "top" === this._position ? c : b, b = Math.abs(this.range);
          if (this.logarithmic) for (var d = 0; d < a.length && !(this.viewportMaximum < a[d].startValue); d++) this.viewportMinimum > a[d].endValue || (this.viewportMinimum >= a[d].startValue && this.viewportMaximum <= a[d].endValue ? c = 0 : this.viewportMinimum <= a[d].startValue && this.viewportMaximum >= a[d].endValue ? (b = b / a[d].endValue * a[d].startValue, c = 0 < a[d].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[d].spacing) / 100) : c - Math.min(a[d].spacing, 0.1 * c)) : this.viewportMinimum > a[d].startValue && this.viewportMaximum >= a[d].endValue ? (b = b / a[d].endValue * this.viewportMinimum, c = 0 < a[d].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[d].spacing) / 100 * Math.log(a[d].endValue / this.viewportMinimum) / Math.log(a[d].endValue / a[d].startValue)) : c - Math.min(a[d].spacing, 0.1 * c) * Math.log(a[d].endValue / this.viewportMinimum) / Math.log(a[d].endValue / a[d].startValue)) : this.viewportMinimum <= a[d].startValue && this.viewportMaximum < a[d].endValue && (b = b / this.viewportMaximum * a[d].startValue, c = 0 < a[d].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[d].spacing) / 100 * Math.log(this.viewportMaximum / a[d].startValue) / Math.log(a[d].endValue / a[d].startValue)) : c - Math.min(a[d].spacing, 0.1 * c) * Math.log(this.viewportMaximum / a[d].startValue) / Math.log(a[d].endValue / a[d].startValue)));
          else for (d = 0; d < a.length && !(this.viewportMaximum < a[d].startValue); d++) this.viewportMinimum > a[d].endValue || (this.viewportMinimum >= a[d].startValue && this.viewportMaximum <= a[d].endValue ? c = 0 : this.viewportMinimum <= a[d].startValue && this.viewportMaximum >= a[d].endValue ? (b = b - a[d].endValue + a[d].startValue, c = 0 < a[d].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[d].spacing) / 100) : c - Math.min(a[d].spacing, 0.1 * c)) : this.viewportMinimum > a[d].startValue && this.viewportMaximum >= a[d].endValue ? (b = b - a[d].endValue + this.viewportMinimum, c = 0 < a[d].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[d].spacing) / 100 * (a[d].endValue - this.viewportMinimum) / (a[d].endValue - a[d].startValue)) : c - Math.min(a[d].spacing, 0.1 * c) * (a[d].endValue - this.viewportMinimum) / (a[d].endValue - a[d].startValue)) : this.viewportMinimum <= a[d].startValue && this.viewportMaximum < a[d].endValue && (b = b - this.viewportMaximum + a[d].startValue, c = 0 < a[d].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[d].spacing) / 100 * (this.viewportMaximum - a[d].startValue) / (a[d].endValue - a[d].startValue)) : c - Math.min(a[d].spacing, 0.1 * c) * (this.viewportMaximum - a[d].startValue) / (a[d].endValue - a[d].startValue)));
          e.minimum = this.viewportMinimum;
          e.maximum = this.viewportMaximum;
          e.range = b;
          if ("bottom" === this._position || "top" === this._position) this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? -1 : 1) * c * e.lnLogarithmBase / Math.log(Math.abs(b))) : e.pixelPerUnit = (this.reversed ? -1 : 1) * c / Math.abs(b), e.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;
          if ("left" === this._position || "right" === this._position) this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? 1 : -1) * c * e.lnLogarithmBase / Math.log(Math.abs(b))) : e.pixelPerUnit = (this.reversed ? 1 : -1) * c / Math.abs(b), e.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;
          this.conversionParameters = e;
        };
        B.prototype.calculateAxisParameters = function() {
          if (this.logarithmic) this.calculateLogarithmicAxisParameters();
          else {
            var a = this.chart.layoutManager.getFreeSpace(), e = false, c = false;
            "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
            var a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40, b = 4;
            "axisX" === this.type && (b = 600 > this.maxWidth ? 8 : 6);
            var a = Math.max(b, Math.floor(this.maxWidth / a)), d, f, g2, b = 0;
            !l(this.options.viewportMinimum) && (!l(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) && (this.viewportMinimum = this.viewportMaximum = null);
            if (l(this.options.viewportMinimum) && !l(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum)) this.viewportMinimum = this.sessionVariables.newViewportMinimum;
            else if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;
            if (l(this.options.viewportMaximum) && !l(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum)) this.viewportMaximum = this.sessionVariables.newViewportMaximum;
            else if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;
            !l(this.minimum) && this.viewportMinimum < this.minimum && (this.viewportMinimum = this.minimum);
            !l(this.maximum) && this.viewportMaximum > this.maximum && (this.viewportMaximum = this.maximum);
            if (this.scaleBreaks) {
              for (b = 0; b < this.scaleBreaks._appliedBreaks.length; b++) if ((!l(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue || !l(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[b].startValue || !l(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue) && (!l(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue || !l(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[b].endValue || !l(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue)) {
                this.scaleBreaks._appliedBreaks.splice(b, 1);
                break;
              }
            }
            if ("axisX" === this.type) {
              if (this.dataSeries && 0 < this.dataSeries.length) for (d = 0; d < this.dataSeries.length; d++) "dateTime" === this.dataSeries[d].xValueType && (c = true);
              d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;
              f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;
              0 === f - d && (b = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, f += b, d -= b);
              Infinity !== this.dataInfo.minDiff ? g2 = this.dataInfo.minDiff : 1 < f - d ? g2 = 0.5 * Math.abs(f - d) : (g2 = 1, c && (e = true));
            } else "axisY" === this.type && (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(d) || isFinite(f) ? isFinite(d) ? isFinite(f) || (f = d) : d = f : (f = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, d = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === d && 0 === f ? (f += 9, d = 0) : 0 === f - d ? (b = Math.min(Math.abs(0.01 * Math.abs(f)), 5), f += b, d -= b) : d > f ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(f, d, null, true)), 5), 0 <= f ? d = f - b : f = isFinite(d) ? d + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(d, f, null, true)), 0.05), 0 !== f && (f += b), 0 !== d && (d -= b)), g2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < f - d ? 0.5 * Math.abs(f - d) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < d && (d = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > f && (f = 0));
            b = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? d : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? f : this.viewportMaximum, null, true);
            if ("axisX" === this.type && c) {
              this.valueType = "dateTime";
              this.intervalType || (b / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : b / 2 <= a ? (this.interval = 2, this.intervalType = "millisecond") : b / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : b / 10 <= a ? (this.interval = 10, this.intervalType = "millisecond") : b / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : b / 50 <= a ? (this.interval = 50, this.intervalType = "millisecond") : b / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : b / 200 <= a ? (this.interval = 200, this.intervalType = "millisecond") : b / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : b / 300 <= a ? (this.interval = 300, this.intervalType = "millisecond") : b / 400 <= a ? (this.interval = 400, this.intervalType = "millisecond") : b / 500 <= a ? (this.interval = 500, this.intervalType = "millisecond") : b / (1 * V.secondDuration) <= a ? (this.interval = 1, this.intervalType = "second") : b / (2 * V.secondDuration) <= a ? (this.interval = 2, this.intervalType = "second") : b / (5 * V.secondDuration) <= a ? (this.interval = 5, this.intervalType = "second") : b / (10 * V.secondDuration) <= a ? (this.interval = 10, this.intervalType = "second") : b / (15 * V.secondDuration) <= a ? (this.interval = 15, this.intervalType = "second") : b / (20 * V.secondDuration) <= a ? (this.interval = 20, this.intervalType = "second") : b / (30 * V.secondDuration) <= a ? (this.interval = 30, this.intervalType = "second") : b / (1 * V.minuteDuration) <= a ? (this.interval = 1, this.intervalType = "minute") : b / (2 * V.minuteDuration) <= a ? (this.interval = 2, this.intervalType = "minute") : b / (5 * V.minuteDuration) <= a ? (this.interval = 5, this.intervalType = "minute") : b / (10 * V.minuteDuration) <= a ? (this.interval = 10, this.intervalType = "minute") : b / (15 * V.minuteDuration) <= a ? (this.interval = 15, this.intervalType = "minute") : b / (20 * V.minuteDuration) <= a ? (this.interval = 20, this.intervalType = "minute") : b / (30 * V.minuteDuration) <= a ? (this.interval = 30, this.intervalType = "minute") : b / (1 * V.hourDuration) <= a ? (this.interval = 1, this.intervalType = "hour") : b / (2 * V.hourDuration) <= a ? (this.interval = 2, this.intervalType = "hour") : b / (3 * V.hourDuration) <= a ? (this.interval = 3, this.intervalType = "hour") : b / (6 * V.hourDuration) <= a ? (this.interval = 6, this.intervalType = "hour") : b / (1 * V.dayDuration) <= a ? (this.interval = 1, this.intervalType = "day") : b / (2 * V.dayDuration) <= a ? (this.interval = 2, this.intervalType = "day") : b / (4 * V.dayDuration) <= a ? (this.interval = 4, this.intervalType = "day") : b / (1 * V.weekDuration) <= a ? (this.interval = 1, this.intervalType = "week") : b / (2 * V.weekDuration) <= a ? (this.interval = 2, this.intervalType = "week") : b / (3 * V.weekDuration) <= a ? (this.interval = 3, this.intervalType = "week") : b / (1 * V.monthDuration) <= a ? (this.interval = 1, this.intervalType = "month") : b / (2 * V.monthDuration) <= a ? (this.interval = 2, this.intervalType = "month") : b / (3 * V.monthDuration) <= a ? (this.interval = 3, this.intervalType = "month") : b / (6 * V.monthDuration) <= a ? (this.interval = 6, this.intervalType = "month") : (this.interval = b / (1 * V.yearDuration) <= a ? 1 : b / (2 * V.yearDuration) <= a ? 2 : b / (4 * V.yearDuration) <= a ? 4 : Math.floor(B.getNiceNumber(b / (a - 1), true) / V.yearDuration), this.intervalType = "year"));
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = d - g2 / 2;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = f + g2 / 2;
              e ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'");
              this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);
            } else {
              this.intervalType = "number";
              b = B.getNiceNumber(b, false);
              this.interval = this.options && 0 < this.options.interval ? this.options.interval : B.getNiceNumber(b / (a - 1), true);
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? d - g2 / 2 : Math.floor(d / this.interval) * this.interval;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = "axisX" === this.type ? f + g2 / 2 : Math.ceil(f / this.interval) * this.interval;
              0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && "undefined" === typeof this.options.interval && (this.interval = B.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), true)));
            }
            if (null === this.minimum || null === this.maximum) if ("axisX" === this.type ? (d = null !== this.minimum ? this.minimum : this.dataInfo.min, f = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === f - d && (b = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, f += b, d -= b), g2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < f - d ? 0.5 * Math.abs(f - d) : 1) : "axisY" === this.type && (d = null !== this.minimum ? this.minimum : this.dataInfo.min, f = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(d) || isFinite(f) ? 0 === d && 0 === f ? (f += 9, d = 0) : 0 === f - d ? (b = Math.min(Math.abs(0.01 * Math.abs(f)), 5), f += b, d -= b) : d > f ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(f, d, null, true)), 5), 0 <= f ? d = f - b : f = isFinite(d) ? d + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(d, f, null, true)), 0.05), 0 !== f && (f += b), 0 !== d && (d -= b)) : (f = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, d = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), g2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < f - d ? 0.5 * Math.abs(f - d) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < d && (d = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > f && (f = 0)), Math.abs(this.getApparentDifference(d, f, null, true)), "axisX" === this.type && c) {
              this.valueType = "dateTime";
              if (null === this.minimum || isNaN(this.minimum)) this.minimum = d - g2 / 2, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum);
              if (null === this.maximum || isNaN(this.maximum)) this.maximum = f + g2 / 2, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum);
            } else this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? d - g2 / 2 : Math.floor(d / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? f + g2 / 2 : Math.ceil(f / this.interval) * this.interval, this.maximum = Math.max(
              this.maximum,
              null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum
            )), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));
            l(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
            l(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
            this.range = this.viewportMaximum - this.viewportMinimum;
            this.intervalStartPosition = "axisX" === this.type && c ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval;
            this.valueFormatString || (this.valueFormatString = B.generateValueFormatString(this.range, 2));
          }
        };
        B.prototype.calculateLogarithmicAxisParameters = function() {
          var a = this.chart.layoutManager.getFreeSpace(), e = Math.log(this.logarithmBase), c;
          "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
          var a = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3), b, d, f, g2;
          g2 = 1;
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;
          if (this.scaleBreaks) {
            for (g2 = 0; g2 < this.scaleBreaks._appliedBreaks.length; g2++) if ((!l(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[g2].startValue || !l(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[g2].startValue || !l(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[g2].startValue) && (!l(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[g2].endValue || !l(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[g2].endValue || !l(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[g2].endValue)) {
              this.scaleBreaks._appliedBreaks.splice(g2, 1);
              break;
            }
          }
          "axisX" === this.type ? (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, d = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === d / b && (g2 = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), d *= g2, b /= g2), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d / b > this.logarithmBase ? d / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, d = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= b && !isFinite(d) ? (d = "undefined" === typeof this.options.interval ? 0 : this.options.interval, b = 1) : 0 >= b ? b = d : isFinite(d) || (d = b), 1 === b && 1 === d ? (d *= this.logarithmBase - 1 / this.logarithmBase, b = 1) : 1 === d / b ? (g2 = Math.min(d * Math.pow(this.logarithmBase, 0.01), Math.pow(
            this.logarithmBase,
            5
          )), d *= g2, b /= g2) : b > d ? (g2 = Math.min(b / d * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= d ? b = d / g2 : d = b * g2) : (g2 = Math.min(d / b * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== d && (d *= g2), 1 !== b && (b /= g2)), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d / b > this.logarithmBase ? d / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < b && (b = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > d && (d = 1));
          g2 = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? d : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
          var r2 = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? d : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
          this.intervalType = "number";
          g2 = Math.pow(this.logarithmBase, B.getNiceNumber(Math.abs(Math.log(g2) / e), false));
          this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = B.getNiceExponent(Math.log(g2) / e / (a - 1), true), c = B.getNiceNumber(r2 / (a - 1), true));
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? b / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / e / this.interval));
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = "axisX" === this.type ? d * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(d) / e / this.interval));
          1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && "undefined" === typeof this.options.interval && (this.interval = B.getNiceExponent(Math.ceil(Math.log(g2) / e) / (a - 1)), c = B.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), true)));
          if (null === this.minimum || null === this.maximum) "axisX" === this.type ? (b = null !== this.minimum ? this.minimum : this.dataInfo.min, d = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === d / b && (g2 = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), d *= g2, b /= g2), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d / b > this.logarithmBase ? d / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.minimum ? this.minimum : this.dataInfo.min, d = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(b) || isFinite(d) ? 1 === b && 1 === d ? (d *= this.logarithmBase, b /= this.logarithmBase) : 1 === d / b ? (g2 = Math.pow(this.logarithmBase, this.interval), d *= g2, b /= g2) : b > d ? (g2 = Math.min(0.01 * (b / d), 5), 1 <= d ? b = d / g2 : d = b * g2) : (g2 = Math.min(d / b * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== d && (d *= g2), 1 !== b && (b /= g2)) : (d = "undefined" === typeof this.options.interval ? 0 : this.options.interval, b = 1), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d / b > this.logarithmBase ? d / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < b && (b = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > d && (d = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? b / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / e / this.interval)), l(null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum) || (this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum))), null === this.maximum && (this.maximum = "axisX" === this.type ? d * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(d) / e / this.interval)), l(null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum) || (this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum))), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));
          this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
          this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);
          this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);
          b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (e * this.interval) + 0.2) * this.interval);
          this.range = this.viewportMaximum / this.viewportMinimum;
          this.noTicks = a;
          if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {
            for (e = Math.floor(this.viewportMinimum / c + 0.5) * c; e < this.viewportMinimum; ) e += c;
            this.equidistantInterval = false;
            this.intervalStartPosition = e;
            this.interval = c;
          } else this.options.interval || (c = Math.ceil(this.interval), this.range > this.interval && (this.interval = c, b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (e * this.interval) + 0.2) * this.interval))), this.equidistantInterval = true, this.intervalStartPosition = b;
          if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum)) {
            e = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;
            if (isNaN(e) || !isFinite(e)) e = 2;
            if (2 < e) for (g2 = 0; g2 < e - 2; g2++) this.valueFormatString += "#";
          }
        };
        B.generateValueFormatString = function(a, e) {
          var c = "#,##0.", b = e;
          1 > a && (b += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(b) || !isFinite(b)) && (b = e);
          for (var d = 0; d < b; d++) c += "#";
          return c;
        };
        B.getNiceExponent = function(a, e) {
          var c = Math.floor(Math.log(a) / Math.LN10), b = a / Math.pow(10, c), b = 0 > c ? 1 >= b ? 1 : 5 >= b ? 5 : 10 : Math.max(Math.floor(b), 1);
          return -20 > c ? Number(b * Math.pow(10, c)) : Number((b * Math.pow(10, c)).toFixed(20));
        };
        B.getNiceNumber = function(a, e) {
          var c = Math.floor(Math.log(a) / Math.LN10), b = a / Math.pow(10, c), b = e ? 1.5 > b ? 1 : 3 > b ? 2 : 7 > b ? 5 : 10 : 1 >= b ? 1 : 2 >= b ? 2 : 5 >= b ? 5 : 10;
          return -20 > c ? Number(b * Math.pow(10, c)) : Number((b * Math.pow(10, c)).toFixed(20));
        };
        B.prototype.getLabelStartPoint = function() {
          var a = V[this.intervalType + "Duration"] * this.interval, a = new Date(Math.floor(this.viewportMinimum / a) * a);
          if ("millisecond" !== this.intervalType) if ("second" === this.intervalType) 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));
          else if ("minute" === this.intervalType) {
            if (0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0);
          } else if ("hour" === this.intervalType) {
            if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
          } else if ("day" === this.intervalType) {
            if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
          } else if ("week" === this.intervalType) {
            if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
          } else if ("month" === this.intervalType) {
            if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
          } else "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));
          return a;
        };
        oa(fa2, U);
        oa(ba2, U);
        ba2.prototype.createUserOptions = function(a) {
          if ("undefined" !== typeof a || this.options._isPlaceholder) {
            var e = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Ca(this.parent[this.optionsName]), e = this.parent.options[this.optionsName].indexOf(this.options));
            this.options = "undefined" === typeof a ? {} : a;
            this.parent.options[this.optionsName][e] = this.options;
          }
        };
        ba2.prototype.render = function(a) {
          if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {
            var e = this.ctx, c = this.ctx.globalAlpha;
            this.ctx = a || this.ctx;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.ctx.clip();
            var b = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), d = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);
            this.ctx.strokeStyle = this.lineColor;
            this.ctx.fillStyle = this.color;
            this.ctx.beginPath();
            this.ctx.globalAlpha = 1;
            T(this.id);
            var f, g2, l2, r2, k, m;
            a = Math.max(this.spacing, 3);
            var n = Math.max(0, this.lineThickness);
            this.ctx.lineWidth = n;
            this.ctx.setLineDash && this.ctx.setLineDash(K(this.lineDashType, n));
            if ("bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position) if (b = 1 === n % 2 ? (b.x << 0) + 0.5 : b.x << 0, g2 = 1 === n % 2 ? (d.x << 0) + 0.5 : d.x << 0, "top" === this.scaleBreaks.parent._position ? (d = this.chart.plotArea.y1, l2 = this.chart.plotArea.y2 + n / 2 + 0.5 << 0) : (d = this.chart.plotArea.y2, l2 = this.chart.plotArea.y1 - n / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: b - n / 2, y1: d, x2: g2 + n / 2, y2: l2 }, this.ctx.moveTo(b, d), "straight" === this.type || "top" === this.scaleBreaks.parent._position && 0 >= a || "bottom" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(b, l2), this.ctx.lineTo(g2, l2), this.ctx.lineTo(g2, d);
            else if ("wavy" === this.type) {
              r2 = b;
              k = d;
              f = 0.5;
              m = (l2 - k) / a / 3;
              for (var p = 0; p < m; p++) this.ctx.bezierCurveTo(r2 + f * a, k + a, r2 + f * a, k + 2 * a, r2, k + 3 * a), k += 3 * a, f *= -1;
              this.ctx.bezierCurveTo(r2 + f * a, k + a, r2 + f * a, k + 2 * a, r2, k + 3 * a);
              r2 = g2;
              f *= -1;
              this.ctx.lineTo(r2, k);
              for (p = 0; p < m; p++) this.ctx.bezierCurveTo(r2 + f * a, k - a, r2 + f * a, k - 2 * a, r2, k - 3 * a), k -= 3 * a, f *= -1;
            } else {
              if ("zigzag" === this.type) {
                f = -1;
                k = d + a;
                r2 = b + a;
                m = (l2 - k) / a / 2;
                for (p = 0; p < m; p++) this.ctx.lineTo(
                  r2,
                  k
                ), r2 += 2 * f * a, k += 2 * a, f *= -1;
                this.ctx.lineTo(r2, k);
                r2 += g2 - b;
                for (p = 0; p < m + 1; p++) this.ctx.lineTo(r2, k), r2 += 2 * f * a, k -= 2 * a, f *= -1;
                this.ctx.lineTo(r2 + f * a, k + a);
              }
            }
            else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position) {
              if (d = 1 === n % 2 ? (d.y << 0) + 0.5 : d.y << 0, l2 = 1 === n % 2 ? (b.y << 0) + 0.5 : b.y << 0, "left" === this.scaleBreaks.parent._position ? (b = this.chart.plotArea.x1, g2 = this.chart.plotArea.x2 + n / 2 + 0.5 << 0) : (b = this.chart.plotArea.x2, g2 = this.chart.plotArea.x1 - n / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: b, y1: d - n / 2, x2: g2, y2: l2 + n / 2 }, this.ctx.moveTo(b, d), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= a || "right" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(g2, d), this.ctx.lineTo(g2, l2), this.ctx.lineTo(b, l2);
              else if ("wavy" === this.type) {
                r2 = b;
                k = d;
                f = 0.5;
                m = (g2 - r2) / a / 3;
                for (p = 0; p < m; p++) this.ctx.bezierCurveTo(r2 + a, k + f * a, r2 + 2 * a, k + f * a, r2 + 3 * a, k), r2 += 3 * a, f *= -1;
                this.ctx.bezierCurveTo(r2 + a, k + f * a, r2 + 2 * a, k + f * a, r2 + 3 * a, k);
                k = l2;
                f *= -1;
                this.ctx.lineTo(r2, k);
                for (p = 0; p < m; p++) this.ctx.bezierCurveTo(
                  r2 - a,
                  k + f * a,
                  r2 - 2 * a,
                  k + f * a,
                  r2 - 3 * a,
                  k
                ), r2 -= 3 * a, f *= -1;
              } else if ("zigzag" === this.type) {
                f = 1;
                k = d - a;
                r2 = b + a;
                m = (g2 - r2) / a / 2;
                for (p = 0; p < m; p++) this.ctx.lineTo(r2, k), k += 2 * f * a, r2 += 2 * a, f *= -1;
                this.ctx.lineTo(r2, k);
                k += l2 - d;
                for (p = 0; p < m + 1; p++) this.ctx.lineTo(r2, k), k += 2 * f * a, r2 -= 2 * a, f *= -1;
                this.ctx.lineTo(r2 + a, k + f * a);
              }
            }
            0 < n && this.ctx.stroke();
            this.ctx.closePath();
            this.ctx.globalAlpha = this.fillOpacity;
            this.ctx.globalCompositeOperation = "destination-over";
            this.ctx.fill();
            this.ctx.restore();
            this.ctx.globalAlpha = c;
            this.ctx = e;
          }
        };
        oa(ga2, U);
        ga2.prototype.createUserOptions = function(a) {
          if ("undefined" !== typeof a || this.options._isPlaceholder) {
            var e = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Ca(this.parent.stripLines), e = this.parent.options.stripLines.indexOf(this.options));
            this.options = "undefined" === typeof a ? {} : a;
            this.parent.options.stripLines[e] = this.options;
          }
        };
        ga2.prototype.render = function() {
          this.ctx.save();
          var a = this.parent.getPixelCoordinatesOnAxis(this.value), e = Math.abs("pixel" === this._thicknessType ? this.thickness : Math.abs(this.parent.convertValueToPixel(this.endValue) - this.parent.convertValueToPixel(this.startValue)));
          if (0 < e) {
            var c = null === this.opacity ? 1 : this.opacity;
            this.ctx.strokeStyle = this.color;
            this.ctx.beginPath();
            var b = this.ctx.globalAlpha;
            this.ctx.globalAlpha = c;
            T(this.id);
            var d, f, g2, l2;
            this.ctx.lineWidth = e;
            this.ctx.setLineDash && this.ctx.setLineDash(K(this.lineDashType, e));
            if ("bottom" === this.parent._position || "top" === this.parent._position) d = f = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, g2 = this.chart.plotArea.y1, l2 = this.chart.plotArea.y2, this.bounds = { x1: d - e / 2, y1: g2, x2: f + e / 2, y2: l2 };
            else if ("left" === this.parent._position || "right" === this.parent._position) g2 = l2 = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, d = this.chart.plotArea.x1, f = this.chart.plotArea.x2, this.bounds = { x1: d, y1: g2 - e / 2, x2: f, y2: l2 + e / 2 };
            this.ctx.moveTo(d, g2);
            this.ctx.lineTo(f, l2);
            this.ctx.stroke();
            this.ctx.globalAlpha = b;
          }
          this.ctx.restore();
        };
        oa(da2, U);
        da2.prototype.showAt = function(a) {
          if (!this.enabled) return false;
          var e = this.chart, c = false;
          e.resetOverlayedCanvas();
          e.clearedOverlayedCanvas = this.parent.type;
          this.chart.renderCrosshairs(this.parent);
          if ("xySwapped" === e.plotInfo.axisPlacement) if ("bottom" === this.parent._position) for (var b = 0; b < e.axisY.length; b++) this.parent === e.axisY[b] && (e.axisY[b]._crosshairValue = a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum ? a : null);
          else if ("top" === this.parent._position) for (b = 0; b < e.axisY2.length; b++) this.parent === e.axisY2[b] && (e.axisY2[b]._crosshairValue = a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum ? a : null);
          else if ("left" === this.parent._position) for (b = 0; b < e.axisX.length; b++) this.parent === e.axisX[b] && (e.axisX[b]._crosshairValue = a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum ? a : null);
          else {
            if ("right" === this.parent._position) for (b = 0; b < e.axisX2.length; b++) this.parent === e.axisX2[b] && (e.axisX2[b]._crosshairValue = a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum ? a : null);
          }
          else if ("bottom" === this.parent._position) for (b = 0; b < e.axisX.length; b++) this.parent === e.axisX[b] && (e.axisX[b]._crosshairValue = a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum ? a : null);
          else if ("top" === this.parent._position) for (b = 0; b < e.axisX2.length; b++) this.parent === e.axisX2[b] && (e.axisX2[b]._crosshairValue = a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum ? a : null);
          else if ("left" === this.parent._position) for (b = 0; b < e.axisY.length; b++) this.parent === e.axisY[b] && (e.axisY[b]._crosshairValue = a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum ? a : null);
          else if ("right" === this.parent._position) for (b = 0; b < e.axisY2.length; b++) this.parent === e.axisY2[b] && (e.axisY2[b]._crosshairValue = a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum ? a : null);
          for (b = 0; b < e.axisX.length; b++) a = e.axisX[b]._crosshairValue, e.axisX[b].crosshair && e.axisX[b].crosshair.enabled && (!l(a) && a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum ? (e.axisX[b].showCrosshair(a), e.axisX[b].sessionVariables.crosshairValue = e.axisX[b].crosshair._updatedValue = a, this === e.axisX[b].crosshair && (c = true)) : void 0 !== a && (e.axisX[b].sessionVariables.crosshairValue = e.axisX[b].crosshair._updatedValue = null));
          for (b = 0; b < e.axisX2.length; b++) a = e.axisX2[b]._crosshairValue, e.axisX2[b].crosshair && e.axisX2[b].crosshair.enabled && (!l(a) && a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum ? (e.axisX2[b].showCrosshair(a), e.axisX2[b].sessionVariables.crosshairValue = e.axisX2[b].crosshair._updatedValue = a, this === e.axisX2[b].crosshair && (c = true)) : void 0 !== a && (e.axisX2[b].sessionVariables.crosshairValue = e.axisX2[b].crosshair._updatedValue = null));
          for (b = 0; b < e.axisY.length; b++) a = e.axisY[b]._crosshairValue, e.axisY[b].crosshair && e.axisY[b].crosshair.enabled && (!l(a) && a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum ? (e.axisY[b].showCrosshair(a), e.axisY[b].sessionVariables.crosshairValue = e.axisY[b].crosshair._updatedValue = a, this === e.axisY[b].crosshair && (c = true)) : void 0 !== a && (e.axisY[b].sessionVariables.crosshairValue = e.axisY[b].crosshair._updatedValue = null));
          for (b = 0; b < e.axisY2.length; b++) a = e.axisY2[b]._crosshairValue, e.axisY2[b].crosshair && e.axisY2[b].crosshair.enabled && (!l(a) && a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum ? (e.axisY2[b].showCrosshair(a), e.axisY2[b].sessionVariables.crosshairValue = e.axisY2[b].crosshair._updatedValue = a, this === e.axisY2[b].crosshair && (c = true)) : void 0 !== a && (e.axisY2[b].sessionVariables.crosshairValue = e.axisY2[b].crosshair._updatedValue = null));
          this.chart.toolTip && this.chart.toolTip._entries && this.chart.toolTip.highlightObjects(this.chart.toolTip._entries);
          e.sessionVariables.crosshairShownByPixel = false;
          return c;
        };
        da2.prototype.hide = function() {
          this.chart.resetOverlayedCanvas();
          this.chart.renderCrosshairs(this.parent);
          this._hidden = true;
        };
        da2.prototype.render = function(a, e, c) {
          var b, d, f, g2, r2 = null, t2 = null, k = null, m = "";
          this.valueFormatString || ("dateTime" === this.parent.valueType ? this.valueFormatString = this.parent.valueFormatString : (k = 0, k = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0), this.valueFormatString = B.generateValueFormatString(this.parent.range, k)));
          var n = null === this.opacity ? 1 : this.opacity, p = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), h = this.chart.overlaidCanvasCtx, u3 = h.globalAlpha;
          h.beginPath();
          h.strokeStyle = this.color;
          h.lineWidth = p;
          h.save();
          this.labelFontSize = Math.abs(l(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize);
          this.labelMaxWidth = l(this.options.labelMaxWidth) ? 0.3 * this.chart.width : this.labelMaxWidth;
          this.labelMaxHeight = l(this.options.labelWrap) || this.labelWrap ? 0.3 * this.chart.height : 1.5 * this.labelFontSize + ("object" === typeof this.labelPadding ? (this.labelPadding.top || 0) + (this.labelPadding.bottom || 0) : 2 * this.labelPadding);
          0 < p && h.setLineDash && h.setLineDash(K(this.lineDashType, p));
          k = new ja(h, {
            x: 0,
            y: 0,
            backgroundColor: this.labelBackgroundColor,
            borderColor: this.labelBorderColor,
            borderThickness: this.labelBorderThickness,
            cornerRadius: this.labelCornerRadius,
            maxWidth: this.labelMaxWidth,
            maxHeight: this.labelMaxHeight,
            angle: this.labelAngle,
            text: m,
            textAlign: this.labelTextAlign,
            fontSize: this.labelFontSize,
            fontFamily: this.labelFontFamily,
            fontWeight: this.labelFontWeight,
            padding: this.labelPadding,
            fontColor: this.labelFontColor,
            fontStyle: this.labelFontStyle,
            textBaseline: "middle"
          });
          if (this.snapToDataPoint) {
            var A = 0, m = [];
            if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
              var z = null;
              if ("bottom" === this.parent._position || "top" === this.parent._position) A = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: e });
              else if ("left" === this.parent._position || "right" === this.parent._position) A = this.parent.convertPixelToValue({ y: e });
              for (var s = 0; s < this.parent.dataSeries.length; s++) (z = this.parent.dataSeries[s].getDataPointAtX(A, true, true)) && 0 <= z.index && (z.dataSeries = this.parent.dataSeries[s], null !== z.dataPoint.y && z.dataSeries.visible && m.push(z));
              z = null;
              if (0 === m.length) return;
              m.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              var x = z = 0;
              yPercent = cumulativeY = 0;
              for (var A = Infinity, v, s = 0; s < m.length; s++) {
                if ("rangeBar" === m[s].dataSeries.type || "error" === m[s].dataSeries.type) {
                  if (m[s].dataPoint.y) for (var C3 = 0; C3 < m[s].dataPoint.y.length; C3++) x = Math.abs(a - this.parent.convertValueToPixel(m[s].dataPoint.y[C3])), x <= A && (A = x, z = s);
                } else "stackedBar" === m[s].dataSeries.type ? (cumulativeY = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, x = Math.abs(a - this.parent.convertValueToPixel(cumulativeY)), x <= A && (A = x, z = s)) : "stackedBar100" === m[s].dataSeries.type ? (x = m[0].dataPoint.x.getTime ? m[0].dataPoint.x.getTime() : m[0].dataPoint.x, l(v) && (v = Math.abs(a - this.parent.convertValueToPixel(100 * (m[0].dataSeries.dataPointEOs[m[0].index].cumulativeY / m[0].dataSeries.plotUnit.dataPointYSums[x])))), cumulativeY = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, x = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, yPercent = 100 * (cumulativeY / m[s].dataSeries.plotUnit.dataPointYSums[x]), x = Math.abs(a - this.parent.convertValueToPixel(yPercent)), x <= v && (v = x, z = s)) : (x = Math.abs(a - this.parent.convertValueToPixel(m[s].dataPoint.y)), x <= A && (A = x, z = s));
                l(v) || (A = Math.min(A, v));
              }
              v = m[z];
              s = 0;
              if ("bottom" === this.parent._position || "top" === this.parent._position) {
                if ("rangeBar" === v.dataSeries.type || "error" === v.dataSeries.type) {
                  A = Math.abs(a - this.parent.convertValueToPixel(v.dataPoint.y[0]));
                  for (m = 0; m < v.dataPoint.y.length; m++) x = Math.abs(a - this.parent.convertValueToPixel(v.dataPoint.y[m])), x < A && (A = x, s = m);
                  r2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(v.dataPoint.y[s]) << 0) + 0.5 : this.parent.convertValueToPixel(v.dataPoint.y[s]) << 0;
                  this.value = v.dataPoint.y[s];
                  k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataPoint.y[s] }) : l(this.options.label) ? ea(l(c) ? v.dataPoint.y[s] : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else "stackedBar" === v.dataSeries.type ? (A = Math.abs(a - this.parent.convertValueToPixel(m[0].dataPoint.y)), cumulativeY = v.dataSeries.dataPointEOs[v.index].cumulativeY, r2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(cumulativeY) << 0) + 0.5 : this.parent.convertValueToPixel(cumulativeY) << 0, this.value = cumulativeY, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: cumulativeY }) : l(this.options.label) ? ea(l(c) ? cumulativeY : c, this.valueFormatString, this.chart._cultureInfo) : this.label) : "stackedBar100" === v.dataSeries.type ? (A = Math.abs(a - this.parent.convertValueToPixel(m[0].dataPoint.y)), cumulativeY = v.dataSeries.dataPointEOs[v.index].cumulativeY, x = v.dataPoint.x.getTime ? v.dataPoint.x.getTime() : v.dataPoint.x, yPercent = 100 * (cumulativeY / v.dataSeries.plotUnit.dataPointYSums[x]), r2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(yPercent) << 0) + 0.5 : this.parent.convertValueToPixel(yPercent) << 0, this.value = yPercent, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: yPercent }) : l(this.options.label) ? ea(l(c) ? yPercent : c, this.valueFormatString, this.chart._cultureInfo) : this.label) : (r2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(v.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(v.dataPoint.y) << 0, this.value = v.dataPoint.y, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataPoint.y }) : l(this.options.label) ? ea(l(c) ? v.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label);
                b = d = r2;
                f = this.chart.plotArea.y1;
                g2 = this.chart.plotArea.y2;
                this.bounds = { x1: b - p / 2, y1: f, x2: d + p / 2, y2: g2 };
                k.x = b - k.measureText().width / 2;
                k.x + k.width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.width : k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
                k.y = this.parent.lineCoordinates.y2 + ("top" === this.parent._position ? -k.height + this.parent.tickLength : k.fontSize / 2) + 2;
                k.y + k.height > this.chart.bounds.y2 ? k.y = this.chart.bounds.y2 - k.height : k.y < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1);
              } else if ("left" === this.parent._position || "right" === this.parent._position) {
                f = g2 = t2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(v.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(v.dataPoint.x) << 0;
                b = this.chart.plotArea.x1;
                d = this.chart.plotArea.x2;
                this.bounds = { x1: b, y1: f - p / 2, x2: d, y2: g2 + p / 2 };
                s = false;
                if (this.parent.labels) for (A = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += A) if (this.parent.labels[m]) s = true;
                else {
                  s = false;
                  break;
                }
                if (s) {
                  if ("axisX" === this.parent.type) for (A = this.parent.convertPixelToValue({ y: e }), z = null, s = 0; s < this.parent.dataSeries.length; s++) (z = this.parent.dataSeries[s].getDataPointAtX(A, true, true)) && 0 <= z.index && (k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataPoint.x }) : l(this.options.label) ? z.dataPoint.label : this.label);
                } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataPoint.x }) : l(this.options.label) ? ea(v.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataPoint.x }) : l(this.options.label) ? Ba(
                  v.dataPoint.x,
                  this.valueFormatString,
                  this.chart._cultureInfo
                ) : this.label;
                this.value = v.dataPoint.x;
                k.y = g2 + k.fontSize / 2 - k.measureText().height / 2 + 2;
                k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
                "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
              }
            } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              A = this.parent.convertPixelToValue({ x: a });
              for (s = 0; s < this.parent.dataSeries.length; s++) (z = this.parent.dataSeries[s].getDataPointAtX(A, true, true)) && 0 <= z.index && (z.dataSeries = this.parent.dataSeries[s], null !== z.dataPoint.y && z.dataSeries.visible && m.push(z));
              if (0 === m.length) return;
              m.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              v = m[0];
              b = d = r2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(v.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(v.dataPoint.x) << 0;
              f = this.chart.plotArea.y1;
              g2 = this.chart.plotArea.y2;
              this.bounds = { x1: b - p / 2, y1: f, x2: d + p / 2, y2: g2 };
              s = false;
              if (this.parent.labels) for (A = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += A) if (this.parent.labels[m]) s = true;
              else {
                s = false;
                break;
              }
              if (s) {
                if ("axisX" === this.parent.type) for (A = this.parent.convertPixelToValue({ x: a }), z = null, s = 0; s < this.parent.dataSeries.length; s++) (z = this.parent.dataSeries[s].getDataPointAtX(A, true, true)) && 0 <= z.index && (k.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: v.dataPoint.x
                }) : l(this.options.label) ? z.dataPoint.label : this.label);
              } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataPoint.x }) : l(this.options.label) ? ea(v.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                chart: this.chart,
                axis: this.parent.options,
                crosshair: this.options,
                value: v.dataPoint.x
              }) : l(this.options.label) ? Ba(v.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;
              this.value = v.dataPoint.x;
              k.x = b - k.measureText().width / 2;
              k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);
              k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position) {
              !l(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (A = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a }));
              for (s = 0; s < this.parent.dataSeries.length; s++) (z = this.parent.dataSeries[s].getDataPointAtX(A, true, true)) && 0 <= z.index && (z.dataSeries = this.parent.dataSeries[s], null !== z.dataPoint.y && z.dataSeries.visible && m.push(z));
              if (0 === m.length) return;
              m.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              x = z = 0;
              A = Infinity;
              for (s = 0; s < m.length; s++) {
                if ("rangeColumn" === m[s].dataSeries.type || "rangeArea" === m[s].dataSeries.type || "error" === m[s].dataSeries.type || "rangeSplineArea" === m[s].dataSeries.type || "candlestick" === m[s].dataSeries.type || "ohlc" === m[s].dataSeries.type || "boxAndWhisker" === m[s].dataSeries.type) {
                  if (m[s].dataPoint.y) for (C3 = 0; C3 < m[s].dataPoint.y.length; C3++) x = Math.abs(e - this.parent.convertValueToPixel(m[s].dataPoint.y[C3])), x <= A && (A = x, z = s);
                } else "stackedColumn" === m[s].dataSeries.type ? (b = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, x = Math.abs(e - this.parent.convertValueToPixel(b)), x <= A && (A = x, z = s)) : "stackedArea" === m[s].dataSeries.type ? (b = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, x = Math.abs(e - this.parent.convertValueToPixel(b)), x <= A && (A = x, z = s)) : "stackedColumn100" === m[s].dataSeries.type || "stackedArea100" === m[s].dataSeries.type ? (x = m[0].dataPoint.x.getTime ? m[0].dataPoint.x.getTime() : m[0].dataPoint.x, l(v) && (v = Math.abs(e - this.parent.convertValueToPixel(100 * (m[0].dataSeries.dataPointEOs[m[0].index].cumulativeY / m[0].dataSeries.plotUnit.dataPointYSums[x])))), "stackedColumn100" === m[s].dataSeries.type ? (t2 = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, x = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, b = 100 * (t2 / m[s].dataSeries.plotUnit.dataPointYSums[x]), x = Math.abs(e - this.parent.convertValueToPixel(b)), x <= v && (v = x, z = s)) : "stackedArea100" === m[s].dataSeries.type && (t2 = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, x = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, b = 100 * (t2 / m[s].dataSeries.plotUnit.dataPointYSums[x]), x = Math.abs(e - this.parent.convertValueToPixel(b)), x <= v && (v = x, z = s))) : "waterfall" === m[s].dataSeries.type ? (x = Math.abs(e - this.parent.convertValueToPixel(m[s].dataSeries.dataPointEOs[m[s].index].cumulativeSum)), x <= A && (v = A = x, z = s)) : (x = Math.abs(e - this.parent.convertValueToPixel(m[s].dataPoint.y)), x <= A && (A = x, z = s));
                l(v) || (A = Math.min(A, v));
              }
              v = m[z];
              s = 0;
              if ("rangeColumn" === v.dataSeries.type || "rangeArea" === v.dataSeries.type || "error" === v.dataSeries.type || "rangeSplineArea" === v.dataSeries.type || "candlestick" === v.dataSeries.type || "ohlc" === v.dataSeries.type || "boxAndWhisker" === v.dataSeries.type) {
                A = Math.abs(e - this.parent.convertValueToPixel(v.dataPoint.y[0]));
                for (m = 0; m < v.dataPoint.y.length; m++) x = Math.abs(e - this.parent.convertValueToPixel(v.dataPoint.y[m])), x < A && (A = x, s = m);
                t2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(v.dataPoint.y[s]) << 0) + 0.5 : this.parent.convertValueToPixel(v.dataPoint.y[s]) << 0;
                k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataPoint.y[s] }) : l(this.options.label) ? ea(l(c) ? v.dataPoint.y[s] : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
                this.value = v.dataPoint.y[s];
              } else "stackedColumn" === v.dataSeries.type ? (b = v.dataSeries.dataPointEOs[v.index].cumulativeY, t2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b }) : l(this.options.label) ? ea(
                l(c) ? b : c,
                this.valueFormatString,
                this.chart._cultureInfo
              ) : this.label, this.value = b) : "stackedArea" === v.dataSeries.type ? (b = v.dataSeries.dataPointEOs[v.index].cumulativeY, t2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b }) : l(this.options.label) ? ea(l(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : "stackedColumn100" === v.dataSeries.type ? (t2 = v.dataSeries.dataPointEOs[v.index].cumulativeY, x = v.dataPoint.x.getTime ? v.dataPoint.x.getTime() : v.dataPoint.x, b = 100 * (t2 / v.dataSeries.plotUnit.dataPointYSums[x]), t2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b }) : l(this.options.label) ? ea(l(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : "stackedArea100" === v.dataSeries.type ? (t2 = v.dataSeries.dataPointEOs[v.index].cumulativeY, x = v.dataPoint.x.getTime ? v.dataPoint.x.getTime() : v.dataPoint.x, b = 100 * (t2 / v.dataSeries.plotUnit.dataPointYSums[x]), t2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b }) : l(this.options.label) ? ea(l(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : "waterfall" === v.dataSeries.type ? (t2 = 1 === h.lineWidth % 2 ? (this.parent.convertValueToPixel(v.dataSeries.dataPointEOs[v.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(v.dataSeries.dataPointEOs[v.index].cumulativeSum) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: v.dataSeries.dataPointEOs[v.index].cumulativeSum }) : l(this.options.label) ? ea(
                l(c) ? v.dataSeries.dataPointEOs[v.index].cumulativeSum : c,
                this.valueFormatString,
                this.chart._cultureInfo
              ) : this.label, this.value = v.dataSeries.dataPointEOs[v.index].cumulativeSum) : (t2 = 1 === h.lineWidth % 2 ? (l(a) ? e : this.parent.convertValueToPixel(v.dataPoint.y) << 0) + 0.5 : l(a) ? e : this.parent.convertValueToPixel(v.dataPoint.y) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l(c) ? v.dataPoint.y : c }) : l(this.options.label) ? ea(l(c) ? v.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = v.dataPoint.y);
              f = g2 = t2;
              b = this.chart.plotArea.x1;
              d = this.chart.plotArea.x2;
              this.bounds = { x1: b, y1: f - p / 2, x2: d, y2: g2 + p / 2 };
              k.y = g2 + k.fontSize / 2 - k.measureText().height / 2 + 2;
              k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
              "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
            }
            m = null;
            h.globalAlpha = n;
            if ("bottom" === this.parent._position || "top" === this.parent._position) "top" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1 + k.fontSize / 2), "bottom" === this.parent._position && this.parent.lineCoordinates.y2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2), this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < p && (h.moveTo(b, f), h.lineTo(d, g2), h.stroke(), this._hidden = false);
            if ("left" === this.parent._position || "right" === this.parent._position) "left" === this.parent._position && k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), "right" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.measureText().width), this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < p && (h.moveTo(b, f), h.lineTo(d, g2), h.stroke(), this._hidden = false);
          } else {
            if ("bottom" === this.parent._position || "top" === this.parent._position) b = d = r2 = 1 === h.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, f = this.chart.plotArea.y1, g2 = this.chart.plotArea.y2, this.bounds = { x1: b - p / 2, y1: f, x2: d + p / 2, y2: g2 };
            else if ("left" === this.parent._position || "right" === this.parent._position) f = g2 = t2 = 1 === h.lineWidth % 2 ? (e << 0) + 0.5 : e << 0, b = this.chart.plotArea.x1, d = this.chart.plotArea.x2, this.bounds = { x1: b, y1: f - p / 2, x2: d, y2: g2 + p / 2 };
            if ("xySwapped" === this.chart.plotInfo.axisPlacement) if ("left" === this.parent._position || "right" === this.parent._position) {
              s = false;
              if (this.parent.labels) for (A = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += A) if (this.parent.labels[m]) s = true;
              else {
                s = false;
                break;
              }
              if (s) {
                if ("axisX" === this.parent.type) for (A = this.parent.convertPixelToValue({ y: e }), z = null, s = 0; s < this.parent.dataSeries.length; s++) (z = this.parent.dataSeries[s].getDataPointAtX(A, true)) && 0 <= z.index && (k.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: l(c) ? this.parent.convertPixelToValue(a) : c
                }) : l(this.options.label) ? z.dataPoint.label : this.label);
              } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l(c) ? this.parent.convertPixelToValue(e) : c }) : l(this.options.label) ? ea(l(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                chart: this.chart,
                axis: this.parent.options,
                crosshair: this.options,
                value: l(c) ? this.parent.convertPixelToValue(e) : c
              }) : l(this.options.label) ? Ba(l(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
              k.y = e + k.fontSize / 2 - k.measureText().height / 2 + 2;
              k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
              "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x1 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
            } else {
              if ("bottom" === this.parent._position || "top" === this.parent._position) k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l(c) ? this.parent.convertPixelToValue(a) : c }) : l(this.options.label) ? ea(l(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label, k.x = b - k.measureText().width / 2, k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width), k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
            }
            else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              s = false;
              m = "";
              if (this.parent.labels) for (A = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += A) if (this.parent.labels[m]) s = true;
              else {
                s = false;
                break;
              }
              if (s) {
                if ("axisX" === this.parent.type) for (A = this.parent.convertPixelToValue({ x: a }), z = null, s = 0; s < this.parent.dataSeries.length; s++) (z = this.parent.dataSeries[s].getDataPointAtX(A, true)) && 0 <= z.index && (k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l(c) ? this.parent.convertPixelToValue(a) : c }) : l(this.options.label) ? l(c) ? z.dataPoint.label : c : this.label);
              } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l(c) ? 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : "" : c }) : l(this.options.label) ? ea(l(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l(c) ? this.parent.convertPixelToValue(a) : c }) : l(this.options.label) ? Ba(l(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
              k.x = b - k.measureText().width / 2;
              k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);
              k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position) k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: l(c) ? this.parent.convertPixelToValue(e) : c }) : l(this.options.label) ? ea(l(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label, k.y = e + k.fontSize / 2 - k.measureText().height / 2 + 2, k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2), "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
            "left" === this.parent._position && k.x < this.chart.bounds.x1 ? k.x = this.chart.bounds.x1 : "right" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.measureText().width : "top" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 : "bottom" === this.parent._position && this.parent.lineCoordinates.y2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2);
            h.globalAlpha = n;
            0 < p && (h.moveTo(b, f), h.lineTo(d, g2), h.stroke(), this._hidden = false);
            this.value = "bottom" === this.parent._position || "top" === this.parent._position ? this.parent.convertPixelToValue(a) : this.parent.convertPixelToValue(e);
          }
          if ("bottom" === this.parent._position || "top" === this.parent._position) this.parent.sessionVariables.crosshairValue = this._updatedValue = this.parent.convertPixelToValue(r2);
          if ("left" === this.parent._position || "right" === this.parent._position) this.parent.sessionVariables.crosshairValue = this._updatedValue = this.parent.convertPixelToValue(t2);
          this._textBlock = k;
          this._label = c;
          l(c) || this.renderLabel();
          h.restore();
          h.globalAlpha = u3;
        };
        da2.prototype.renderLabel = function() {
          this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && (l(this._textBlock) || (l(this._textBlock.text) || !("number" === typeof this._textBlock.text.valueOf() || 0 < this._textBlock.text.length) || this._hidden) || this._textBlock.render(true), l(this._label) && this.dispatchEvent("updated", { chart: this.chart, crosshair: this.options, axis: this.parent, value: this.value }, this.parent));
        };
        oa(la, U);
        la.prototype._updateOptions = function() {
          this.updateOption("enabled");
          this.updateOption("shared");
          this.updateOption("animationEnabled");
          this.updateOption("content");
          this.updateOption("contentFormatter");
          this.updateOption("reversed");
          this.updateOption("backgroundColor");
          this.updateOption("borderColor");
          this.updateOption("borderThickness");
          this.updateOption("cornerRadius");
          this.updateOption("fontSize");
          this.updateOption("fontColor");
          this.updateOption("fontFamily");
          this.updateOption("fontWeight");
          this.updateOption("fontStyle");
        };
        la.prototype._initialize = function() {
          this.updateOption("updated");
          this.updateOption("hidden");
          if (this.enabled) {
            this.container = document.createElement("div");
            this.container.setAttribute("class", "canvasjs-chart-tooltip");
            this.container.style.position = "absolute";
            this.container.style.height = "auto";
            this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)";
            this.container.style.zIndex = "1000";
            this.container.style.pointerEvents = "none";
            this.container.style.display = "none";
            var a = document.createElement("div");
            a.style.width = "auto";
            a.style.height = "auto";
            a.style.minWidth = "50px";
            a.style.lineHeight = "normal";
            a.style.margin = "0px 0px 0px 0px";
            a.style.padding = "5px";
            a.style.fontFamily = "Calibri, Arial, Georgia, serif";
            a.style.fontWeight = "normal";
            a.style.fontStyle = r ? "italic" : "normal";
            a.style.fontSize = "14px";
            a.style.color = "#000000";
            a.style.textShadow = "1px 1px 1px rgba(0, 0, 0, 0.1)";
            a.style.textAlign = "left";
            a.style.border = "2px solid gray";
            a.style.background = r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)";
            a.style.textIndent = "0px";
            a.style.whiteSpace = "nowrap";
            a.style.borderRadius = "5px";
            a.style.MozUserSelect = "none";
            a.style.WebkitUserSelect = "none";
            a.style.msUserSelect = "none";
            a.style.userSelect = "none";
            r || (a.style.filter = "alpha(opacity = 90)", a.style.filter = "progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666')");
            a.innerText = "Sample Tooltip";
            this.container.appendChild(a);
            this.contentDiv = this.container.firstChild;
            this.container.style.borderRadius = this.contentDiv.style.borderRadius;
            this.chart._canvasJSContainer.appendChild(this.container);
          }
        };
        la.prototype.mouseMoveHandler = function(a, e) {
          this._lastUpdated && 4 > (/* @__PURE__ */ new Date()).getTime() - this._lastUpdated || (this._lastUpdated = (/* @__PURE__ */ new Date()).getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, e), this.enabled && this._updatedEventParameters && !isNaN(this._prevX) && !isNaN(this._prevY) && this.container && this.container.style && this.dispatchEvent("none" === this.container.style.display ? "hidden" : "updated", this._updatedEventParameters, this));
        };
        la.prototype._updateToolTip = function(a, e, c) {
          c = "undefined" === typeof c ? true : c;
          this._updateOptions();
          this.container || this._initialize();
          this.enabled || this.hide();
          if (!this.chart.disableToolTip) {
            if ("undefined" === typeof a || "undefined" === typeof e) {
              if (isNaN(this._prevX) || isNaN(this._prevY)) return;
              a = this._prevX;
              e = this._prevY;
            } else this._prevX = a, this._prevY = e;
            var b = null, d = null, f = [], g2 = 0;
            if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
              var t2 = [];
              if (this.chart.axisX) for (var u3 = 0; u3 < this.chart.axisX.length; u3++) {
                for (var g2 = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX[u3].convertPixelToValue({ y: e }) : this.chart.axisX[u3].convertPixelToValue({ x: a }), k = null, b = 0; b < this.chart.axisX[u3].dataSeries.length; b++) (k = this.chart.axisX[u3].dataSeries[b].getDataPointAtX(g2, c, true)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[u3].dataSeries[b], null !== k.dataPoint.y && k.dataSeries.visible && t2.push(k));
                k = null;
              }
              if (this.chart.axisX2) for (u3 = 0; u3 < this.chart.axisX2.length; u3++) {
                g2 = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX2[u3].convertPixelToValue({ y: e }) : this.chart.axisX2[u3].convertPixelToValue({ x: a });
                k = null;
                for (b = 0; b < this.chart.axisX2[u3].dataSeries.length; b++) (k = this.chart.axisX2[u3].dataSeries[b].getDataPointAtX(g2, c, true)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[u3].dataSeries[b], null !== k.dataPoint.y && k.dataSeries.visible && t2.push(k));
                k = null;
              }
              if (0 === t2.length) return;
              t2.sort(function(a2, b2) {
                return a2.dataSeries.axisX.logarithmic || b2.dataSeries.axisX.logarithmic ? a2.distance - b2.distance : a2.distance / a2.dataSeries.axisX.range - b2.distance / b2.dataSeries.axisX.range;
              });
              c = t2[0];
              for (b = 0; b < t2.length; b++) t2[b].dataPoint.x.valueOf() === c.dataPoint.x.valueOf() && f.push(t2[b]);
              t2 = null;
            } else {
              if (b = this.chart.getDataPointAtXY(a, e, c)) this.currentDataPointIndex = b.dataPointIndex, this.currentSeriesIndex = b.dataSeries.index;
              else if (r) if (b = Za(a, e, this.chart._eventManager.ghostCtx), 0 < b && "undefined" !== typeof this.chart._eventManager.objectMap[b]) {
                b = this.chart._eventManager.objectMap[b];
                if ("legendItem" === b.objectType) return;
                this.currentSeriesIndex = b.dataSeriesIndex;
                this.currentDataPointIndex = 0 <= b.dataPointIndex ? b.dataPointIndex : -1;
              } else this.currentDataPointIndex = -1;
              else this.currentDataPointIndex = -1;
              if (0 <= this.currentSeriesIndex) {
                d = this.chart.data[this.currentSeriesIndex];
                k = {};
                if (0 <= this.currentDataPointIndex) b = d.dataPoints[this.currentDataPointIndex], k.dataSeries = d, k.dataPoint = b, k.index = this.currentDataPointIndex, k.distance = Math.abs(b.x - g2), "waterfall" === d.type && (k.cumulativeSumYStartValue = d.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, k.cumulativeSum = d.dataPointEOs[this.currentDataPointIndex].cumulativeSum);
                else if (this.enabled && d && ("line" === d.type || "stepLine" === d.type || "spline" === d.type || "area" === d.type || "stepArea" === d.type || "splineArea" === d.type || "stackedArea" === d.type || "stackedArea100" === d.type || "rangeArea" === d.type || "rangeSplineArea" === d.type || "candlestick" === d.type || "ohlc" === d.type || "boxAndWhisker" === d.type)) g2 = d.axisX.convertPixelToValue({ x: a }), k = d.getDataPointAtX(g2, c, true), l(k) || (k.dataSeries = d, this.currentDataPointIndex = k.index, b = k.dataPoint);
                else {
                  "toolTip" === this.chart.clearedOverlayedCanvas && (this.chart.resetOverlayedCanvas(), this.chart.clearedOverlayedCanvas = null, this.container && (this.container.style.display = "none"));
                  return;
                }
                if (!l(k) && !l(k.dataPoint) && !l(k.dataPoint.y)) if (k.dataSeries.axisY) if (0 < k.dataPoint.y.length) {
                  for (b = c = 0; b < k.dataPoint.y.length; b++) k.dataPoint.y[b] < k.dataSeries.axisY.viewportMinimum ? c-- : k.dataPoint.y[b] > k.dataSeries.axisY.viewportMaximum && c++;
                  c < k.dataPoint.y.length && c > -k.dataPoint.y.length && f.push(k);
                } else "column" === d.type || "bar" === d.type ? 0 > k.dataPoint.y ? 0 > k.dataSeries.axisY.viewportMinimum && k.dataSeries.axisY.viewportMaximum >= k.dataPoint.y && f.push(k) : k.dataSeries.axisY.viewportMinimum <= k.dataPoint.y && 0 <= k.dataSeries.axisY.viewportMaximum && f.push(k) : "bubble" === d.type ? (c = this.chart._eventManager.objectMap[d.dataPointIds[k.index]].size / 2, k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum - c && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum + c && f.push(k)) : "waterfall" === d.type ? (c = 0, k.cumulativeSumYStartValue < k.dataSeries.axisY.viewportMinimum ? c-- : k.cumulativeSumYStartValue > k.dataSeries.axisY.viewportMaximum && c++, k.cumulativeSum < k.dataSeries.axisY.viewportMinimum ? c-- : k.cumulativeSum > k.dataSeries.axisY.viewportMaximum && c++, 2 > c && -2 < c && f.push(k)) : (0 <= k.dataSeries.type.indexOf("100") || "stackedColumn" === d.type || "stackedBar" === d.type || "stackedArea" === d.type || k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum) && f.push(k);
                else f.push(k);
              }
            }
            if (0 < f.length) {
              if (this.highlightObjects(f), this.enabled) {
                c = "";
                c = this.getToolTipInnerHTML({ entries: f });
                if (null !== c) {
                  this.contentDiv.innerHTML = c;
                  if (this.isToolTipDefinedInData && l(this.options.content) && l(this.options.contentFormatter)) for (g2 = this.contentDiv.getElementsByTagName("span"), b = 0; b < g2.length; b++) g2[b] && (g2[b].style.color = g2[b].getAttribute("data-color"));
                  g2 = false;
                  "none" === this.container.style.display && (g2 = true, this.container.style.display = "block");
                  try {
                    this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : 0 < f[0].dataPoint.y ? f[0].dataSeries.risingColor : f[0].dataSeries.fallingColor : "error" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[d.index % f[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[f[0].index % f[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : r ? "italic" : "normal";
                  } catch (m) {
                  }
                  "pie" === f[0].dataSeries.type || "doughnut" === f[0].dataSeries.type || "funnel" === f[0].dataSeries.type || "pyramid" === f[0].dataSeries.type || "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);
                  0 > a && (a = Math.max(0, a + this.container.clientWidth + 20));
                  a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
                  e = 1 !== f.length || this.shared || "line" !== f[0].dataSeries.type && "stepLine" !== f[0].dataSeries.type && "spline" !== f[0].dataSeries.type && "area" !== f[0].dataSeries.type && "stepArea" !== f[0].dataSeries.type && "splineArea" !== f[0].dataSeries.type ? "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) : e : f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y);
                  e = -e + 10;
                  0 < e + this.container.clientHeight + 5 && (e -= e + this.container.clientHeight + 5 - 0);
                  this.fixMozTransitionDelay(a, e);
                  !this.animationEnabled || g2 ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
                  this.positionLeft = a;
                  this.positionBottom = e;
                  this.container.style.left = a + "px";
                  this.container.style.bottom = e + "px";
                } else this.hide(false), this.enabled && this.dispatchEvent("hidden", { chart: this.chart, toolTip: this }, this);
                e = [];
                for (b = 0; b < f.length; b++) e.push({
                  xValue: f[b].dataPoint.x,
                  dataPoint: f[b].dataPoint,
                  dataSeries: f[b].dataSeries,
                  dataPointIndex: f[b].index,
                  dataSeriesIndex: f[b].dataSeries._index
                });
                this._updatedEventParameters = { chart: this.chart, toolTip: this.options, content: c, entries: e };
                this._entries = f;
              }
            } else this.hide(), this.enabled && this.dispatchEvent("hidden", { chart: this.chart, toolTip: this }, this);
            this._dataSeriesIndex = this._xValue = null;
          }
        };
        la.prototype.highlightObjects = function(a) {
          var e = this.chart.overlaidCanvasCtx;
          l(this.chart.clearedOverlayedCanvas) || "toolTip" === this.chart.clearedOverlayedCanvas ? (this.chart.resetOverlayedCanvas(), e.clearRect(
            0,
            0,
            this.chart.width,
            this.chart.height
          ), this.chart.clearedOverlayedCanvas = "toolTip") : this.chart.clearedOverlayedCanvas = null;
          e.save();
          var c = this.chart.plotArea, b = 0;
          e.beginPath();
          e.rect(c.x1, c.y1, c.x2 - c.x1, c.y2 - c.y1);
          e.clip();
          for (c = 0; c < a.length; c++) {
            var d = a[c];
            if ((d = this.chart._eventManager.objectMap[d.dataSeries.dataPointIds[d.index]]) && d.objectType && "dataPoint" === d.objectType) {
              var b = this.chart.data[d.dataSeriesIndex], f = b.dataPoints[d.dataPointIndex], g2 = d.dataPointIndex;
              false === f.highlightEnabled || true !== b.highlightEnabled && true !== f.highlightEnabled || ("line" === b.type || "stepLine" === b.type || "spline" === b.type || "scatter" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type ? (f = b.getMarkerProperties(g2, d.x1, d.y1, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(0.1 * f.size), X.drawMarkers([f]), "undefined" !== typeof d.y2 && (f = b.getMarkerProperties(g2, d.x1, d.y2, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(0.1 * f.size), X.drawMarkers([f]))) : "bubble" === b.type ? (f = b.getMarkerProperties(g2, d.x1, d.y1, this.chart.overlaidCanvasCtx), f.size = d.size, f.color = "white", f.borderColor = "white", e.globalAlpha = 0.3, X.drawMarkers([f]), e.globalAlpha = 1) : "column" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "bar" === b.type || "rangeBar" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "rangeColumn" === b.type || "waterfall" === b.type ? Y(e, d.x1, d.y1, d.x2, d.y2, "white", 0, null, false, false, false, false, 0.3) : "pie" === b.type || "doughnut" === b.type ? pa2(e, d.center, d.radius, "white", b.type, d.startAngle, d.endAngle, 0.3, d.percentInnerRadius) : "funnel" === b.type || "pyramid" === b.type ? qa2(e, d.funnelSection, 0.3, "white") : "candlestick" === b.type ? (e.globalAlpha = 1, e.strokeStyle = d.color, e.lineWidth = 2 * d.borderThickness, b = 0 === e.lineWidth % 2 ? 0 : 0.5, e.beginPath(), e.moveTo(d.x3 - b, Math.min(d.y2, d.y3)), e.lineTo(d.x3 - b, Math.min(d.y1, d.y4)), e.stroke(), e.beginPath(), e.moveTo(d.x3 - b, Math.max(d.y1, d.y4)), e.lineTo(d.x3 - b, Math.max(d.y2, d.y3)), e.stroke(), Y(e, d.x1, Math.min(d.y1, d.y4), d.x2, Math.max(d.y1, d.y4), "transparent", 2 * d.borderThickness, d.color, false, false, false, false), e.globalAlpha = 1) : "ohlc" === b.type ? (e.globalAlpha = 1, e.strokeStyle = d.color, e.lineWidth = 2 * d.borderThickness, b = 0 === e.lineWidth % 2 ? 0 : 0.5, e.beginPath(), e.moveTo(d.x3 - b, d.y2), e.lineTo(d.x3 - b, d.y3), e.stroke(), e.beginPath(), e.moveTo(d.x3, d.y1), e.lineTo(d.x1, d.y1), e.stroke(), e.beginPath(), e.moveTo(d.x3, d.y4), e.lineTo(d.x2, d.y4), e.stroke(), e.globalAlpha = 1) : "boxAndWhisker" === b.type ? (e.save(), e.globalAlpha = 1, e.strokeStyle = d.stemColor, e.lineWidth = 2 * d.stemThickness, 0 < d.stemThickness && (e.beginPath(), e.moveTo(d.x3, d.y2 + d.borderThickness / 2), e.lineTo(d.x3, d.y1 + d.whiskerThickness / 2), e.stroke(), e.beginPath(), e.moveTo(d.x3, d.y4 - d.whiskerThickness / 2), e.lineTo(d.x3, d.y3 - d.borderThickness / 2), e.stroke()), e.beginPath(), Y(e, d.x1, Math.max(
                d.y2,
                d.y3
              ), d.x2, Math.min(d.y2, d.y3), "transparent", 2 * d.borderThickness, d.color, false, false, false, false), e.globalAlpha = 1, e.strokeStyle = d.whiskerColor, e.lineWidth = 2 * d.whiskerThickness, 0 < d.whiskerThickness && (e.beginPath(), e.moveTo(Math.floor(d.x3 - d.whiskerLength / 2), d.y4), e.lineTo(Math.ceil(d.x3 + d.whiskerLength / 2), d.y4), e.stroke(), e.beginPath(), e.moveTo(Math.floor(d.x3 - d.whiskerLength / 2), d.y1), e.lineTo(Math.ceil(d.x3 + d.whiskerLength / 2), d.y1), e.stroke()), e.globalAlpha = 1, e.strokeStyle = d.lineColor, e.lineWidth = 2 * d.lineThickness, 0 < d.lineThickness && (e.beginPath(), e.moveTo(d.x1, d.y5), e.lineTo(d.x2, d.y5), e.stroke()), e.restore(), e.globalAlpha = 1) : "error" === b.type && C2(e, d.x1, d.y1, d.x2, d.y2, "white", d.whiskerProperties, d.stemProperties, d.isXYSwapped, 0.3));
            }
          }
          e.restore();
          e.globalAlpha = 1;
          e.beginPath();
        };
        la.prototype.getToolTipInnerHTML = function(a) {
          a = a.entries;
          var e = null, c = null, b = null, d = 0, f = "";
          this.isToolTipDefinedInData = true;
          for (var g2 = 0; g2 < a.length; g2++) if (a[g2].dataSeries.toolTipContent || a[g2].dataPoint.toolTipContent) {
            this.isToolTipDefinedInData = false;
            break;
          }
          if (this.isToolTipDefinedInData && (this.content && "function" === typeof this.content || this.contentFormatter)) a = { chart: this.chart, toolTip: this.options, entries: a }, e = this.contentFormatter ? this.contentFormatter(a) : this.content(a);
          else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
            for (var l2 = null, r2 = "", g2 = 0; g2 < a.length; g2++) {
              c = a[g2].dataSeries;
              b = a[g2].dataPoint;
              d = a[g2].index;
              f = "";
              if (0 === g2 && this.isToolTipDefinedInData && !this.content) {
                this.chart.axisX && 0 < this.chart.axisX.length ? r2 += "undefined" !== typeof this.chart.axisX[0].labels[b.x] ? this.chart.axisX[0].labels[b.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (r2 += "undefined" !== typeof this.chart.axisX2[0].labels[b.x] ? this.chart.axisX2[0].labels[b.x] : "{x}");
                r2 += "</br>";
                if (!c.visible) continue;
                r2 = this.chart.replaceKeywordsWithValue(r2, b, c, d);
              }
              null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c.options.toolTipContent || ("line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "waterfall" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += l2 != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y}`, l2 = c.axisXIndex) : "bubble" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += l2 != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}`) : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "error" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += l2 != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}`) : "candlestick" === c.type || "ohlc" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += l2 != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}`) : "boxAndWhisker" === c.type && (this.chart.axisX && 1 < this.chart.axisX.length && (f += l2 != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}`), null === e && (e = ""), c.visible && (true === this.reversed ? (e = this.chart.replaceKeywordsWithValue(f, b, c, d) + e, g2 < a.length - 1 && (e = "</br>" + e)) : (e += this.chart.replaceKeywordsWithValue(f, b, c, d), g2 < a.length - 1 && (e += "</br>"))));
            }
            null !== e && (e = r2 + e);
          } else {
            c = a[0].dataSeries;
            b = a[0].dataPoint;
            d = a[0].index;
            if (null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c.options.toolTipContent) return null;
            "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "waterfall" === c.type ? f = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === c.type ? f = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === c.type || "doughnut" === c.type || "funnel" === c.type || "pyramid" === c.type ? f = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.name ? "{name}:</span>&nbsp;&nbsp;" : b.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "error" === c.type ? f = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" === c.type || "ohlc" === c.type ? f = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === c.type && (f = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");
            null === e && (e = "");
            e += this.chart.replaceKeywordsWithValue(
              f,
              b,
              c,
              d
            );
          }
          return e;
        };
        la.prototype.enableAnimation = function() {
          if (!this.container.style.WebkitTransition) {
            var a = this.getContainerTransition(this.containerTransitionDuration);
            this.container.style.WebkitTransition = a;
            this.container.style.MsTransition = a;
            this.container.style.transition = a;
            this.container.style.MozTransition = this.mozContainerTransition;
          }
        };
        la.prototype.disableAnimation = function() {
          this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "");
        };
        la.prototype.hide = function(a) {
          this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._entries = this._dataSeriesIndex = this._xValue = null, this._prevY = this._prevX = NaN, this._updatedEventParameters = null, ("undefined" === typeof a || a) && this.chart.resetOverlayedCanvas());
        };
        la.prototype.show = function(a, e, c) {
          this._updateToolTip(a, e, "undefined" === typeof c ? false : c);
        };
        la.prototype.showAtIndex = function(a, e) {
        };
        la.prototype.showAtX = function(a, e) {
          if (!this.enabled) return false;
          !l(this.chart.clearedOverlayedCanvas) && this.chart.clearedOverlayedCanvas.indexOf("axis") && (this.chart.clearedOverlayedCanvas = null);
          this._updateOptions();
          var c, b, d, f = [];
          d = false;
          e = !l(e) && 0 <= e && e < this.chart.data.length ? e : 0;
          if (this.shared) for (var g2 = 0; g2 < this.chart.data.length; g2++) c = this.chart.data[g2], (b = c.getDataPointAtX(a, false)) && (b.dataPoint && !l(b.dataPoint.y) && c.visible) && (b.dataSeries = c, this.chart.data[e].axisX.convertValueToPixel(a) === c.axisX.convertValueToPixel(b.dataPoint.x) && f.push(b));
          else c = this.chart.data[e], (b = c.getDataPointAtX(a, false)) && (b.dataPoint && !l(b.dataPoint.y) && c.visible) && (b.dataSeries = c, f.push(b));
          if (0 < f.length) {
            for (g2 = 0; g2 < f.length; g2++) if (b = f[g2], (this.shared || 0 <= b.dataSeries.type.indexOf("100")) && b.dataSeries.axisX && b.dataPoint.x >= b.dataSeries.axisX.viewportMinimum && b.dataPoint.x <= b.dataSeries.axisX.viewportMaximum) {
              d = false;
              break;
            } else if (b.dataSeries.axisX && b.dataSeries.axisY && (b.dataPoint.x < b.dataSeries.axisX.viewportMinimum || b.dataPoint.x > b.dataSeries.axisX.viewportMaximum || b.dataPoint.y < b.dataSeries.axisY.viewportMinimum || b.dataPoint.y > b.dataSeries.axisY.viewportMaximum)) d = true;
            else {
              d = false;
              break;
            }
            if (d) return this.hide(), false;
            this.highlightObjects(f);
            "toolTip" === this.chart.clearedOverlayedCanvas && this.chart.renderCrosshairs();
            this._entries = f;
            g2 = "";
            g2 = this.getToolTipInnerHTML({ entries: f });
            if (null !== g2) {
              this.contentDiv.innerHTML = g2;
              if (this.isToolTipDefinedInData && l(this.options.content) && l(this.options.contentFormatter)) for (b = this.contentDiv.getElementsByTagName("span"), g2 = 0; g2 < b.length; g2++) b[g2] && (b[g2].style.color = b[g2].getAttribute("data-color"));
              g2 = false;
              "none" === this.container.style.display && (g2 = true, this.container.style.display = "block");
              try {
                this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : 0 < f[0].dataPoint.y ? f[0].dataSeries.risingColor : f[0].dataSeries.fallingColor : "error" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[c.index % f[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[f[0].index % f[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : r ? "italic" : "normal";
              } catch (t2) {
              }
              "pie" === f[0].dataSeries.type || "doughnut" === f[0].dataSeries.type ? c = f[0].dataSeries.dataPointEOs[f[0].index].center.x + f[0].dataSeries.radius * Math.cos(f[0].dataSeries.dataPointEOs[f[0].index].midAngle) + -("left" === f[0].dataSeries.dataPointEOs[f[0].index].hemisphere ? 0 : this.container.clientWidth) : "funnel" === f[0].dataSeries.type || "pyramid" === f[0].dataSeries.type ? (b = f[0].dataSeries.dataPointEOs[f[0].index].sectionsofFunnel, c = (b.x1 + b.x2 - this.container.clientWidth) / 2) : (c = "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y.length ? f[0].dataPoint.y[f[0].dataPoint.y.length - 1] : f[0].dataPoint.y) - this.container.clientWidth << 0 : f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) - this.container.clientWidth << 0, c -= 10);
              0 > c && (c += this.container.clientWidth + 20);
              c + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (c = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
              1 !== f.length || this.shared || "line" !== f[0].dataSeries.type && "stepLine" !== f[0].dataSeries.type && "spline" !== f[0].dataSeries.type && "area" !== f[0].dataSeries.type && "stepArea" !== f[0].dataSeries.type && "splineArea" !== f[0].dataSeries.type ? "pie" === f[0].dataSeries.type || "doughnut" === f[0].dataSeries.type ? (b = f[0].dataSeries.dataPointEOs[f[0].index].center.y + f[0].dataSeries.radius * Math.sin(f[0].dataSeries.dataPointEOs[f[0].index].midAngle), b < f[0].dataSeries.dataPointEOs[f[0].index].center.y && (b += this.container.clientHeight)) : "funnel" === f[0].dataSeries.type || "pyramid" === f[0].dataSeries.type ? (b = f[0].dataSeries.dataPointEOs[f[0].dataSeries.reversed ? f[0].dataSeries.dataPointEOs.length - 1 - f[0].index : f[0].index].sectionsofFunnel, b = "undefined" !== typeof b.x5 ? (b.y2 + b.y4) / 2 : (b.y2 + b.y3) / 2 + this.container.clientHeight / 2) : b = "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) : f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y.length ? f[0].dataPoint.y[f[0].dataPoint.y.length - 1] : f[0].dataPoint.y) : b = f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y);
              b = -b + 10;
              0 < b + this.container.clientHeight + 5 && (b -= b + this.container.clientHeight + 5 - 0);
              this.fixMozTransitionDelay(c, b);
              !this.animationEnabled || g2 ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
              this.container.style.left = c + "px";
              this.container.style.bottom = b + "px";
            } else return this.hide(false), false;
          } else return this.hide(), false;
          this._xValue = a;
          this._dataSeriesIndex = e;
          this._prevY = this._prevX = NaN;
          return true;
        };
        la.prototype.fixMozTransitionDelay = function(a, e) {
          if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition = this.getContainerTransition(0);
          else {
            var c = parseFloat(this.container.style.left), c = isNaN(c) ? 0 : c, b = parseFloat(this.container.style.bottom), b = isNaN(b) ? 0 : b;
            10 < Math.sqrt(Math.pow(c - a, 2) + Math.pow(b - e, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);
          }
        };
        la.prototype.getContainerTransition = function(a) {
          return "left " + a + "s ease-out 0s, bottom " + a + "s ease-out 0s";
        };
        ha2.prototype.reset = function() {
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.eventObjects = [];
          r && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());
        };
        ha2.prototype.getNewObjectTrackingId = function() {
          return ++this.lastObjectId;
        };
        ha2.prototype.mouseEventHandler = function(a) {
          if ("mousemove" === a.type || "click" === a.type) {
            var e = [], c = Oa(a), b = null;
            if ((b = this.chart.getObjectAtXY(c.x, c.y, false)) && "undefined" !== typeof this.objectMap[b]) if (b = this.objectMap[b], "dataPoint" === b.objectType) {
              var d = this.chart.data[b.dataSeriesIndex], f = d.dataPoints[b.dataPointIndex], g2 = b.dataPointIndex;
              b.eventParameter = { x: c.x, y: c.y, dataPoint: f, dataSeries: d.options, dataPointIndex: g2, dataSeriesIndex: d.index, chart: this.chart };
              b.eventContext = { context: f, userContext: f, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" };
              e.push(b);
              b = this.objectMap[d.id];
              b.eventParameter = {
                x: c.x,
                y: c.y,
                dataPoint: f,
                dataSeries: d.options,
                dataPointIndex: g2,
                dataSeriesIndex: d.index,
                chart: this.chart
              };
              b.eventContext = { context: d, userContext: d.options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" };
              e.push(this.objectMap[d.id]);
            } else "legendItem" === b.objectType && (d = this.chart.data[b.dataSeriesIndex], f = null !== b.dataPointIndex ? d.dataPoints[b.dataPointIndex] : null, b.eventParameter = { x: c.x, y: c.y, dataSeries: d.options, dataPoint: f, dataPointIndex: b.dataPointIndex, dataSeriesIndex: b.dataSeriesIndex, chart: this.chart }, b.eventContext = {
              context: this.chart.legend,
              userContext: this.chart.legend.options,
              mouseover: "itemmouseover",
              mousemove: "itemmousemove",
              mouseout: "itemmouseout",
              click: "itemclick"
            }, e.push(b));
            d = [];
            for (c = 0; c < this.mouseoveredObjectMaps.length; c++) {
              f = true;
              for (b = 0; b < e.length; b++) if (e[b].id === this.mouseoveredObjectMaps[c].id) {
                f = false;
                break;
              }
              f ? this.fireEvent(this.mouseoveredObjectMaps[c], "mouseout", a) : d.push(this.mouseoveredObjectMaps[c]);
            }
            this.mouseoveredObjectMaps = d;
            for (c = 0; c < e.length; c++) {
              d = false;
              for (b = 0; b < this.mouseoveredObjectMaps.length; b++) if (e[c].id === this.mouseoveredObjectMaps[b].id) {
                d = true;
                break;
              }
              d || (this.fireEvent(e[c], "mouseover", a), this.mouseoveredObjectMaps.push(e[c]));
              "click" === a.type ? this.fireEvent(e[c], "click", a) : "mousemove" === a.type && this.fireEvent(e[c], "mousemove", a);
            }
          }
        };
        ha2.prototype.fireEvent = function(a, e, c) {
          if (a && e) {
            var b = a.eventParameter, d = a.eventContext, f = a.eventContext.userContext;
            f && (d && f[d[e]]) && f[d[e]].call(f, b);
            "mouseout" !== e ? f.cursor && f.cursor !== c.target.style.cursor && (c.target.style.cursor = f.cursor) : (c.target.style.cursor = this.chart.panEnabled ? "itemmouseout" !== d.mouseout || f.dockInsidePlotArea ? "move" : this.chart._defaultCursor : this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);
            "click" === e && ("dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler) && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], b);
            "click" === e && ("dataPoint" === a.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], b);
          }
        };
        ia2.prototype.animate = function(a, e, c, b, d) {
          var f = this;
          this.chart.isAnimating = true;
          d = d || O.easing.linear;
          c && this.animations.push({ startTime: (/* @__PURE__ */ new Date()).getTime() + (a ? a : 0), duration: e, animationCallback: c, onComplete: b });
          for (a = []; 0 < this.animations.length; ) if (e = this.animations.shift(), c = (/* @__PURE__ */ new Date()).getTime(), b = 0, e.startTime <= c && (b = d(Math.min(c - e.startTime, e.duration), 0, 1, e.duration), b = Math.min(b, 1), isNaN(b) || !isFinite(b)) && (b = 1), 1 > b && a.push(e), e.animationCallback(b), 1 <= b && e.onComplete) e.onComplete();
          this.animations = a;
          0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(
            window,
            function() {
              f.animate.call(f);
            }
          ) : this.chart.isAnimating = false;
        };
        ia2.prototype.cancelAllAnimations = function() {
          this.animations = [];
          this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);
          this.animationRequestId = null;
          this.chart.isAnimating = false;
        };
        var O = { yScaleAnimation: function(a, e) {
          if (0 !== a) {
            var c = e.dest, b = e.source.canvas, d = e.animationBase;
            c.drawImage(b, 0, 0, b.width, b.height, 0, d - d * a, c.canvas.width / ka, a * c.canvas.height / ka);
          }
        }, xScaleAnimation: function(a, e) {
          if (0 !== a) {
            var c = e.dest, b = e.source.canvas, d = e.animationBase;
            c.drawImage(b, 0, 0, b.width, b.height, d - d * a, 0, a * c.canvas.width / ka, c.canvas.height / ka);
          }
        }, xClipAnimation: function(a, e) {
          if (0 !== a) {
            var c = e.dest, b = e.source.canvas;
            c.save();
            0 < a && c.drawImage(b, 0, 0, b.width * a, b.height, 0, 0, b.width * a / ka, b.height / ka);
            c.restore();
          }
        }, fadeInAnimation: function(a, e) {
          if (0 !== a) {
            var c = e.dest, b = e.source.canvas;
            c.save();
            c.globalAlpha = a;
            c.drawImage(b, 0, 0, b.width, b.height, 0, 0, c.canvas.width / ka, c.canvas.height / ka);
            c.restore();
          }
        }, easing: { linear: function(a, e, c, b) {
          return c * a / b + e;
        }, easeOutQuad: function(a, e, c, b) {
          return -c * (a /= b) * (a - 2) + e;
        }, easeOutQuart: function(a, e, c, b) {
          return -c * ((a = a / b - 1) * a * a * a - 1) + e;
        }, easeInQuad: function(a, e, c, b) {
          return c * (a /= b) * a + e;
        }, easeInQuart: function(a, e, c, b) {
          return c * (a /= b) * a * a * a + e;
        } } }, X = { drawMarker: function(a, e, c, b, d, f, g2, l2) {
          if (c) {
            var r2 = 1;
            c.fillStyle = f ? f : "#000000";
            c.strokeStyle = g2 ? g2 : "#000000";
            c.lineWidth = l2 ? l2 : 0;
            c.setLineDash && c.setLineDash(K("solid", l2));
            "circle" === b ? (c.moveTo(a, e), c.beginPath(), c.arc(a, e, d / 2, 0, 2 * Math.PI, false), f && c.fill(), l2 && (g2 ? c.stroke() : (r2 = c.globalAlpha, c.globalAlpha = 0.15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = r2))) : "square" === b ? (c.beginPath(), c.rect(a - d / 2, e - d / 2, d, d), f && c.fill(), l2 && (g2 ? c.stroke() : (r2 = c.globalAlpha, c.globalAlpha = 0.15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = r2))) : "triangle" === b ? (c.beginPath(), c.moveTo(a - d / 2, e + d / 2), c.lineTo(a + d / 2, e + d / 2), c.lineTo(a, e - d / 2), c.closePath(), f && c.fill(), l2 && (g2 ? c.stroke() : (r2 = c.globalAlpha, c.globalAlpha = 0.15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = r2)), c.beginPath()) : "cross" === b && (c.strokeStyle = f, c.lineWidth = d / 4, c.beginPath(), c.moveTo(a - d / 2, e - d / 2), c.lineTo(a + d / 2, e + d / 2), c.stroke(), c.moveTo(a + d / 2, e - d / 2), c.lineTo(a - d / 2, e + d / 2), c.stroke());
          }
        }, drawMarkers: function(a) {
          for (var e = 0; e < a.length; e++) {
            var c = a[e];
            X.drawMarker(c.x, c.y, c.ctx, c.type, c.size, c.color, c.borderColor, c.borderThickness);
          }
        } };
        return t;
      }();
      u.version = "v3.12.12 GA";
      window.CanvasJS && (u && !window.CanvasJS.Chart) && (window.CanvasJS.Chart = u);
    })();
    document.createElement("canvas").getContext || function() {
      function V() {
        return this.context_ || (this.context_ = new C(this));
      }
      function W(a, b, c) {
        var g = M.call(arguments, 2);
        return function() {
          return a.apply(b, g.concat(M.call(arguments)));
        };
      }
      function N(a) {
        return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
      }
      function O(a) {
        a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML");
        a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");
        a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}");
      }
      function X(a) {
        var b = a.srcElement;
        switch (a.propertyName) {
          case "width":
            b.getContext().clearRect();
            b.style.width = b.attributes.width.nodeValue + "px";
            b.firstChild.style.width = b.clientWidth + "px";
            break;
          case "height":
            b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight + "px";
        }
      }
      function Y(a) {
        a = a.srcElement;
        a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px");
      }
      function D() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      }
      function t(a, b) {
        for (var c = D(), g = 0; 3 > g; g++) for (var e = 0; 3 > e; e++) {
          for (var f = 0, d2 = 0; 3 > d2; d2++) f += a[g][d2] * b[d2][e];
          c[g][e] = f;
        }
        return c;
      }
      function P(a, b) {
        b.fillStyle = a.fillStyle;
        b.lineCap = a.lineCap;
        b.lineJoin = a.lineJoin;
        b.lineWidth = a.lineWidth;
        b.miterLimit = a.miterLimit;
        b.shadowBlur = a.shadowBlur;
        b.shadowColor = a.shadowColor;
        b.shadowOffsetX = a.shadowOffsetX;
        b.shadowOffsetY = a.shadowOffsetY;
        b.strokeStyle = a.strokeStyle;
        b.globalAlpha = a.globalAlpha;
        b.font = a.font;
        b.textAlign = a.textAlign;
        b.textBaseline = a.textBaseline;
        b.arcScaleX_ = a.arcScaleX_;
        b.arcScaleY_ = a.arcScaleY_;
        b.lineScale_ = a.lineScale_;
      }
      function Q(a) {
        var b = a.indexOf("(", 3), c = a.indexOf(")", b + 1), b = a.substring(b + 1, c).split(",");
        if (4 != b.length || "a" != a.charAt(3)) b[3] = 1;
        return b;
      }
      function E(a, b, c) {
        return Math.min(c, Math.max(b, a));
      }
      function F(a, b, c) {
        0 > c && c++;
        1 < c && c--;
        return 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a;
      }
      function G(a) {
        if (a in H) return H[a];
        var b, c = 1;
        a = String(a);
        if ("#" == a.charAt(0)) b = a;
        else if (/^rgb/.test(a)) {
          c = Q(a);
          b = "#";
          for (var g, e = 0; 3 > e; e++) g = -1 != c[e].indexOf("%") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)];
          c = +c[3];
        } else if (/^hsl/.test(a)) {
          e = c = Q(a);
          b = parseFloat(e[0]) / 360 % 360;
          0 > b && b++;
          g = E(parseFloat(e[1]) / 100, 0, 1);
          e = E(parseFloat(e[2]) / 100, 0, 1);
          if (0 == g) g = e = b = e;
          else {
            var f = 0.5 > e ? e * (1 + g) : e + g - e * g, d2 = 2 * e - f;
            g = F(d2, f, b + 1 / 3);
            e = F(d2, f, b);
            b = F(d2, f, b - 1 / 3);
          }
          b = "#" + v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];
          c = c[3];
        } else b = Z[a] || a;
        return H[a] = { color: b, alpha: c };
      }
      function C(a) {
        this.m_ = D();
        this.mStack_ = [];
        this.aStack_ = [];
        this.currentPath_ = [];
        this.fillStyle = this.strokeStyle = "#000";
        this.lineWidth = 1;
        this.lineJoin = "miter";
        this.lineCap = "butt";
        this.miterLimit = 1 * q;
        this.globalAlpha = 1;
        this.font = "10px sans-serif";
        this.textAlign = "left";
        this.textBaseline = "alphabetic";
        this.canvas = a;
        var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute", c = a.ownerDocument.createElement("div");
        c.style.cssText = b;
        a.appendChild(c);
        b = c.cloneNode(false);
        b.style.backgroundColor = "red";
        b.style.filter = "alpha(opacity=0)";
        a.appendChild(b);
        this.element_ = c;
        this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;
      }
      function R(a, b, c, g) {
        a.currentPath_.push({ type: "bezierCurveTo", cp1x: b.x, cp1y: b.y, cp2x: c.x, cp2y: c.y, x: g.x, y: g.y });
        a.currentX_ = g.x;
        a.currentY_ = g.y;
      }
      function S(a, b) {
        var c = G(a.strokeStyle), g = c.color, c = c.alpha * a.globalAlpha, e = a.lineScale_ * a.lineWidth;
        1 > e && (c *= e);
        b.push(
          "<g_vml_:stroke",
          ' opacity="',
          c,
          '"',
          ' joinstyle="',
          a.lineJoin,
          '"',
          ' miterlimit="',
          a.miterLimit,
          '"',
          ' endcap="',
          $[a.lineCap] || "square",
          '"',
          ' weight="',
          e,
          'px"',
          ' color="',
          g,
          '" />'
        );
      }
      function T(a, b, c, g) {
        var e = a.fillStyle, f = a.arcScaleX_, d2 = a.arcScaleY_, k2 = g.x - c.x, n = g.y - c.y;
        if (e instanceof w) {
          var h = 0, l = g = 0, u = 0, m = 1;
          if ("gradient" == e.type_) {
            h = e.x1_ / f;
            c = e.y1_ / d2;
            var p = s(a, e.x0_ / f, e.y0_ / d2), h = s(a, h, c), h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;
            0 > h && (h += 360);
            1e-6 > h && (h = 0);
          } else p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k2, l = (p.y - c.y) / n, k2 /= f * q, n /= d2 * q, m = x.max(k2, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;
          f = e.colors_;
          f.sort(function(a2, b2) {
            return a2.offset - b2.offset;
          });
          d2 = f.length;
          p = f[0].color;
          c = f[d2 - 1].color;
          k2 = f[0].alpha * a.globalAlpha;
          a = f[d2 - 1].alpha * a.globalAlpha;
          for (var n = [], r2 = 0; r2 < d2; r2++) {
            var t2 = f[r2];
            n.push(t2.offset * m + u + " " + t2.color);
          }
          b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', p, '"', ' color2="', c, '"', ' colors="', n.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', k2, '"', ' angle="', h, '"', ' focusposition="', g, ",", l, '" />');
        } else e instanceof I ? k2 && n && b.push("<g_vml_:fill", ' position="', -c.x / k2 * f * f, ",", -c.y / n * d2 * d2, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />'));
      }
      function s(a, b, c) {
        a = a.m_;
        return { x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r, y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r };
      }
      function z(a, b, c) {
        isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));
      }
      function w(a) {
        this.type_ = a;
        this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;
        this.colors_ = [];
      }
      function I(a, b) {
        if (!a || 1 != a.nodeType || "IMG" != a.tagName) throw new A("TYPE_MISMATCH_ERR");
        if ("complete" != a.readyState) throw new A("INVALID_STATE_ERR");
        switch (b) {
          case "repeat":
          case null:
          case "":
            this.repetition_ = "repeat";
            break;
          case "repeat-x":
          case "repeat-y":
          case "no-repeat":
            this.repetition_ = b;
            break;
          default:
            throw new A("SYNTAX_ERR");
        }
        this.src_ = a.src;
        this.width_ = a.width;
        this.height_ = a.height;
      }
      function A(a) {
        this.code = this[a];
        this.message = a + ": DOM Exception " + this.code;
      }
      var x = Math, k = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2;
      navigator.userAgent.match(/MSIE ([\d.]+)?/);
      var M = Array.prototype.slice;
      O(document);
      var U = { init: function(a) {
        a = a || document;
        a.createElement("canvas");
        a.attachEvent("onreadystatechange", W(this.init_, this, a));
      }, init_: function(a) {
        a = a.getElementsByTagName("canvas");
        for (var b = 0; b < a.length; b++) this.initElement(a[b]);
      }, initElement: function(a) {
        if (!a.getContext) {
          a.getContext = V;
          O(a.ownerDocument);
          a.innerHTML = "";
          a.attachEvent("onpropertychange", X);
          a.attachEvent("onresize", Y);
          var b = a.attributes;
          b.width && b.width.specified ? a.style.width = b.width.nodeValue + "px" : a.width = a.clientWidth;
          b.height && b.height.specified ? a.style.height = b.height.nodeValue + "px" : a.height = a.clientHeight;
        }
        return a;
      } };
      U.init();
      for (var v = [], d = 0; 16 > d; d++) for (var B = 0; 16 > B; B++) v[16 * d + B] = d.toString(16) + B.toString(16);
      var Z = {
        aliceblue: "#F0F8FF",
        antiquewhite: "#FAEBD7",
        aquamarine: "#7FFFD4",
        azure: "#F0FFFF",
        beige: "#F5F5DC",
        bisque: "#FFE4C4",
        black: "#000000",
        blanchedalmond: "#FFEBCD",
        blueviolet: "#8A2BE2",
        brown: "#A52A2A",
        burlywood: "#DEB887",
        cadetblue: "#5F9EA0",
        chartreuse: "#7FFF00",
        chocolate: "#D2691E",
        coral: "#FF7F50",
        cornflowerblue: "#6495ED",
        cornsilk: "#FFF8DC",
        crimson: "#DC143C",
        cyan: "#00FFFF",
        darkblue: "#00008B",
        darkcyan: "#008B8B",
        darkgoldenrod: "#B8860B",
        darkgray: "#A9A9A9",
        darkgreen: "#006400",
        darkgrey: "#A9A9A9",
        darkkhaki: "#BDB76B",
        darkmagenta: "#8B008B",
        darkolivegreen: "#556B2F",
        darkorange: "#FF8C00",
        darkorchid: "#9932CC",
        darkred: "#8B0000",
        darksalmon: "#E9967A",
        darkseagreen: "#8FBC8F",
        darkslateblue: "#483D8B",
        darkslategray: "#2F4F4F",
        darkslategrey: "#2F4F4F",
        darkturquoise: "#00CED1",
        darkviolet: "#9400D3",
        deeppink: "#FF1493",
        deepskyblue: "#00BFFF",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1E90FF",
        firebrick: "#B22222",
        floralwhite: "#FFFAF0",
        forestgreen: "#228B22",
        gainsboro: "#DCDCDC",
        ghostwhite: "#F8F8FF",
        gold: "#FFD700",
        goldenrod: "#DAA520",
        grey: "#808080",
        greenyellow: "#ADFF2F",
        honeydew: "#F0FFF0",
        hotpink: "#FF69B4",
        indianred: "#CD5C5C",
        indigo: "#4B0082",
        ivory: "#FFFFF0",
        khaki: "#F0E68C",
        lavender: "#E6E6FA",
        lavenderblush: "#FFF0F5",
        lawngreen: "#7CFC00",
        lemonchiffon: "#FFFACD",
        lightblue: "#ADD8E6",
        lightcoral: "#F08080",
        lightcyan: "#E0FFFF",
        lightgoldenrodyellow: "#FAFAD2",
        lightgreen: "#90EE90",
        lightgrey: "#D3D3D3",
        lightpink: "#FFB6C1",
        lightsalmon: "#FFA07A",
        lightseagreen: "#20B2AA",
        lightskyblue: "#87CEFA",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#B0C4DE",
        lightyellow: "#FFFFE0",
        limegreen: "#32CD32",
        linen: "#FAF0E6",
        magenta: "#FF00FF",
        mediumaquamarine: "#66CDAA",
        mediumblue: "#0000CD",
        mediumorchid: "#BA55D3",
        mediumpurple: "#9370DB",
        mediumseagreen: "#3CB371",
        mediumslateblue: "#7B68EE",
        mediumspringgreen: "#00FA9A",
        mediumturquoise: "#48D1CC",
        mediumvioletred: "#C71585",
        midnightblue: "#191970",
        mintcream: "#F5FFFA",
        mistyrose: "#FFE4E1",
        moccasin: "#FFE4B5",
        navajowhite: "#FFDEAD",
        oldlace: "#FDF5E6",
        olivedrab: "#6B8E23",
        orange: "#FFA500",
        orangered: "#FF4500",
        orchid: "#DA70D6",
        palegoldenrod: "#EEE8AA",
        palegreen: "#98FB98",
        paleturquoise: "#AFEEEE",
        palevioletred: "#DB7093",
        papayawhip: "#FFEFD5",
        peachpuff: "#FFDAB9",
        peru: "#CD853F",
        pink: "#FFC0CB",
        plum: "#DDA0DD",
        powderblue: "#B0E0E6",
        rosybrown: "#BC8F8F",
        royalblue: "#4169E1",
        saddlebrown: "#8B4513",
        salmon: "#FA8072",
        sandybrown: "#F4A460",
        seagreen: "#2E8B57",
        seashell: "#FFF5EE",
        sienna: "#A0522D",
        skyblue: "#87CEEB",
        slateblue: "#6A5ACD",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#FFFAFA",
        springgreen: "#00FF7F",
        steelblue: "#4682B4",
        tan: "#D2B48C",
        thistle: "#D8BFD8",
        tomato: "#FF6347",
        turquoise: "#40E0D0",
        violet: "#EE82EE",
        wheat: "#F5DEB3",
        whitesmoke: "#F5F5F5",
        yellowgreen: "#9ACD32"
      }, H = {}, L = {}, $ = { butt: "flat", round: "round" }, d = C.prototype;
      d.clearRect = function() {
        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(true), this.textMeasureEl_ = null);
        this.element_.innerHTML = "";
      };
      d.beginPath = function() {
        this.currentPath_ = [];
      };
      d.moveTo = function(a, b) {
        var c = s(this, a, b);
        this.currentPath_.push({ type: "moveTo", x: c.x, y: c.y });
        this.currentX_ = c.x;
        this.currentY_ = c.y;
      };
      d.lineTo = function(a, b) {
        var c = s(this, a, b);
        this.currentPath_.push({ type: "lineTo", x: c.x, y: c.y });
        this.currentX_ = c.x;
        this.currentY_ = c.y;
      };
      d.bezierCurveTo = function(a, b, c, g, e, f) {
        e = s(this, e, f);
        a = s(this, a, b);
        c = s(this, c, g);
        R(this, a, c, e);
      };
      d.quadraticCurveTo = function(a, b, c, g) {
        a = s(this, a, b);
        c = s(this, c, g);
        g = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) };
        R(this, g, { x: g.x + (c.x - this.currentX_) / 3, y: g.y + (c.y - this.currentY_) / 3 }, c);
      };
      d.arc = function(a, b, c, g, e, f) {
        c *= q;
        var d2 = f ? "at" : "wa", k2 = a + K(g) * c - r, n = b + J(g) * c - r;
        g = a + K(e) * c - r;
        e = b + J(e) * c - r;
        k2 != g || f || (k2 += 0.125);
        a = s(this, a, b);
        k2 = s(this, k2, n);
        g = s(this, g, e);
        this.currentPath_.push({
          type: d2,
          x: a.x,
          y: a.y,
          radius: c,
          xStart: k2.x,
          yStart: k2.y,
          xEnd: g.x,
          yEnd: g.y
        });
      };
      d.rect = function(a, b, c, g) {
        this.moveTo(a, b);
        this.lineTo(a + c, b);
        this.lineTo(a + c, b + g);
        this.lineTo(a, b + g);
        this.closePath();
      };
      d.strokeRect = function(a, b, c, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a, b);
        this.lineTo(a + c, b);
        this.lineTo(a + c, b + g);
        this.lineTo(a, b + g);
        this.closePath();
        this.stroke();
        this.currentPath_ = e;
      };
      d.fillRect = function(a, b, c, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a, b);
        this.lineTo(a + c, b);
        this.lineTo(a + c, b + g);
        this.lineTo(a, b + g);
        this.closePath();
        this.fill();
        this.currentPath_ = e;
      };
      d.createLinearGradient = function(a, b, c, g) {
        var e = new w("gradient");
        e.x0_ = a;
        e.y0_ = b;
        e.x1_ = c;
        e.y1_ = g;
        return e;
      };
      d.createRadialGradient = function(a, b, c, g, e, f) {
        var d2 = new w("gradientradial");
        d2.x0_ = a;
        d2.y0_ = b;
        d2.r0_ = c;
        d2.x1_ = g;
        d2.y1_ = e;
        d2.r1_ = f;
        return d2;
      };
      d.drawImage = function(a, b) {
        var c, g, e, d2, r2, y, n, h;
        e = a.runtimeStyle.width;
        d2 = a.runtimeStyle.height;
        a.runtimeStyle.width = "auto";
        a.runtimeStyle.height = "auto";
        var l = a.width, u = a.height;
        a.runtimeStyle.width = e;
        a.runtimeStyle.height = d2;
        if (3 == arguments.length) c = arguments[1], g = arguments[2], r2 = y = 0, n = e = l, h = d2 = u;
        else if (5 == arguments.length) c = arguments[1], g = arguments[2], e = arguments[3], d2 = arguments[4], r2 = y = 0, n = l, h = u;
        else if (9 == arguments.length) r2 = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d2 = arguments[8];
        else throw Error("Invalid number of arguments");
        var m = s(this, c, g), p = [];
        p.push(
          " <g_vml_:group",
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' coordorigin="0,0"',
          ' style="width:',
          10,
          "px;height:",
          10,
          "px;position:absolute;"
        );
        if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
          var t2 = [];
          t2.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k(m.x / q), ",", "Dy=", k(m.y / q), "");
          var v2 = s(this, c + e, g), w2 = s(this, c, g + d2);
          c = s(this, c + e, g + d2);
          m.x = x.max(m.x, v2.x, w2.x, c.x);
          m.y = x.max(m.y, v2.y, w2.y, c.y);
          p.push("padding:0 ", k(m.x / q), "px ", k(m.y / q), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", t2.join(""), ", sizingmethod='clip');");
        } else p.push(
          "top:",
          k(m.y / q),
          "px;left:",
          k(m.x / q),
          "px;"
        );
        p.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', q * e, "px;", " height:", q * d2, 'px"', ' cropleft="', r2 / l, '"', ' croptop="', y / u, '"', ' cropright="', (l - r2 - n) / l, '"', ' cropbottom="', (u - y - h) / u, '"', " />", "</g_vml_:group>");
        this.element_.insertAdjacentHTML("BeforeEnd", p.join(""));
      };
      d.stroke = function(a) {
        var b = [];
        b.push(
          "<g_vml_:shape",
          ' filled="',
          !!a,
          '"',
          ' style="position:absolute;width:',
          10,
          "px;height:",
          10,
          'px;"',
          ' coordorigin="0,0"',
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' stroked="',
          !a,
          '"',
          ' path="'
        );
        for (var c = { x: null, y: null }, d2 = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {
          var f = this.currentPath_[e];
          switch (f.type) {
            case "moveTo":
              b.push(" m ", k(f.x), ",", k(f.y));
              break;
            case "lineTo":
              b.push(" l ", k(f.x), ",", k(f.y));
              break;
            case "close":
              b.push(" x ");
              f = null;
              break;
            case "bezierCurveTo":
              b.push(" c ", k(f.cp1x), ",", k(f.cp1y), ",", k(f.cp2x), ",", k(f.cp2y), ",", k(f.x), ",", k(f.y));
              break;
            case "at":
            case "wa":
              b.push(" ", f.type, " ", k(f.x - this.arcScaleX_ * f.radius), ",", k(f.y - this.arcScaleY_ * f.radius), " ", k(f.x + this.arcScaleX_ * f.radius), ",", k(f.y + this.arcScaleY_ * f.radius), " ", k(f.xStart), ",", k(f.yStart), " ", k(f.xEnd), ",", k(f.yEnd));
          }
          if (f) {
            if (null == c.x || f.x < c.x) c.x = f.x;
            if (null == d2.x || f.x > d2.x) d2.x = f.x;
            if (null == c.y || f.y < c.y) c.y = f.y;
            if (null == d2.y || f.y > d2.y) d2.y = f.y;
          }
        }
        b.push(' ">');
        a ? T(this, b, c, d2) : S(this, b);
        b.push("</g_vml_:shape>");
        this.element_.insertAdjacentHTML("beforeEnd", b.join(""));
      };
      d.fill = function() {
        this.stroke(true);
      };
      d.closePath = function() {
        this.currentPath_.push({ type: "close" });
      };
      d.save = function() {
        var a = {};
        P(this, a);
        this.aStack_.push(a);
        this.mStack_.push(this.m_);
        this.m_ = t(D(), this.m_);
      };
      d.restore = function() {
        this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());
      };
      d.translate = function(a, b) {
        z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), false);
      };
      d.rotate = function(a) {
        var b = K(a);
        a = J(a);
        z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), false);
      };
      d.scale = function(a, b) {
        this.arcScaleX_ *= a;
        this.arcScaleY_ *= b;
        z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), true);
      };
      d.transform = function(a, b, c, d2, e, f) {
        z(this, t([[
          a,
          b,
          0
        ], [c, d2, 0], [e, f, 1]], this.m_), true);
      };
      d.setTransform = function(a, b, c, d2, e, f) {
        z(this, [[a, b, 0], [c, d2, 0], [e, f, 1]], true);
      };
      d.drawText_ = function(a, b, c, d2, e) {
        var f = this.m_;
        d2 = 0;
        var r2 = 1e3, t2 = 0, n = [], h;
        h = this.font;
        if (L[h]) h = L[h];
        else {
          var l = document.createElement("div").style;
          try {
            l.font = h;
          } catch (u) {
          }
          h = L[h] = { style: l.fontStyle || "normal", variant: l.fontVariant || "normal", weight: l.fontWeight || "normal", size: l.fontSize || 10, family: l.fontFamily || "sans-serif" };
        }
        var l = h, m = this.element_;
        h = {};
        for (var p in l) h[p] = l[p];
        p = parseFloat(m.currentStyle.fontSize);
        m = parseFloat(l.size);
        "number" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf("px") ? h.size = m : -1 != l.size.indexOf("em") ? h.size = p * m : -1 != l.size.indexOf("%") ? h.size = p / 100 * m : -1 != l.size.indexOf("pt") ? h.size = m / 0.75 : h.size = p;
        h.size *= 0.981;
        p = h.style + " " + h.variant + " " + h.weight + " " + h.size + "px " + h.family;
        m = this.element_.currentStyle;
        l = this.textAlign.toLowerCase();
        switch (l) {
          case "left":
          case "center":
          case "right":
            break;
          case "end":
            l = "ltr" == m.direction ? "right" : "left";
            break;
          case "start":
            l = "rtl" == m.direction ? "right" : "left";
            break;
          default:
            l = "left";
        }
        switch (this.textBaseline) {
          case "hanging":
          case "top":
            t2 = h.size / 1.75;
            break;
          case "middle":
            break;
          default:
          case null:
          case "alphabetic":
          case "ideographic":
          case "bottom":
            t2 = -h.size / 2.25;
        }
        switch (l) {
          case "right":
            d2 = 1e3;
            r2 = 0.05;
            break;
          case "center":
            d2 = r2 = 500;
        }
        b = s(this, b + 0, c + t2);
        n.push('<g_vml_:line from="', -d2, ' 0" to="', r2, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !e, '" stroked="', !!e, '" style="position:absolute;width:1px;height:1px;">');
        e ? S(this, n) : T(
          this,
          n,
          { x: -d2, y: 0 },
          { x: r2, y: h.size }
        );
        e = f[0][0].toFixed(3) + "," + f[1][0].toFixed(3) + "," + f[0][1].toFixed(3) + "," + f[1][1].toFixed(3) + ",0,0";
        b = k(b.x / q) + "," + k(b.y / q);
        n.push('<g_vml_:skew on="t" matrix="', e, '" ', ' offset="', b, '" origin="', d2, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', N(a), '" style="v-text-align:', l, ";font:", N(p), '" /></g_vml_:line>');
        this.element_.insertAdjacentHTML("beforeEnd", n.join(""));
      };
      d.fillText = function(a, b, c, d2) {
        this.drawText_(a, b, c, d2, false);
      };
      d.strokeText = function(a, b, c, d2) {
        this.drawText_(a, b, c, d2, true);
      };
      d.measureText = function(a) {
        this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild);
        var b = this.element_.ownerDocument;
        this.textMeasureEl_.innerHTML = "";
        this.textMeasureEl_.style.font = this.font;
        this.textMeasureEl_.appendChild(b.createTextNode(a));
        return { width: this.textMeasureEl_.offsetWidth };
      };
      d.clip = function() {
      };
      d.arcTo = function() {
      };
      d.createPattern = function(a, b) {
        return new I(a, b);
      };
      w.prototype.addColorStop = function(a, b) {
        b = G(b);
        this.colors_.push({ offset: a, color: b.color, alpha: b.alpha });
      };
      d = A.prototype = Error();
      d.INDEX_SIZE_ERR = 1;
      d.DOMSTRING_SIZE_ERR = 2;
      d.HIERARCHY_REQUEST_ERR = 3;
      d.WRONG_DOCUMENT_ERR = 4;
      d.INVALID_CHARACTER_ERR = 5;
      d.NO_DATA_ALLOWED_ERR = 6;
      d.NO_MODIFICATION_ALLOWED_ERR = 7;
      d.NOT_FOUND_ERR = 8;
      d.NOT_SUPPORTED_ERR = 9;
      d.INUSE_ATTRIBUTE_ERR = 10;
      d.INVALID_STATE_ERR = 11;
      d.SYNTAX_ERR = 12;
      d.INVALID_MODIFICATION_ERR = 13;
      d.NAMESPACE_ERR = 14;
      d.INVALID_ACCESS_ERR = 15;
      d.VALIDATION_ERR = 16;
      d.TYPE_MISMATCH_ERR = 17;
      G_vmlCanvasManager = U;
      CanvasRenderingContext2D = C;
      CanvasGradient = w;
      CanvasPattern = I;
      DOMException = A;
    }();
  }
});

// node_modules/@canvasjs/react-charts/canvasjs.react.js
var React = require_react();
var CanvasJS = require_canvasjs_min();
CanvasJS = CanvasJS.Chart ? CanvasJS : window.CanvasJS;
var CanvasJSChart = class extends React.Component {
  constructor(props) {
    super(props);
    this.options = props.options ? props.options : {};
    this.containerProps = props.containerProps ? { ...props.containerProps } : { width: "100%", position: "relative" };
    this.containerProps.height = props.containerProps && props.containerProps.height ? props.containerProps.height : this.options.height ? this.options.height + "px" : "400px";
    this.containerRef = React.createRef();
  }
  componentDidMount() {
    this.chart = new CanvasJS.Chart(this.containerRef.current, this.options);
    this.chart.render();
    if (this.props.onRef)
      this.props.onRef(this.chart);
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !(nextProps.options === this.options);
  }
  componentDidUpdate() {
    this.chart.options = this.props.options;
    this.chart.render();
  }
  componentWillUnmount() {
    if (this.chart)
      this.chart.destroy();
    if (this.props.onRef)
      this.props.onRef(void 0);
  }
  render() {
    return React.createElement("div", { id: this.props.id, ref: this.containerRef, style: this.containerProps });
  }
};
var CanvasJSReact = {
  CanvasJSChart,
  CanvasJS
};
var canvasjs_react_default = CanvasJSReact;
export {
  canvasjs_react_default as default
};
//# sourceMappingURL=@canvasjs_react-charts.js.map
